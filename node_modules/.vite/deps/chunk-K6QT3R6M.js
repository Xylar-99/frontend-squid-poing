import {
  ThinEngine,
  init_thinEngine
} from "./chunk-R4SYYAYE.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js
var init_engine_alpha = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js"() {
    init_thinEngine();
    ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange = false) {
      if (this._alphaMode === mode) {
        if (!noDepthWriteChange) {
          const depthMask = mode === 0;
          if (this.depthCullingState.depthMask !== depthMask) {
            this.depthCullingState.depthMask = depthMask;
          }
        }
        return;
      }
      switch (mode) {
        case 0:
          this._alphaState.alphaBlend = false;
          break;
        case 7:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 8:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 2:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 6:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 1:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 3:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 4:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 5:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 9:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 10:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 11:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 12:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 13:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 14:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 15:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 16:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 17:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
      }
      if (!noDepthWriteChange) {
        this.depthCullingState.depthMask = mode === 0;
      }
      this._alphaMode = mode;
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js
var init_engine_dynamicBuffer = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js"() {
    init_thinEngine();
    ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset = 0) {
      this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
      this.bindIndexBuffer(indexBuffer);
      let view;
      if (indexBuffer.is32Bits) {
        view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
      } else {
        view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
      }
      this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);
      this._resetIndexBufferBinding();
    };
    ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
      this.bindArrayBuffer(vertexBuffer);
      if (byteOffset === void 0) {
        byteOffset = 0;
      }
      const dataLength = data.byteLength || data.length;
      if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
        } else {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
      } else {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data).subarray(0, byteLength / 4));
        } else {
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data, 0, byteLength);
          } else {
            data = new Uint8Array(data.buffer, data.byteOffset, byteLength);
          }
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
      }
      this._resetVertexBufferBinding();
    };
  }
});

export {
  init_engine_alpha,
  init_engine_dynamicBuffer
};
//# sourceMappingURL=chunk-K6QT3R6M.js.map
