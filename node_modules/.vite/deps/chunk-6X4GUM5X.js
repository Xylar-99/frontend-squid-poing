import {
  CreatePlane,
  init_planeBuilder
} from "./chunk-7GPYL2GD.js";
import {
  HemisphericLight,
  init_hemisphericLight
} from "./chunk-LAMSNEUU.js";
import {
  Mesh,
  init_mesh
} from "./chunk-SLNQLWMK.js";
import {
  TransformNode,
  init_transformNode
} from "./chunk-TKSFKGF2.js";
import {
  Camera,
  init_camera
} from "./chunk-WHBMKD76.js";
import {
  Light,
  init_light
} from "./chunk-MGZMLHJ7.js";
import {
  ThinEngine,
  init_thinEngine
} from "./chunk-R4SYYAYE.js";
import {
  IntersectionInfo,
  Material,
  init_intersectionInfo,
  init_material
} from "./chunk-GQ3TXI7S.js";
import {
  Scene,
  _ImportHelper,
  init_import_helper,
  init_scene
} from "./chunk-DR3K4Z6K.js";
import {
  UniqueIdGenerator,
  init_uniqueIdGenerator
} from "./chunk-LNOUESAW.js";
import {
  PickingInfo,
  SceneComponentConstants,
  init_pickingInfo,
  init_sceneComponent
} from "./chunk-J6IZTA6X.js";
import {
  PointerEventTypes,
  PointerInfo,
  init_pointerEvents
} from "./chunk-V2QI3I5N.js";
import {
  Texture,
  init_texture
} from "./chunk-FF2BXABR.js";
import {
  DrawWrapper,
  init_drawWrapper
} from "./chunk-QCHJ7PFC.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-5UL5TUIP.js";
import {
  Tools,
  init_tools
} from "./chunk-RBASUMGO.js";
import {
  GetExponentOfTwo,
  init_tools_functions
} from "./chunk-YTLDOPO3.js";
import {
  InternalTexture,
  init_internalTexture
} from "./chunk-KKMPA6IU.js";
import {
  Logger,
  init_logger
} from "./chunk-RB67CL7C.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize
} from "./chunk-56URP3F6.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  init_math_vector
} from "./chunk-3SMC2E6I.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-LZS7X66T.js";
import {
  Observable,
  init_observable
} from "./chunk-H6EIW4LR.js";
import {
  Color3,
  Color4,
  init_math_color
} from "./chunk-52D66CJC.js";
import {
  BuildArray,
  Epsilon,
  init_arrayTools,
  init_math_constants
} from "./chunk-LNF52JT4.js";
import {
  GetClass,
  init_typeStore
} from "./chunk-FYD2IJRD.js";
import {
  Clamp,
  HighestCommonFactor,
  init_math_scalar_functions,
  math_scalar_functions_exports
} from "./chunk-4MN3UCXJ.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js
var FadeInOutBehavior;
var init_fadeInOutBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js"() {
    FadeInOutBehavior = class {
      /**
       * Time in milliseconds to delay before fading in (Default: 0)
       * Will set both fade in and out delay to the same value
       */
      get delay() {
        return this.fadeInDelay;
      }
      set delay(value) {
        this.fadeInDelay = value;
        this.fadeOutDelay = value;
      }
      /**
       * Instantiates the FadeInOutBehavior
       */
      constructor() {
        this.fadeInDelay = 0;
        this.fadeOutDelay = 0;
        this.fadeInTime = 300;
        this.fadeOutTime = 300;
        this._millisecondsPerFrame = 1e3 / 60;
        this._hovered = false;
        this._hoverValue = 0;
        this._ownerNode = null;
        this._delay = 0;
        this._time = 300;
        this._update = () => {
          if (this._ownerNode) {
            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;
            this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);
            if (this._ownerNode.visibility > 1) {
              this._setAllVisibility(this._ownerNode, 1);
              if (this._hoverValue > this._time) {
                this._hoverValue = this._time;
                this._detachObserver();
                return;
              }
            } else if (this._ownerNode.visibility < 0) {
              this._setAllVisibility(this._ownerNode, 0);
              if (this._hoverValue < 0) {
                this._hoverValue = 0;
                this._detachObserver();
                return;
              }
            }
            this._attachObserver();
          }
        };
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "FadeInOut";
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * Attaches the fade behavior on the passed in mesh
       * @param ownerNode The mesh that will be faded in/out once attached
       */
      attach(ownerNode) {
        this._ownerNode = ownerNode;
        this._setAllVisibility(this._ownerNode, 0);
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        this._ownerNode = null;
      }
      /**
       * Triggers the mesh to begin fading in (or out)
       * @param fadeIn if the object should fade in or out (true to fade in)
       */
      fadeIn(fadeIn = true) {
        this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;
        this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;
        this._detachObserver();
        if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {
          return;
        }
        this._hovered = fadeIn;
        if (!this._hovered) {
          this._delay *= -1;
        }
        if (this._ownerNode.visibility >= 1) {
          this._hoverValue = this._time;
        } else if (this._ownerNode.visibility <= 0) {
          this._hoverValue = 0;
        }
        this._update();
      }
      /**
       * Triggers the mesh to begin fading out
       */
      fadeOut() {
        this.fadeIn(false);
      }
      _setAllVisibility(mesh, value) {
        mesh.visibility = value;
        mesh.getChildMeshes().forEach((c) => {
          this._setAllVisibility(c, value);
        });
      }
      _attachObserver() {
        var _a;
        if (!this._onBeforeRenderObserver) {
          this._onBeforeRenderObserver = (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);
        }
      }
      _detachObserver() {
        var _a;
        if (this._onBeforeRenderObserver) {
          (_a = this._ownerNode) == null ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
          this._onBeforeRenderObserver = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Culling/ray.core.js
function CreatePickingRay(scene, x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);
  return result;
}
function CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    return scene;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return scene;
}
function CreatePickingRayInCameraSpace(scene, x, y, camera) {
  const result = Ray.Zero();
  CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);
  return result;
}
function CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera) {
  if (!PickingInfo) {
    return scene;
  }
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return scene;
}
function InternalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
}
function InternalPick(scene, rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
}
function InternalMultiPick(scene, rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
}
function PickWithBoundingInfo(scene, x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = InternalPick(scene, (world) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);
    return scene._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function Pick(scene, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = InternalPick(scene, (world, enableDistantPicking) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);
    return scene._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function PickWithRay(scene, ray, predicate, fastCheck, trianglePredicate) {
  const result = InternalPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
}
function MultiPick(scene, x, y, predicate, camera, trianglePredicate) {
  return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);
}
function MultiPickWithRay(scene, ray, predicate, trianglePredicate) {
  return InternalMultiPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, trianglePredicate);
}
function GetForwardRay(camera, length = 100, transform, origin) {
  return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
}
function GetForwardRayToRef(camera, refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = camera.getWorldMatrix();
  }
  refRay.length = length;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(camera.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
}
function AddRayExtensions(sceneClass, cameraClass) {
  if (cameraClass) {
    cameraClass.prototype.getForwardRay = function(length = 100, transform, origin) {
      return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
    };
    cameraClass.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
      return GetForwardRayToRef(this, refRay, length, transform, origin);
    };
  }
  if (!sceneClass) {
    return;
  }
  _ImportHelper._IsPickingAvailable = true;
  sceneClass.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
    return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);
  };
}
var PickingCustomization, Ray;
var init_ray_core = __esm({
  "node_modules/@babylonjs/core/Culling/ray.core.js"() {
    init_math_constants();
    init_math_vector();
    init_arrayTools();
    init_intersectionInfo();
    init_pickingInfo();
    init_engineStore();
    init_import_helper();
    PickingCustomization = {
      internalPickerForMesh: void 0
    };
    Ray = class _Ray {
      /**
       * Creates a new ray
       * @param origin origin point
       * @param direction direction
       * @param length length of the ray
       * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)
       */
      constructor(origin, direction, length = Number.MAX_VALUE, epsilon = Epsilon) {
        this.origin = origin;
        this.direction = direction;
        this.length = length;
        this.epsilon = epsilon;
      }
      // Methods
      /**
       * Clone the current ray
       * @returns a new ray
       */
      clone() {
        return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
      }
      /**
       * Checks if the ray intersects a box
       * This does not account for the ray length by design to improve perfs.
       * @param minimum bound of the box
       * @param maximum bound of the box
       * @param intersectionTreshold extra extend to be added to the box in all direction
       * @returns if the box was hit
       */
      intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
        const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
        const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
        let d = 0;
        let maxValue = Number.MAX_VALUE;
        let inv;
        let min;
        let max;
        let temp;
        if (Math.abs(this.direction.x) < 1e-7) {
          if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
            return false;
          }
        } else {
          inv = 1 / this.direction.x;
          min = (newMinimum.x - this.origin.x) * inv;
          max = (newMaximum.x - this.origin.x) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        if (Math.abs(this.direction.y) < 1e-7) {
          if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
            return false;
          }
        } else {
          inv = 1 / this.direction.y;
          min = (newMinimum.y - this.origin.y) * inv;
          max = (newMaximum.y - this.origin.y) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        if (Math.abs(this.direction.z) < 1e-7) {
          if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
            return false;
          }
        } else {
          inv = 1 / this.direction.z;
          min = (newMinimum.z - this.origin.z) * inv;
          max = (newMaximum.z - this.origin.z) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        return true;
      }
      /**
       * Checks if the ray intersects a box
       * This does not account for the ray lenght by design to improve perfs.
       * @param box the bounding box to check
       * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
       * @returns if the box was hit
       */
      intersectsBox(box, intersectionTreshold = 0) {
        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
      }
      /**
       * If the ray hits a sphere
       * @param sphere the bounding sphere to check
       * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
       * @returns true if it hits the sphere
       */
      intersectsSphere(sphere, intersectionTreshold = 0) {
        const x = sphere.center.x - this.origin.x;
        const y = sphere.center.y - this.origin.y;
        const z = sphere.center.z - this.origin.z;
        const pyth = x * x + y * y + z * z;
        const radius = sphere.radius + intersectionTreshold;
        const rr = radius * radius;
        if (pyth <= rr) {
          return true;
        }
        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
        if (dot < 0) {
          return false;
        }
        const temp = pyth - dot * dot;
        return temp <= rr;
      }
      /**
       * If the ray hits a triange
       * @param vertex0 triangle vertex
       * @param vertex1 triangle vertex
       * @param vertex2 triangle vertex
       * @returns intersection information if hit
       */
      intersectsTriangle(vertex0, vertex1, vertex2) {
        const edge1 = _Ray._TmpVector3[0];
        const edge2 = _Ray._TmpVector3[1];
        const pvec = _Ray._TmpVector3[2];
        const tvec = _Ray._TmpVector3[3];
        const qvec = _Ray._TmpVector3[4];
        vertex1.subtractToRef(vertex0, edge1);
        vertex2.subtractToRef(vertex0, edge2);
        Vector3.CrossToRef(this.direction, edge2, pvec);
        const det = Vector3.Dot(edge1, pvec);
        if (det === 0) {
          return null;
        }
        const invdet = 1 / det;
        this.origin.subtractToRef(vertex0, tvec);
        const bv = Vector3.Dot(tvec, pvec) * invdet;
        if (bv < -this.epsilon || bv > 1 + this.epsilon) {
          return null;
        }
        Vector3.CrossToRef(tvec, edge1, qvec);
        const bw = Vector3.Dot(this.direction, qvec) * invdet;
        if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
          return null;
        }
        const distance = Vector3.Dot(edge2, qvec) * invdet;
        if (distance > this.length) {
          return null;
        }
        return new IntersectionInfo(1 - bv - bw, bv, distance);
      }
      /**
       * Checks if ray intersects a plane
       * @param plane the plane to check
       * @returns the distance away it was hit
       */
      intersectsPlane(plane) {
        let distance;
        const result1 = Vector3.Dot(plane.normal, this.direction);
        if (Math.abs(result1) < 999999997475243e-21) {
          return null;
        } else {
          const result2 = Vector3.Dot(plane.normal, this.origin);
          distance = (-plane.d - result2) / result1;
          if (distance < 0) {
            if (distance < -999999997475243e-21) {
              return null;
            } else {
              return 0;
            }
          }
          return distance;
        }
      }
      /**
       * Calculate the intercept of a ray on a given axis
       * @param axis to check 'x' | 'y' | 'z'
       * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
       * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
       */
      intersectsAxis(axis, offset = 0) {
        switch (axis) {
          case "y": {
            const t = (this.origin.y - offset) / this.direction.y;
            if (t > 0) {
              return null;
            }
            return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
          }
          case "x": {
            const t = (this.origin.x - offset) / this.direction.x;
            if (t > 0) {
              return null;
            }
            return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
          }
          case "z": {
            const t = (this.origin.z - offset) / this.direction.z;
            if (t > 0) {
              return null;
            }
            return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
          }
          default:
            return null;
        }
      }
      /**
       * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
       * irrespective of orientation.
       * @param mesh the mesh to check
       * @param fastCheck defines if the first intersection will be used (and not the closest)
       * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
       * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
       * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
       * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
       * @returns picking info of the intersection
       */
      intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
        const tm = TmpVectors.Matrix[0];
        mesh.getWorldMatrix().invertToRef(tm);
        if (this._tmpRay) {
          _Ray.TransformToRef(this, tm, this._tmpRay);
        } else {
          this._tmpRay = _Ray.Transform(this, tm);
        }
        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
      }
      /**
       * Checks if ray intersects a mesh
       * @param meshes the meshes to check
       * @param fastCheck defines if the first intersection will be used (and not the closest)
       * @param results array to store result in
       * @returns Array of picking infos
       */
      intersectsMeshes(meshes, fastCheck, results) {
        if (results) {
          results.length = 0;
        } else {
          results = [];
        }
        for (let i = 0; i < meshes.length; i++) {
          const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
          if (pickInfo.hit) {
            results.push(pickInfo);
          }
        }
        results.sort(this._comparePickingInfo);
        return results;
      }
      _comparePickingInfo(pickingInfoA, pickingInfoB) {
        if (pickingInfoA.distance < pickingInfoB.distance) {
          return -1;
        } else if (pickingInfoA.distance > pickingInfoB.distance) {
          return 1;
        } else {
          return 0;
        }
      }
      /**
       * Intersection test between the ray and a given segment within a given tolerance (threshold)
       * @param sega the first point of the segment to test the intersection against
       * @param segb the second point of the segment to test the intersection against
       * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
       * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
       */
      intersectionSegment(sega, segb, threshold) {
        const o = this.origin;
        const u = TmpVectors.Vector3[0];
        const rsegb = TmpVectors.Vector3[1];
        const v = TmpVectors.Vector3[2];
        const w = TmpVectors.Vector3[3];
        segb.subtractToRef(sega, u);
        this.direction.scaleToRef(_Ray._Rayl, v);
        o.addToRef(v, rsegb);
        sega.subtractToRef(o, w);
        const a = Vector3.Dot(u, u);
        const b = Vector3.Dot(u, v);
        const c = Vector3.Dot(v, v);
        const d = Vector3.Dot(u, w);
        const e = Vector3.Dot(v, w);
        const D = a * c - b * b;
        let sN, sD = D;
        let tN, tD = D;
        if (D < _Ray._Smallnum) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0) {
            sN = 0;
          } else if (-d > a) {
            sN = sD;
          } else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0) {
            sN = 0;
          } else if (-d + b > a) {
            sN = sD;
          } else {
            sN = -d + b;
            sD = a;
          }
        }
        const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
        const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
        const qtc = TmpVectors.Vector3[4];
        v.scaleToRef(tc, qtc);
        const qsc = TmpVectors.Vector3[5];
        u.scaleToRef(sc, qsc);
        qsc.addInPlace(w);
        const dP = TmpVectors.Vector3[6];
        qsc.subtractToRef(qtc, dP);
        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
        if (isIntersected) {
          return qsc.length();
        }
        return -1;
      }
      /**
       * Update the ray from viewport position
       * @param x position
       * @param y y position
       * @param viewportWidth viewport width
       * @param viewportHeight viewport height
       * @param world world matrix
       * @param view view matrix
       * @param projection projection matrix
       * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
       * @returns this ray updated
       */
      update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
        if (enableDistantPicking) {
          if (!_Ray._RayDistant) {
            _Ray._RayDistant = _Ray.Zero();
          }
          _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
          const tm = TmpVectors.Matrix[0];
          world.invertToRef(tm);
          _Ray.TransformToRef(_Ray._RayDistant, tm, this);
        } else {
          this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
        }
        return this;
      }
      // Statics
      /**
       * Creates a ray with origin and direction of 0,0,0
       * @returns the new ray
       */
      static Zero() {
        return new _Ray(Vector3.Zero(), Vector3.Zero());
      }
      /**
       * Creates a new ray from screen space and viewport
       * @param x position
       * @param y y position
       * @param viewportWidth viewport width
       * @param viewportHeight viewport height
       * @param world world matrix
       * @param view view matrix
       * @param projection projection matrix
       * @returns new ray
       */
      static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
        const result = _Ray.Zero();
        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
      }
      /**
       * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
       * transformed to the given world matrix.
       * @param origin The origin point
       * @param end The end point
       * @param world a matrix to transform the ray to. Default is the identity matrix.
       * @returns the new ray
       */
      static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
        const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        return _Ray.CreateFromToToRef(origin, end, result, world);
      }
      /**
       * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
       * transformed to the given world matrix.
       * @param origin The origin point
       * @param end The end point
       * @param result the object to store the result
       * @param world a matrix to transform the ray to. Default is the identity matrix.
       * @returns the ref ray
       */
      static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
        result.origin.copyFrom(origin);
        const direction = end.subtractToRef(origin, result.direction);
        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        result.length = length;
        result.direction.normalize();
        return _Ray.TransformToRef(result, world, result);
      }
      /**
       * Transforms a ray by a matrix
       * @param ray ray to transform
       * @param matrix matrix to apply
       * @returns the resulting new ray
       */
      static Transform(ray, matrix) {
        const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        _Ray.TransformToRef(ray, matrix, result);
        return result;
      }
      /**
       * Transforms a ray by a matrix
       * @param ray ray to transform
       * @param matrix matrix to apply
       * @param result ray to store result in
       * @returns the updated result ray
       */
      static TransformToRef(ray, matrix, result) {
        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
        result.length = ray.length;
        result.epsilon = ray.epsilon;
        const dir = result.direction;
        const len = dir.length();
        if (!(len === 0 || len === 1)) {
          const num = 1 / len;
          dir.x *= num;
          dir.y *= num;
          dir.z *= num;
          result.length *= len;
        }
        return result;
      }
      /**
       * Unproject a ray from screen space to object space
       * @param sourceX defines the screen space x coordinate to use
       * @param sourceY defines the screen space y coordinate to use
       * @param viewportWidth defines the current width of the viewport
       * @param viewportHeight defines the current height of the viewport
       * @param world defines the world matrix to use (can be set to Identity to go to world space)
       * @param view defines the view matrix to use
       * @param projection defines the projection matrix to use
       */
      unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
        const matrix = TmpVectors.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        matrix.invert();
        const engine = EngineStore.LastCreatedEngine;
        const nearScreenSource = TmpVectors.Vector3[0];
        nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
        nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
        nearScreenSource.z = (engine == null ? void 0 : engine.useReverseDepthBuffer) ? 1 : (engine == null ? void 0 : engine.isNDCHalfZRange) ? 0 : -1;
        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
        const nearVec3 = TmpVectors.Vector3[2];
        const farVec3 = TmpVectors.Vector3[3];
        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
        this.origin.copyFrom(nearVec3);
        farVec3.subtractToRef(nearVec3, this.direction);
        this.direction.normalize();
      }
    };
    Ray._TmpVector3 = BuildArray(6, Vector3.Zero);
    Ray._RayDistant = Ray.Zero();
    Ray._Smallnum = 1e-8;
    Ray._Rayl = 1e9;
  }
});

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools;
var init_pivotTools = __esm({
  "node_modules/@babylonjs/core/Misc/pivotTools.js"() {
    init_math_vector();
    PivotTools = class _PivotTools {
      /**
       * @internal
       */
      static _RemoveAndStorePivotPoint(mesh) {
        if (mesh && _PivotTools._PivotCached === 0) {
          mesh.getPivotPointToRef(_PivotTools._OldPivotPoint);
          _PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
          if (!_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
            mesh.setPivotMatrix(Matrix.IdentityReadOnly);
            _PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), _PivotTools._PivotTranslation);
            _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
            _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
            _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
            mesh.position.addInPlace(_PivotTools._PivotTmpVector);
          }
        }
        _PivotTools._PivotCached++;
      }
      /**
       * @internal
       */
      static _RestorePivotPoint(mesh) {
        if (mesh && !_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && _PivotTools._PivotCached === 1) {
          mesh.setPivotPoint(_PivotTools._OldPivotPoint);
          mesh._postMultiplyPivotMatrix = _PivotTools._PivotPostMultiplyPivotMatrix;
          _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
          _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
          _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
          mesh.position.subtractInPlace(_PivotTools._PivotTmpVector);
        }
        this._PivotCached--;
      }
    };
    PivotTools._PivotCached = 0;
    PivotTools._OldPivotPoint = new Vector3();
    PivotTools._PivotTranslation = new Vector3();
    PivotTools._PivotTmpVector = new Vector3();
    PivotTools._PivotPostMultiplyPivotMatrix = false;
  }
});

// node_modules/@babylonjs/core/Culling/ray.js
var init_ray = __esm({
  "node_modules/@babylonjs/core/Culling/ray.js"() {
    init_scene();
    init_camera();
    init_ray_core();
    init_ray_core();
    AddRayExtensions(Scene, Camera);
    Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
      return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);
    };
    Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
      return CreatePickingRayInCameraSpace(this, x, y, camera);
    };
    Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
      return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);
    };
    Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
      return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);
    };
    Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
      return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);
    };
    Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
      return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);
    };
    Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
      return MultiPick(this, x, y, predicate, camera, trianglePredicate);
    };
    Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
      return MultiPickWithRay(this, ray, predicate, trianglePredicate);
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior;
var init_pointerDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js"() {
    init_mesh();
    init_scene();
    init_observable();
    init_math_vector();
    init_pointerEvents();
    init_ray();
    init_pivotTools();
    init_planeBuilder();
    init_math_constants();
    PointerDragBehavior = class _PointerDragBehavior {
      /**
       * Get or set the currentDraggingPointerId
       * @deprecated Please use currentDraggingPointerId instead
       */
      get currentDraggingPointerID() {
        return this.currentDraggingPointerId;
      }
      set currentDraggingPointerID(currentDraggingPointerID) {
        this.currentDraggingPointerId = currentDraggingPointerID;
      }
      /**
       *  If the drag behavior will react to drag events (Default: true)
       */
      set enabled(value) {
        if (value != this._enabled) {
          this.onEnabledObservable.notifyObservers(value);
        }
        this._enabled = value;
      }
      get enabled() {
        return this._enabled;
      }
      /**
       * Gets the options used by the behavior
       */
      get options() {
        return this._options;
      }
      /**
       * Sets the options used by the behavior
       */
      set options(options) {
        this._options = options;
      }
      /**
       * Creates a pointer drag behavior that can be attached to a mesh
       * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
       * @param options.dragAxis
       * @param options.dragPlaneNormal
       */
      constructor(options) {
        this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
        this._activeDragButton = -1;
        this.maxDragAngle = 0;
        this.dragButtons = [0, 1, 2];
        this._useAlternatePickedPointAboveMaxDragAngle = false;
        this.currentDraggingPointerId = -1;
        this.dragging = false;
        this.dragDeltaRatio = 0.2;
        this.updateDragPlane = true;
        this._debugMode = false;
        this._moving = false;
        this.onDragObservable = new Observable();
        this.onDragStartObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this.onEnabledObservable = new Observable();
        this.moveAttached = true;
        this._enabled = true;
        this.startAndReleaseDragOnPointerEvents = true;
        this.detachCameraControls = true;
        this.useObjectOrientationForDragging = true;
        this.validateDrag = (target) => {
          return true;
        };
        this._tmpVector = new Vector3(0, 0, 0);
        this._alternatePickedPoint = new Vector3(0, 0, 0);
        this._worldDragAxis = new Vector3(0, 0, 0);
        this._targetPosition = new Vector3(0, 0, 0);
        this._attachedToElement = false;
        this._startDragRay = new Ray(new Vector3(), new Vector3());
        this._lastPointerRay = {};
        this._dragDelta = new Vector3();
        this._pointA = new Vector3(0, 0, 0);
        this._pointC = new Vector3(0, 0, 0);
        this._localAxis = new Vector3(0, 0, 0);
        this._lookAt = new Vector3(0, 0, 0);
        this._options = options ? options : {};
        let optionCount = 0;
        if (this._options.dragAxis) {
          optionCount++;
        }
        if (this._options.dragPlaneNormal) {
          optionCount++;
        }
        if (optionCount > 1) {
          throw "Multiple drag modes specified in dragBehavior options. Only one expected";
        }
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "PointerDrag";
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * Attaches the drag behavior the passed in mesh
       * @param ownerNode The mesh that will be dragged around once attached
       * @param predicate Predicate to use for pick filtering
       */
      attach(ownerNode, predicate) {
        this._scene = ownerNode.getScene();
        ownerNode.isNearGrabbable = true;
        this.attachedNode = ownerNode;
        if (!_PointerDragBehavior._PlaneScene) {
          if (this._debugMode) {
            _PointerDragBehavior._PlaneScene = this._scene;
          } else {
            _PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });
            _PointerDragBehavior._PlaneScene.detachControl();
            this._scene.onDisposeObservable.addOnce(() => {
              _PointerDragBehavior._PlaneScene.dispose();
              _PointerDragBehavior._PlaneScene = null;
            });
          }
        }
        this._dragPlane = CreatePlane("pointerDragPlane", { size: this._debugMode ? 1 : 1e4, updatable: false, sideOrientation: Mesh.DOUBLESIDE }, _PointerDragBehavior._PlaneScene);
        this.lastDragPosition = new Vector3(0, 0, 0);
        const pickPredicate = predicate ? predicate : (m) => {
          return this.attachedNode == m || m.isDescendantOf(this.attachedNode);
        };
        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
          if (!this.enabled) {
            if (this._attachedToElement) {
              this.releaseDrag();
            }
            return;
          }
          if (this.dragging && this.currentDraggingPointerId == pointerInfo.event.pointerId && pointerInfo.event.button !== -1 && pointerInfo.event.button !== this._activeDragButton) {
            this.releaseDrag();
            return;
          }
          if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
            if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
              if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {
                this._activeDragButton = pointerInfo.event.button;
                this._activePointerInfo = pointerInfo;
                this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
              }
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
            if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerId == pointerInfo.event.pointerId && (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)) {
              this.releaseDrag();
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
            const pointerId = pointerInfo.event.pointerId;
            if (this.currentDraggingPointerId === _PointerDragBehavior._AnyMouseId && pointerId !== _PointerDragBehavior._AnyMouseId) {
              const evt = pointerInfo.event;
              const isMouseEvent = evt.pointerType === "mouse" || !this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
              if (isMouseEvent) {
                if (this._lastPointerRay[this.currentDraggingPointerId]) {
                  this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];
                  delete this._lastPointerRay[this.currentDraggingPointerId];
                }
                this.currentDraggingPointerId = pointerId;
              }
            }
            if (!this._lastPointerRay[pointerId]) {
              this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
            }
            if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
              this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
              this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
              if (this.currentDraggingPointerId == pointerId && this.dragging) {
                this._moveDrag(pointerInfo.pickInfo.ray);
              }
            }
          }
        });
        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
          if (this._moving && this.moveAttached) {
            let needMatrixUpdate = false;
            PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
            this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);
            this._tmpVector.scaleInPlace(this.dragDeltaRatio);
            this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);
            if (this.validateDrag(this._tmpVector)) {
              this.attachedNode.setAbsolutePosition(this._tmpVector);
              needMatrixUpdate = true;
            }
            PivotTools._RestorePivotPoint(this.attachedNode);
            if (needMatrixUpdate) {
              this.attachedNode.computeWorldMatrix();
            }
          }
        });
      }
      /**
       * Force release the drag action by code.
       */
      releaseDrag() {
        if (this.dragging) {
          this.dragging = false;
          this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
        }
        this.currentDraggingPointerId = -1;
        this._activeDragButton = -1;
        this._activePointerInfo = null;
        this._moving = false;
        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
          if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
            const arcRotateCamera = this._scene.activeCamera;
            arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
          } else {
            this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
          }
          this._attachedToElement = false;
        }
      }
      /**
       * Simulates the start of a pointer drag event on the behavior
       * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
       * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
       * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
       */
      startDrag(pointerId = _PointerDragBehavior._AnyMouseId, fromRay, startPickedPoint) {
        this._startDrag(pointerId, fromRay, startPickedPoint);
        let lastRay = this._lastPointerRay[pointerId];
        if (pointerId === _PointerDragBehavior._AnyMouseId) {
          lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
        }
        if (lastRay) {
          this._moveDrag(lastRay);
        }
      }
      _startDrag(pointerId, fromRay, startPickedPoint) {
        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
          return;
        }
        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
        if (fromRay) {
          this._startDragRay.direction.copyFrom(fromRay.direction);
          this._startDragRay.origin.copyFrom(fromRay.origin);
        } else {
          this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
          this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
          this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
        }
        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
        const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
        if (pickedPoint) {
          this.dragging = true;
          this.currentDraggingPointerId = pointerId;
          this.lastDragPosition.copyFrom(pickedPoint);
          this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
          this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());
          if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
            if (this._scene.activeCamera.inputs.attachedToElement) {
              this._scene.activeCamera.detachControl();
              this._attachedToElement = true;
            } else {
              this._attachedToElement = false;
            }
          }
        } else {
          this.releaseDrag();
        }
        PivotTools._RestorePivotPoint(this.attachedNode);
      }
      _moveDrag(ray) {
        this._moving = true;
        const pickedPoint = this._pickWithRayOnDragPlane(ray);
        if (pickedPoint) {
          PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
          if (this.updateDragPlane) {
            this._updateDragPlanePosition(ray, pickedPoint);
          }
          let dragLength = 0;
          if (this._options.dragAxis) {
            this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
            pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
            this._worldDragAxis.normalize();
            dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
            this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
          } else {
            dragLength = this._dragDelta.length();
            pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
          }
          this._targetPosition.addInPlace(this._dragDelta);
          this.onDragObservable.notifyObservers({
            dragDistance: dragLength,
            delta: this._dragDelta,
            dragPlanePoint: pickedPoint,
            dragPlaneNormal: this._dragPlane.forward,
            pointerId: this.currentDraggingPointerId,
            pointerInfo: this._activePointerInfo
          });
          this.lastDragPosition.copyFrom(pickedPoint);
          PivotTools._RestorePivotPoint(this.attachedNode);
        }
      }
      _pickWithRayOnDragPlane(ray) {
        if (!ray) {
          return null;
        }
        let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
        if (angle > Math.PI / 2) {
          angle = Math.PI - angle;
        }
        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
          if (this._useAlternatePickedPointAboveMaxDragAngle) {
            this._tmpVector.copyFrom(ray.direction);
            this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
            this._alternatePickedPoint.normalize();
            this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
            this._tmpVector.addInPlace(this._alternatePickedPoint);
            const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
            this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
            this._alternatePickedPoint.addInPlace(this._tmpVector);
            this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
            return this._alternatePickedPoint;
          } else {
            return null;
          }
        }
        const planeNormal = this._dragPlane.forward;
        const planePosition = this._dragPlane.position;
        const dotProduct = ray.direction.dot(planeNormal);
        if (Math.abs(dotProduct) < Epsilon) {
          return null;
        }
        planePosition.subtractToRef(ray.origin, TmpVectors.Vector3[0]);
        const t = TmpVectors.Vector3[0].dot(planeNormal) / dotProduct;
        if (t < 0) {
          return null;
        }
        ray.direction.scaleToRef(t, TmpVectors.Vector3[0]);
        const intersectionPoint = ray.origin.add(TmpVectors.Vector3[0]);
        return intersectionPoint;
      }
      // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera
      _updateDragPlanePosition(ray, dragPlanePosition) {
        this._pointA.copyFrom(dragPlanePosition);
        if (this._options.dragAxis) {
          this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
          ray.origin.subtractToRef(this._pointA, this._pointC);
          this._pointC.normalize();
          if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
            if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
              this._lookAt.copyFrom(Vector3.Right());
            } else {
              this._lookAt.copyFrom(Vector3.UpReadOnly);
            }
          } else {
            Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
            Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
            this._lookAt.normalize();
          }
          this._dragPlane.position.copyFrom(this._pointA);
          this._pointA.addToRef(this._lookAt, this._lookAt);
          this._dragPlane.lookAt(this._lookAt);
        } else if (this._options.dragPlaneNormal) {
          this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
          this._dragPlane.position.copyFrom(this._pointA);
          this._pointA.addToRef(this._localAxis, this._lookAt);
          this._dragPlane.lookAt(this._lookAt);
        } else {
          if (this._scene.activeCamera) {
            this._scene.activeCamera.getForwardRay().direction.normalizeToRef(this._localAxis);
          }
          this._dragPlane.position.copyFrom(this._pointA);
          this._dragPlane.lookAt(this._pointA.add(this._localAxis));
        }
        this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());
        this._dragPlane.computeWorldMatrix(true);
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        this._lastPointerRay = {};
        if (this.attachedNode) {
          this.attachedNode.isNearGrabbable = false;
        }
        if (this._pointerObserver) {
          this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        if (this._beforeRenderObserver) {
          this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
        if (this._dragPlane) {
          this._dragPlane.dispose();
        }
        this.releaseDrag();
      }
    };
    PointerDragBehavior._AnyMouseId = -2;
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js
var BaseSixDofDragBehavior;
var init_baseSixDofDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js"() {
    init_scene();
    init_pointerEvents();
    init_math_vector();
    init_observable();
    init_transformNode();
    init_camera();
    BaseSixDofDragBehavior = class _BaseSixDofDragBehavior {
      constructor() {
        this._attachedToElement = false;
        this._virtualMeshesInfo = {};
        this._tmpVector = new Vector3();
        this._tmpQuaternion = new Quaternion();
        this._dragType = {
          NONE: 0,
          DRAG: 1,
          DRAG_WITH_CONTROLLER: 2,
          NEAR_DRAG: 3
        };
        this._moving = false;
        this._dragging = this._dragType.NONE;
        this.draggableMeshes = null;
        this.zDragFactor = 3;
        this.currentDraggingPointerIds = [];
        this.detachCameraControls = true;
        this.onDragStartObservable = new Observable();
        this.onDragObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this.allowMultiPointer = true;
      }
      /**
       * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
       */
      get currentDraggingPointerId() {
        if (this.currentDraggingPointerIds[0] !== void 0) {
          return this.currentDraggingPointerIds[0];
        }
        return -1;
      }
      set currentDraggingPointerId(value) {
        this.currentDraggingPointerIds[0] = value;
      }
      /**
       * Get or set the currentDraggingPointerId
       * @deprecated Please use currentDraggingPointerId instead
       */
      get currentDraggingPointerID() {
        return this.currentDraggingPointerId;
      }
      set currentDraggingPointerID(currentDraggingPointerID) {
        this.currentDraggingPointerId = currentDraggingPointerID;
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "BaseSixDofDrag";
      }
      /**
       *  Returns true if the attached mesh is currently moving with this behavior
       */
      get isMoving() {
        return this._moving;
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera
       */
      get _pointerCamera() {
        if (this._scene.cameraToUseForPointers) {
          return this._scene.cameraToUseForPointers;
        } else {
          return this._scene.activeCamera;
        }
      }
      _createVirtualMeshInfo() {
        const dragMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
        dragMesh.rotationQuaternion = new Quaternion();
        const originMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
        originMesh.rotationQuaternion = new Quaternion();
        const pivotMesh = new TransformNode("", _BaseSixDofDragBehavior._virtualScene);
        pivotMesh.rotationQuaternion = new Quaternion();
        return {
          dragging: false,
          moving: false,
          dragMesh,
          originMesh,
          pivotMesh,
          startingPivotPosition: new Vector3(),
          startingPivotOrientation: new Quaternion(),
          startingPosition: new Vector3(),
          startingOrientation: new Quaternion(),
          lastOriginPosition: new Vector3(),
          lastDragPosition: new Vector3()
        };
      }
      _resetVirtualMeshesPosition() {
        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);
        }
      }
      _pointerUpdate2D(ray, pointerId, zDragFactor) {
        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
          ray.origin.copyFrom(this._pointerCamera.globalPosition);
          zDragFactor = 0;
        }
        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
        const originDragDifference = TmpVectors.Vector3[11];
        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);
        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);
        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);
        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);
        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);
        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);
        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);
        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);
        const lookAt = TmpVectors.Vector3[10];
        ray.origin.addToRef(ray.direction, lookAt);
        virtualMeshesInfo.originMesh.lookAt(lookAt);
        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
      }
      _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {
        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);
        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {
          virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);
        } else {
          virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);
        }
        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);
        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);
        if (zDragFactor !== 0) {
          const cameraForwardVec = TmpVectors.Vector3[10];
          const originDragDirection = TmpVectors.Vector3[11];
          cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);
          virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);
          virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);
          const controllerDragDistance = originDragDirection.length();
          originDragDirection.normalize();
          const cameraToDrag = TmpVectors.Vector3[12];
          const controllerToDrag = TmpVectors.Vector3[9];
          virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);
          virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);
          const controllerToDragDistance = controllerToDrag.length();
          cameraToDrag.normalize();
          controllerToDrag.normalize();
          const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);
          let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;
          const minDistanceFromControllerToDragMesh = 0.01;
          if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {
            zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);
          }
          controllerToDrag.scaleInPlace(zOffsetScaling);
          controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);
          virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);
          controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);
          virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);
        }
      }
      /**
       * Attaches the scale behavior the passed in mesh
       * @param ownerNode The mesh that will be scaled around once attached
       */
      attach(ownerNode) {
        this._ownerNode = ownerNode;
        this._scene = this._ownerNode.getScene();
        if (!_BaseSixDofDragBehavior._virtualScene) {
          _BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });
          _BaseSixDofDragBehavior._virtualScene.detachControl();
        }
        const pickPredicate = (m) => {
          return this._ownerNode === m || m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1);
        };
        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
          const pointerId = pointerInfo.event.pointerId;
          if (!this._virtualMeshesInfo[pointerId]) {
            this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();
          }
          const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
          const isXRPointer = pointerInfo.event.pointerType === "xr-near" || pointerInfo.event.pointerType === "xr";
          const isNearXRPointer = pointerInfo.event.pointerType === "xr-near";
          if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
            if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isNearXRPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
              if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {
                return;
              }
              if (this._pointerCamera && this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
                pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);
              }
              this._ownerNode.computeWorldMatrix(true);
              const virtualMeshesInfo2 = this._virtualMeshesInfo[pointerId];
              if (isXRPointer) {
                this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;
                virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);
                if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {
                  virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);
                } else {
                  virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);
                }
              } else {
                this._dragging = this._dragType.DRAG;
                virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
              }
              virtualMeshesInfo2.lastOriginPosition.copyFrom(virtualMeshesInfo2.originMesh.position);
              virtualMeshesInfo2.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);
              virtualMeshesInfo2.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);
              virtualMeshesInfo2.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
              virtualMeshesInfo2.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
              virtualMeshesInfo2.startingPosition.copyFrom(virtualMeshesInfo2.dragMesh.position);
              virtualMeshesInfo2.startingPivotPosition.copyFrom(virtualMeshesInfo2.pivotMesh.position);
              virtualMeshesInfo2.startingOrientation.copyFrom(virtualMeshesInfo2.dragMesh.rotationQuaternion);
              virtualMeshesInfo2.startingPivotOrientation.copyFrom(virtualMeshesInfo2.pivotMesh.rotationQuaternion);
              if (isNearXRPointer) {
                virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.dragMesh);
                virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.pivotMesh);
              } else {
                virtualMeshesInfo2.originMesh.lookAt(virtualMeshesInfo2.dragMesh.position);
              }
              virtualMeshesInfo2.dragging = true;
              if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {
                this.currentDraggingPointerIds.push(pointerId);
              }
              if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {
                if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {
                  this._pointerCamera.detachControl();
                  this._attachedToElement = true;
                } else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {
                  this._attachedToElement = false;
                }
              }
              this._targetDragStart(virtualMeshesInfo2.pivotMesh.position, virtualMeshesInfo2.pivotMesh.rotationQuaternion, pointerId);
              this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo2.pivotMesh.position });
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
            const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
            virtualMeshesInfo.dragging = false;
            if (registeredPointerIndex !== -1) {
              this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);
              if (this.currentDraggingPointerIds.length === 0) {
                this._moving = false;
                this._dragging = this._dragType.NONE;
                if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
                  this._reattachCameraControls();
                  this._attachedToElement = false;
                }
              }
              virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
              virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
              this._targetDragEnd(pointerId);
              this.onDragEndObservable.notifyObservers({});
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
            const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
            if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {
              let zDragFactor = this.zDragFactor;
              if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {
                zDragFactor = 0;
              }
              this._ownerNode.computeWorldMatrix(true);
              if (!isNearXRPointer) {
                this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);
              } else {
                this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);
              }
              this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);
              this._tmpQuaternion.x = -this._tmpQuaternion.x;
              this._tmpQuaternion.y = -this._tmpQuaternion.y;
              this._tmpQuaternion.z = -this._tmpQuaternion.z;
              virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);
              virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);
              this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });
              this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);
              virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);
              this._moving = true;
            }
          }
        });
      }
      _applyZOffset(node, localOriginDragDifference, zDragFactor) {
        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;
        if (node.position.z < 0) {
          node.position.z = 0;
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _targetDragStart(worldPosition, worldRotation, pointerId) {
      }
      _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {
      }
      _targetDragEnd(pointerId) {
      }
      _reattachCameraControls() {
        if (this._pointerCamera) {
          if (this._pointerCamera.getClassName() === "ArcRotateCamera") {
            const arcRotateCamera = this._pointerCamera;
            arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
          } else {
            this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);
          }
        }
      }
      /**
       * Detaches the behavior from the mesh
       */
      detach() {
        if (this._scene) {
          if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
            this._reattachCameraControls();
            this._attachedToElement = false;
          }
          this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        for (const pointerId in this._virtualMeshesInfo) {
          this._virtualMeshesInfo[pointerId].originMesh.dispose();
          this._virtualMeshesInfo[pointerId].dragMesh.dispose();
        }
        this.onDragEndObservable.clear();
        this.onDragObservable.clear();
        this.onDragStartObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior;
var init_sixDofDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js"() {
    init_math_vector();
    init_observable();
    init_baseSixDofDragBehavior();
    init_transformNode();
    SixDofDragBehavior = class extends BaseSixDofDragBehavior {
      constructor() {
        super(...arguments);
        this._sceneRenderObserver = null;
        this._targetPosition = new Vector3(0, 0, 0);
        this._targetOrientation = new Quaternion();
        this._targetScaling = new Vector3(1, 1, 1);
        this._startingPosition = new Vector3(0, 0, 0);
        this._startingOrientation = new Quaternion();
        this._startingScaling = new Vector3(1, 1, 1);
        this.onPositionChangedObservable = new Observable();
        this.dragDeltaRatio = 0.2;
        this.rotateDraggedObject = true;
        this.rotateAroundYOnly = false;
        this.rotateWithMotionController = true;
        this.disableMovement = false;
        this.faceCameraOnDragStart = false;
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "SixDofDrag";
      }
      /**
       * Attaches the six DoF drag behavior
       * In XR mode the mesh and its children will have their isNearGrabbable property set to true
       * @param ownerNode The mesh that will be dragged around once attached
       */
      attach(ownerNode) {
        super.attach(ownerNode);
        ownerNode.isNearGrabbable = true;
        ownerNode.getChildMeshes().forEach((m) => {
          m.isNearGrabbable = true;
        });
        this._virtualTransformNode = new TransformNode("virtual_sixDof", BaseSixDofDragBehavior._virtualScene);
        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();
        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
          if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {
            const deltaToAdd = TmpVectors.Vector3[0];
            deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);
            const deltaToAddTransformed = TmpVectors.Vector3[1];
            deltaToAddTransformed.copyFrom(deltaToAdd);
            if (ownerNode.parent) {
              const parentRotationMatrixInverse = TmpVectors.Matrix[0];
              ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);
              parentRotationMatrixInverse.invert();
              Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);
            }
            ownerNode.position.addInPlace(deltaToAddTransformed);
            this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });
            if (!ownerNode.parent || ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(1e-3)) {
              const rotationToApply = TmpVectors.Quaternion[0];
              rotationToApply.copyFrom(this._targetOrientation);
              if (ownerNode.parent) {
                const parentRotationInverse = TmpVectors.Quaternion[0];
                parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);
                parentRotationInverse.invertInPlace();
                parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);
              }
              Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);
            }
          }
        });
      }
      _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {
        const translationMatrix = TmpVectors.Matrix[0];
        const translationMatrixInv = TmpVectors.Matrix[1];
        const rotationMatrix = TmpVectors.Matrix[2];
        const scaleMatrix = TmpVectors.Matrix[3];
        const finalMatrix = TmpVectors.Matrix[4];
        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix);
        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv);
        Matrix.FromQuaternionToRef(rotation, rotationMatrix);
        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);
        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix);
        finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
        return finalMatrix.getTranslation();
      }
      _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {
        const pointerDelta = TmpVectors.Vector3[0];
        pointerDelta.setAll(0);
        if (this._dragging === this._dragType.DRAG) {
          if (this.rotateDraggedObject) {
            if (this.rotateAroundYOnly) {
              Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
            } else {
              TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);
            }
            TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);
          }
        } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {
          worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);
        }
        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);
      }
      _twoPointersPositionUpdated() {
        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;
        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;
        const startingCenter = TmpVectors.Vector3[0];
        startingPosition0.addToRef(startingPosition1, startingCenter);
        startingCenter.scaleInPlace(0.5);
        const startingVector = TmpVectors.Vector3[1];
        startingPosition1.subtractToRef(startingPosition0, startingVector);
        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;
        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;
        const currentCenter = TmpVectors.Vector3[2];
        currentPosition0.addToRef(currentPosition1, currentCenter);
        currentCenter.scaleInPlace(0.5);
        const currentVector = TmpVectors.Vector3[3];
        currentPosition1.subtractToRef(currentPosition0, currentVector);
        const scaling = currentVector.length() / startingVector.length();
        const translation = currentCenter.subtract(startingCenter);
        const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);
        const oldParent = this._ownerNode.parent;
        this._ownerNode.setParent(null);
        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);
        this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);
        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);
        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);
        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });
        this._ownerNode.setParent(oldParent);
      }
      _targetDragStart() {
        const pointerCount = this.currentDraggingPointerIds.length;
        if (!this._ownerNode.rotationQuaternion) {
          this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);
        }
        const worldPivot = this._ownerNode.getAbsolutePivotPoint();
        if (pointerCount === 1) {
          this._targetPosition.copyFrom(this._ownerNode.absolutePosition);
          this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);
          this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);
          if (this.faceCameraOnDragStart && this._scene.activeCamera) {
            const toCamera = TmpVectors.Vector3[0];
            this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);
            toCamera.normalize();
            const quat = TmpVectors.Quaternion[0];
            if (this._scene.useRightHandedSystem) {
              Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);
            } else {
              Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);
            }
            quat.normalize();
            Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
            this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);
          }
          this._startingPosition.copyFrom(this._targetPosition);
          this._startingOrientation.copyFrom(this._targetOrientation);
          this._startingScaling.copyFrom(this._targetScaling);
        } else if (pointerCount === 2) {
          this._virtualTransformNode.setPivotPoint(
            new Vector3(0, 0, 0),
            0
            /* Space.LOCAL */
          );
          this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);
          this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);
          this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
          this._virtualTransformNode.setPivotPoint(
            worldPivot,
            1
            /* Space.WORLD */
          );
          this._resetVirtualMeshesPosition();
        }
      }
      _targetDrag(worldDeltaPosition, worldDeltaRotation) {
        if (this.currentDraggingPointerIds.length === 1) {
          this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);
        } else if (this.currentDraggingPointerIds.length === 2) {
          this._twoPointersPositionUpdated();
        }
      }
      _targetDragEnd() {
        if (this.currentDraggingPointerIds.length === 1) {
          this._resetVirtualMeshesPosition();
          const previousFaceCameraFlag = this.faceCameraOnDragStart;
          this.faceCameraOnDragStart = false;
          this._targetDragStart();
          this.faceCameraOnDragStart = previousFaceCameraFlag;
        }
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        super.detach();
        if (this._ownerNode) {
          this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
        }
        if (this._virtualTransformNode) {
          this._virtualTransformNode.dispose();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js
var SurfaceMagnetismBehavior;
var init_surfaceMagnetismBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js"() {
    init_pointerEvents();
    init_math_vector();
    SurfaceMagnetismBehavior = class {
      constructor() {
        this._attachPointLocalOffset = new Vector3();
        this._workingPosition = new Vector3();
        this._workingQuaternion = new Quaternion();
        this._lastTick = -1;
        this._hit = false;
        this.hitNormalOffset = 0.05;
        this.meshes = [];
        this.interpolatePose = true;
        this.lerpTime = 250;
        this.keepOrientationVertical = true;
        this.enabled = true;
        this.maxStickingDistance = 0.8;
      }
      /**
       * Name of the behavior
       */
      get name() {
        return "SurfaceMagnetism";
      }
      /**
       * Function called when the behavior needs to be initialized (after attaching it to a target)
       */
      init() {
      }
      /**
       * Attaches the behavior to a transform node
       * @param target defines the target where the behavior is attached to
       * @param scene the scene
       */
      attach(target, scene) {
        this._attachedMesh = target;
        this._scene = scene || target.getScene();
        if (!this._attachedMesh.rotationQuaternion) {
          this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);
        }
        this.updateAttachPoint();
        this._workingPosition.copyFrom(this._attachedMesh.position);
        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);
        this._addObservables();
      }
      /**
       * Detaches the behavior
       */
      detach() {
        this._attachedMesh = null;
        this._removeObservables();
      }
      _getTargetPose(pickingInfo) {
        if (!this._attachedMesh) {
          return null;
        }
        if (pickingInfo && pickingInfo.hit) {
          const pickedNormal = pickingInfo.getNormal(true, true);
          const pickedPoint = pickingInfo.pickedPoint;
          if (!pickedNormal || !pickedPoint) {
            return null;
          }
          pickedNormal.normalize();
          const worldTarget = TmpVectors.Vector3[0];
          worldTarget.copyFrom(pickedNormal);
          worldTarget.scaleInPlace(this.hitNormalOffset);
          worldTarget.addInPlace(pickedPoint);
          if (this._attachedMesh.parent) {
            TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();
            Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);
          }
          return {
            position: worldTarget,
            quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)
          };
        }
        return null;
      }
      /**
       * Updates the attach point with the current geometry extents of the attached mesh
       */
      updateAttachPoint() {
        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);
      }
      /**
       * Finds the intersection point of the given ray onto the meshes and updates the target.
       * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.
       * If no mesh of `meshes` are hit, this does nothing.
       * @param pickInfo The input pickingInfo that will be used to intersect the meshes
       * @returns a boolean indicating if we found a hit to stick to
       */
      findAndUpdateTarget(pickInfo) {
        this._hit = false;
        if (!pickInfo.ray) {
          return false;
        }
        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];
        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {
          const pose = this._getTargetPose(subPicking);
          if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {
            this._workingPosition.copyFrom(pose.position);
            this._workingQuaternion.copyFrom(pose.quaternion);
            this._hit = true;
          }
        }
        return this._hit;
      }
      _getAttachPointOffsetToRef(ref) {
        if (!this._attachedMesh) {
          ref.setAll(0);
          return;
        }
        const storedQuat = TmpVectors.Quaternion[0];
        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);
        this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
        this._attachedMesh.computeWorldMatrix();
        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();
        const center = TmpVectors.Vector3[0];
        boundingMinMax.max.addToRef(boundingMinMax.min, center);
        center.scaleInPlace(0.5);
        center.z = boundingMinMax.max.z;
        const invWorld = TmpVectors.Matrix[0];
        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);
        Vector3.TransformCoordinatesToRef(center, invWorld, ref);
        this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);
      }
      _updateTransformToGoal(elapsed) {
        if (!this._attachedMesh || !this._hit) {
          return;
        }
        const oldParent = this._attachedMesh.parent;
        this._attachedMesh.setParent(null);
        const worldOffset = TmpVectors.Vector3[0];
        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);
        if (!this.interpolatePose) {
          this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);
          this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);
          return;
        }
        const interpolatedPosition = new Vector3();
        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);
        this._attachedMesh.position.copyFrom(interpolatedPosition);
        const currentRotation = new Quaternion();
        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);
        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);
        this._attachedMesh.setParent(oldParent);
      }
      _addObservables() {
        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
          if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {
            this.findAndUpdateTarget(pointerInfo.pickInfo);
          }
        });
        this._lastTick = Date.now();
        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
          const tick = Date.now();
          this._updateTransformToGoal(tick - this._lastTick);
          this._lastTick = tick;
        });
      }
      _removeObservables() {
        this._scene.onPointerObservable.remove(this._pointerObserver);
        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
        this._pointerObserver = null;
        this._onBeforeRender = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js
var FollowBehavior;
var init_followBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_math_constants();
    FollowBehavior = class {
      constructor() {
        this._tmpQuaternion = new Quaternion();
        this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
        this._tmpMatrix = new Matrix();
        this._tmpInvertView = new Matrix();
        this._tmpForward = new Vector3();
        this._tmpNodeForward = new Vector3();
        this._tmpPosition = new Vector3();
        this._workingPosition = new Vector3();
        this._workingQuaternion = new Quaternion();
        this._lastTick = -1;
        this._recenterNextUpdate = true;
        this.interpolatePose = true;
        this.lerpTime = 500;
        this.ignoreCameraPitchAndRoll = false;
        this.pitchOffset = 15;
        this.maxViewVerticalDegrees = 30;
        this.maxViewHorizontalDegrees = 30;
        this.orientToCameraDeadzoneDegrees = 60;
        this.ignoreDistanceClamp = false;
        this.ignoreAngleClamp = false;
        this.verticalMaxDistance = 0;
        this.defaultDistance = 0.8;
        this.maximumDistance = 2;
        this.minimumDistance = 0.3;
        this.useFixedVerticalOffset = false;
        this.fixedVerticalOffset = 0;
        this._enabled = true;
      }
      /**
       * The camera that should be followed by this behavior
       */
      get followedCamera() {
        return this._followedCamera || this._scene.activeCamera;
      }
      set followedCamera(camera) {
        this._followedCamera = camera;
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "Follow";
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * Attaches the follow behavior
       * @param ownerNode The mesh that will be following once attached
       * @param followedCamera The camera that should be followed by the node
       */
      attach(ownerNode, followedCamera) {
        this._scene = ownerNode.getScene();
        this.attachedNode = ownerNode;
        if (followedCamera) {
          this.followedCamera = followedCamera;
        }
        this._addObservables();
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        this.attachedNode = null;
        this._removeObservables();
      }
      /**
       * Recenters the attached node in front of the camera on the next update
       */
      recenter() {
        this._recenterNextUpdate = true;
      }
      _angleBetweenVectorAndPlane(vector, normal) {
        this._tmpVectors[0].copyFrom(vector);
        vector = this._tmpVectors[0];
        this._tmpVectors[1].copyFrom(normal);
        normal = this._tmpVectors[1];
        vector.normalize();
        normal.normalize();
        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));
      }
      _length2D(vector) {
        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);
      }
      _distanceClamp(currentToTarget, moveToDefault = false) {
        let minDistance = this.minimumDistance;
        let maxDistance = this.maximumDistance;
        const defaultDistance = this.defaultDistance;
        const direction = this._tmpVectors[0];
        direction.copyFrom(currentToTarget);
        let currentDistance = direction.length();
        direction.normalizeFromLength(currentDistance);
        if (this.ignoreCameraPitchAndRoll) {
          minDistance = this._length2D(direction) * minDistance;
          maxDistance = this._length2D(direction) * maxDistance;
          const currentDistance2D = this._length2D(currentToTarget);
          direction.scaleInPlace(currentDistance / currentDistance2D);
          currentDistance = currentDistance2D;
        }
        let clampedDistance = currentDistance;
        if (moveToDefault) {
          clampedDistance = defaultDistance;
        } else {
          clampedDistance = Clamp(currentDistance, minDistance, maxDistance);
        }
        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);
        return currentDistance !== clampedDistance;
      }
      _applyVerticalClamp(currentToTarget) {
        if (this.verticalMaxDistance !== 0) {
          currentToTarget.y = Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);
        }
      }
      _toOrientationQuatToRef(vector, quaternion) {
        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);
      }
      _applyPitchOffset(invertView) {
        const forward = this._tmpVectors[0];
        const right = this._tmpVectors[1];
        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
        right.copyFromFloats(1, 0, 0);
        Vector3.TransformNormalToRef(forward, invertView, forward);
        forward.y = 0;
        forward.normalize();
        Vector3.TransformNormalToRef(right, invertView, right);
        Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);
        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);
        this._toOrientationQuatToRef(forward, this._tmpQuaternion);
        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);
        invertView.copyFrom(this._tmpMatrix);
      }
      _angularClamp(invertView, currentToTarget) {
        const forward = this._tmpVectors[5];
        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
        const right = this._tmpVectors[6];
        right.copyFromFloats(1, 0, 0);
        Vector3.TransformNormalToRef(forward, invertView, forward);
        Vector3.TransformNormalToRef(right, invertView, right);
        const up = Vector3.UpReadOnly;
        const dist = currentToTarget.length();
        if (dist < Epsilon) {
          return false;
        }
        let angularClamped = false;
        const rotationQuat = this._tmpQuaternion;
        if (this.ignoreCameraPitchAndRoll) {
          const angle2 = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
          Quaternion.RotationAxisToRef(right, angle2, rotationQuat);
          currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
        } else {
          const angle2 = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);
          const minMaxAngle2 = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;
          if (angle2 < -minMaxAngle2) {
            Quaternion.RotationAxisToRef(right, -angle2 - minMaxAngle2, rotationQuat);
            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
            angularClamped = true;
          } else if (angle2 > minMaxAngle2) {
            Quaternion.RotationAxisToRef(right, -angle2 + minMaxAngle2, rotationQuat);
            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
            angularClamped = true;
          }
        }
        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);
        const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;
        if (angle < -minMaxAngle) {
          Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);
          currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
          angularClamped = true;
        } else if (angle > minMaxAngle) {
          Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);
          currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);
          angularClamped = true;
        }
        return angularClamped;
      }
      _orientationClamp(currentToTarget, rotationQuaternion) {
        var _a;
        const toFollowed = this._tmpVectors[0];
        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();
        const up = this._tmpVectors[1];
        const right = this._tmpVectors[2];
        up.copyFromFloats(0, 1, 0);
        Vector3.CrossToRef(toFollowed, up, right);
        const length = right.length();
        if (length < Epsilon) {
          return;
        }
        right.normalizeFromLength(length);
        Vector3.CrossToRef(right, toFollowed, up);
        if ((_a = this.attachedNode) == null ? void 0 : _a.getScene().useRightHandedSystem) {
          Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);
        } else {
          Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);
        }
      }
      _passedOrientationDeadzone(currentToTarget, forward) {
        const leashToFollow = this._tmpVectors[5];
        leashToFollow.copyFrom(currentToTarget);
        leashToFollow.normalize();
        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));
        return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;
      }
      _updateLeashing(camera) {
        if (this.attachedNode && this._enabled) {
          const oldParent = this.attachedNode.parent;
          this.attachedNode.setParent(null);
          const worldMatrix = this.attachedNode.getWorldMatrix();
          const currentToTarget = this._workingPosition;
          const rotationQuaternion = this._workingQuaternion;
          const pivot = this.attachedNode.getPivotPoint();
          const invertView = this._tmpInvertView;
          invertView.copyFrom(camera.getViewMatrix());
          invertView.invert();
          Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);
          const position = this._tmpPosition;
          position.copyFromFloats(0, 0, 0);
          Vector3.TransformCoordinatesToRef(position, worldMatrix, position);
          position.scaleInPlace(-1).subtractInPlace(pivot);
          currentToTarget.subtractInPlace(camera.globalPosition);
          if (this.ignoreCameraPitchAndRoll) {
            this._applyPitchOffset(invertView);
          }
          let angularClamped = false;
          const forward = this._tmpForward;
          forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
          Vector3.TransformNormalToRef(forward, invertView, forward);
          const nodeForward = this._tmpNodeForward;
          nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
          Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);
          if (this._recenterNextUpdate) {
            currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);
          } else {
            if (this.ignoreAngleClamp) {
              const currentDistance = currentToTarget.length();
              currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);
            } else {
              angularClamped = this._angularClamp(invertView, currentToTarget);
            }
          }
          let distanceClamped = false;
          if (!this.ignoreDistanceClamp) {
            distanceClamped = this._distanceClamp(currentToTarget, angularClamped);
            this._applyVerticalClamp(currentToTarget);
          }
          if (this.useFixedVerticalOffset) {
            currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;
          }
          if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {
            this._orientationClamp(currentToTarget, rotationQuaternion);
          }
          this._workingPosition.subtractInPlace(pivot);
          this._recenterNextUpdate = false;
          this.attachedNode.setParent(oldParent);
        }
      }
      _updateTransformToGoal(elapsed) {
        if (!this.attachedNode || !this.followedCamera || !this._enabled) {
          return;
        }
        if (!this.attachedNode.rotationQuaternion) {
          this.attachedNode.rotationQuaternion = Quaternion.Identity();
        }
        const oldParent = this.attachedNode.parent;
        this.attachedNode.setParent(null);
        if (!this.interpolatePose) {
          this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);
          this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);
          return;
        }
        const currentDirection = new Vector3();
        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);
        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);
        currentDirection.addInPlace(this.followedCamera.globalPosition);
        this.attachedNode.position.copyFrom(currentDirection);
        const currentRotation = new Quaternion();
        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);
        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);
        this.attachedNode.setParent(oldParent);
      }
      _addObservables() {
        this._lastTick = Date.now();
        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {
          if (!this.followedCamera) {
            return;
          }
          const tick = Date.now();
          this._updateLeashing(this.followedCamera);
          this._updateTransformToGoal(tick - this._lastTick);
          this._lastTick = tick;
        });
      }
      _removeObservables() {
        if (this._onBeforeRender) {
          this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/XR/webXRFeaturesManager.js
var WebXRFeatureName, WebXRFeaturesManager;
var init_webXRFeaturesManager = __esm({
  "node_modules/@babylonjs/core/XR/webXRFeaturesManager.js"() {
    init_tools();
    WebXRFeatureName = class {
    };
    WebXRFeatureName.ANCHOR_SYSTEM = "xr-anchor-system";
    WebXRFeatureName.BACKGROUND_REMOVER = "xr-background-remover";
    WebXRFeatureName.HIT_TEST = "xr-hit-test";
    WebXRFeatureName.MESH_DETECTION = "xr-mesh-detection";
    WebXRFeatureName.PHYSICS_CONTROLLERS = "xr-physics-controller";
    WebXRFeatureName.PLANE_DETECTION = "xr-plane-detection";
    WebXRFeatureName.POINTER_SELECTION = "xr-controller-pointer-selection";
    WebXRFeatureName.TELEPORTATION = "xr-controller-teleportation";
    WebXRFeatureName.FEATURE_POINTS = "xr-feature-points";
    WebXRFeatureName.HAND_TRACKING = "xr-hand-tracking";
    WebXRFeatureName.IMAGE_TRACKING = "xr-image-tracking";
    WebXRFeatureName.NEAR_INTERACTION = "xr-near-interaction";
    WebXRFeatureName.DOM_OVERLAY = "xr-dom-overlay";
    WebXRFeatureName.MOVEMENT = "xr-controller-movement";
    WebXRFeatureName.LIGHT_ESTIMATION = "xr-light-estimation";
    WebXRFeatureName.EYE_TRACKING = "xr-eye-tracking";
    WebXRFeatureName.WALKING_LOCOMOTION = "xr-walking-locomotion";
    WebXRFeatureName.LAYERS = "xr-layers";
    WebXRFeatureName.DEPTH_SENSING = "xr-depth-sensing";
    WebXRFeatureName.SPACE_WARP = "xr-space-warp";
    WebXRFeatureName.RAW_CAMERA_ACCESS = "xr-raw-camera-access";
    WebXRFeaturesManager = class _WebXRFeaturesManager {
      /**
       * constructs a new features manages.
       *
       * @param _xrSessionManager an instance of WebXRSessionManager
       */
      constructor(_xrSessionManager) {
        this._xrSessionManager = _xrSessionManager;
        this._features = {};
        this._xrSessionManager.onXRSessionInit.add(() => {
          this.getEnabledFeatures().forEach((featureName) => {
            const feature = this._features[featureName];
            if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {
              this.attachFeature(featureName);
            }
          });
        });
        this._xrSessionManager.onXRSessionEnded.add(() => {
          this.getEnabledFeatures().forEach((featureName) => {
            const feature = this._features[featureName];
            if (feature.enabled && feature.featureImplementation.attached) {
              this.detachFeature(featureName);
            }
          });
        });
      }
      /**
       * Used to register a module. After calling this function a developer can use this feature in the scene.
       * Mainly used internally.
       *
       * @param featureName the name of the feature to register
       * @param constructorFunction the function used to construct the module
       * @param version the (babylon) version of the module
       * @param stable is that a stable version of this module
       */
      static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {
        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };
        if (version > this._AvailableFeatures[featureName].latest) {
          this._AvailableFeatures[featureName].latest = version;
        }
        if (stable) {
          this._AvailableFeatures[featureName].stable = version;
        }
        this._AvailableFeatures[featureName][version] = constructorFunction;
      }
      /**
       * Returns a constructor of a specific feature.
       *
       * @param featureName the name of the feature to construct
       * @param version the version of the feature to load
       * @param xrSessionManager the xrSessionManager. Used to construct the module
       * @param options optional options provided to the module.
       * @returns a function that, when called, will return a new instance of this feature
       */
      static ConstructFeature(featureName, version = 1, xrSessionManager, options) {
        const constructorFunction = this._AvailableFeatures[featureName][version];
        if (!constructorFunction) {
          throw new Error("feature not found");
        }
        return constructorFunction(xrSessionManager, options);
      }
      /**
       * Can be used to return the list of features currently registered
       *
       * @returns an Array of available features
       */
      static GetAvailableFeatures() {
        return Object.keys(this._AvailableFeatures);
      }
      /**
       * Gets the versions available for a specific feature
       * @param featureName the name of the feature
       * @returns an array with the available versions
       */
      static GetAvailableVersions(featureName) {
        return Object.keys(this._AvailableFeatures[featureName]);
      }
      /**
       * Return the latest unstable version of this feature
       * @param featureName the name of the feature to search
       * @returns the version number. if not found will return -1
       */
      static GetLatestVersionOfFeature(featureName) {
        return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;
      }
      /**
       * Return the latest stable version of this feature
       * @param featureName the name of the feature to search
       * @returns the version number. if not found will return -1
       */
      static GetStableVersionOfFeature(featureName) {
        return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;
      }
      /**
       * Attach a feature to the current session. Mainly used when session started to start the feature effect.
       * Can be used during a session to start a feature
       * @param featureName the name of feature to attach
       */
      attachFeature(featureName) {
        const feature = this._features[featureName];
        if (feature && feature.enabled && !feature.featureImplementation.attached) {
          const attached = feature.featureImplementation.attach();
          if (!attached) {
            Tools.Warn(`Feature ${featureName} failed to attach`);
          }
        }
      }
      /**
       * Can be used inside a session or when the session ends to detach a specific feature
       * @param featureName the name of the feature to detach
       */
      detachFeature(featureName) {
        const feature = this._features[featureName];
        if (feature && feature.featureImplementation.attached) {
          const detached = feature.featureImplementation.detach();
          if (!detached) {
            Tools.Warn(`Feature ${featureName} failed to detach`);
          }
        }
      }
      /**
       * Used to disable an already-enabled feature
       * The feature will be disposed and will be recreated once enabled.
       * @param featureName the feature to disable
       * @returns true if disable was successful
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      disableFeature(featureName) {
        const name = typeof featureName === "string" ? featureName : featureName.Name;
        const feature = this._features[name];
        if (feature && feature.enabled) {
          feature.enabled = false;
          this.detachFeature(name);
          feature.featureImplementation.dispose();
          delete this._features[name];
          return true;
        }
        return false;
      }
      /**
       * dispose this features manager
       */
      dispose() {
        this.getEnabledFeatures().forEach((feature) => {
          this.disableFeature(feature);
        });
      }
      /**
       * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.
       * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.
       *
       * @param featureName the name of the feature to load or the class of the feature
       * @param version optional version to load. if not provided the latest version will be enabled
       * @param moduleOptions options provided to the module. Ses the module documentation / constructor
       * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible
       * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.
       * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.
       */
      enableFeature(featureName, version = "latest", moduleOptions = {}, attachIfPossible = true, required = true) {
        const name = typeof featureName === "string" ? featureName : featureName.Name;
        let versionToLoad = 0;
        if (typeof version === "string") {
          if (!version) {
            throw new Error(`Error in provided version - ${name} (${version})`);
          }
          if (version === "stable") {
            versionToLoad = _WebXRFeaturesManager.GetStableVersionOfFeature(name);
          } else if (version === "latest") {
            versionToLoad = _WebXRFeaturesManager.GetLatestVersionOfFeature(name);
          } else {
            versionToLoad = +version;
          }
          if (versionToLoad === -1 || isNaN(versionToLoad)) {
            throw new Error(`feature not found - ${name} (${version})`);
          }
        } else {
          versionToLoad = version;
        }
        const conflictingFeature = _WebXRFeaturesManager._ConflictingFeatures[name];
        if (conflictingFeature !== void 0 && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {
          throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);
        }
        const feature = this._features[name];
        const constructFunction = _WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);
        if (!constructFunction) {
          throw new Error(`feature not found - ${name}`);
        }
        if (feature) {
          this.disableFeature(name);
        }
        const constructed = constructFunction();
        if (constructed.dependsOn) {
          const dependentsFound = constructed.dependsOn.every((featureName2) => !!this._features[featureName2]);
          if (!dependentsFound) {
            throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(", ")}`);
          }
        }
        if (constructed.isCompatible()) {
          this._features[name] = {
            featureImplementation: constructed,
            enabled: true,
            version: versionToLoad,
            required
          };
          if (attachIfPossible) {
            if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {
              this.attachFeature(name);
            }
          } else {
            this._features[name].featureImplementation.disableAutoAttach = true;
          }
          return this._features[name].featureImplementation;
        } else {
          if (required) {
            throw new Error("required feature not compatible");
          } else {
            Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);
            return constructed;
          }
        }
      }
      /**
       * get the implementation of an enabled feature.
       * @param featureName the name of the feature to load
       * @returns the feature class, if found
       */
      getEnabledFeature(featureName) {
        return this._features[featureName] && this._features[featureName].featureImplementation;
      }
      /**
       * Get the list of enabled features
       * @returns an array of enabled features
       */
      getEnabledFeatures() {
        return Object.keys(this._features);
      }
      /**
       * This function will extend the session creation configuration object with enabled features.
       * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,
       * according to the defined "required" variable, provided during enableFeature call
       * @param xrSessionInit the xr Session init object to extend
       *
       * @returns an extended XRSessionInit object
       */
      async _extendXRSessionInitObject(xrSessionInit) {
        const enabledFeatures = this.getEnabledFeatures();
        for (const featureName of enabledFeatures) {
          const feature = this._features[featureName];
          const nativeName = feature.featureImplementation.xrNativeFeatureName;
          if (nativeName) {
            if (feature.required) {
              xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];
              if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {
                xrSessionInit.requiredFeatures.push(nativeName);
              }
            } else {
              xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];
              if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {
                xrSessionInit.optionalFeatures.push(nativeName);
              }
            }
          }
          if (feature.featureImplementation.getXRSessionInitExtension) {
            const extended = await feature.featureImplementation.getXRSessionInitExtension();
            xrSessionInit = {
              ...xrSessionInit,
              ...extended
            };
          }
        }
        return xrSessionInit;
      }
    };
    WebXRFeaturesManager._AvailableFeatures = {};
    WebXRFeaturesManager._ConflictingFeatures = {
      [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,
      [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js
var HandConstraintZone, HandConstraintOrientation, HandConstraintVisibility, HandConstraintBehavior;
var init_handConstraintBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js"() {
    init_webXRFeaturesManager();
    init_math_vector();
    init_tools();
    (function(HandConstraintZone2) {
      HandConstraintZone2[HandConstraintZone2["ABOVE_FINGER_TIPS"] = 0] = "ABOVE_FINGER_TIPS";
      HandConstraintZone2[HandConstraintZone2["RADIAL_SIDE"] = 1] = "RADIAL_SIDE";
      HandConstraintZone2[HandConstraintZone2["ULNAR_SIDE"] = 2] = "ULNAR_SIDE";
      HandConstraintZone2[HandConstraintZone2["BELOW_WRIST"] = 3] = "BELOW_WRIST";
    })(HandConstraintZone || (HandConstraintZone = {}));
    (function(HandConstraintOrientation2) {
      HandConstraintOrientation2[HandConstraintOrientation2["LOOK_AT_CAMERA"] = 0] = "LOOK_AT_CAMERA";
      HandConstraintOrientation2[HandConstraintOrientation2["HAND_ROTATION"] = 1] = "HAND_ROTATION";
    })(HandConstraintOrientation || (HandConstraintOrientation = {}));
    (function(HandConstraintVisibility2) {
      HandConstraintVisibility2[HandConstraintVisibility2["ALWAYS_VISIBLE"] = 0] = "ALWAYS_VISIBLE";
      HandConstraintVisibility2[HandConstraintVisibility2["PALM_UP"] = 1] = "PALM_UP";
      HandConstraintVisibility2[HandConstraintVisibility2["GAZE_FOCUS"] = 2] = "GAZE_FOCUS";
      HandConstraintVisibility2[HandConstraintVisibility2["PALM_AND_GAZE"] = 3] = "PALM_AND_GAZE";
    })(HandConstraintVisibility || (HandConstraintVisibility = {}));
    HandConstraintBehavior = class {
      /**
       * Builds a hand constraint behavior
       */
      constructor() {
        this._sceneRenderObserver = null;
        this._zoneAxis = {};
        this.handConstraintVisibility = 3;
        this.palmUpStrictness = 0.95;
        this.gazeProximityRadius = 0.15;
        this.targetOffset = 0.1;
        this.targetZone = 2;
        this.zoneOrientationMode = 1;
        this.nodeOrientationMode = 1;
        this.handedness = "none";
        this.lerpTime = 100;
        this._zoneAxis[
          0
          /* HandConstraintZone.ABOVE_FINGER_TIPS */
        ] = new Vector3(0, 1, 0);
        this._zoneAxis[
          1
          /* HandConstraintZone.RADIAL_SIDE */
        ] = new Vector3(-1, 0, 0);
        this._zoneAxis[
          2
          /* HandConstraintZone.ULNAR_SIDE */
        ] = new Vector3(1, 0, 0);
        this._zoneAxis[
          3
          /* HandConstraintZone.BELOW_WRIST */
        ] = new Vector3(0, -1, 0);
      }
      /** gets or sets behavior's name */
      get name() {
        return "HandConstraint";
      }
      /** Enable the behavior */
      enable() {
        this._node.setEnabled(true);
      }
      /** Disable the behavior */
      disable() {
        this._node.setEnabled(false);
      }
      _getHandPose() {
        if (!this._handTracking) {
          return null;
        }
        let hand;
        if (this.handedness === "none") {
          hand = this._handTracking.getHandByHandedness("left") || this._handTracking.getHandByHandedness("right");
        } else {
          hand = this._handTracking.getHandByHandedness(this.handedness);
        }
        if (hand) {
          const pinkyMetacarpal = hand.getJointMesh(
            "pinky-finger-metacarpal"
            /* WebXRHandJoint.PINKY_FINGER_METACARPAL */
          );
          const middleMetacarpal = hand.getJointMesh(
            "middle-finger-metacarpal"
            /* WebXRHandJoint.MIDDLE_FINGER_METACARPAL */
          );
          const wrist = hand.getJointMesh(
            "wrist"
            /* WebXRHandJoint.WRIST */
          );
          if (wrist && middleMetacarpal && pinkyMetacarpal) {
            const handPose = { position: middleMetacarpal.absolutePosition, quaternion: new Quaternion(), id: hand.xrController.uniqueId };
            const up = TmpVectors.Vector3[0];
            const forward = TmpVectors.Vector3[1];
            const left = TmpVectors.Vector3[2];
            up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();
            forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();
            Vector3.CrossToRef(up, forward, forward);
            Vector3.CrossToRef(forward, up, left);
            Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);
            return handPose;
          }
        }
        return null;
      }
      /**
       * Initializes the hand constraint behavior
       */
      init() {
      }
      /**
       * Attaches the hand constraint to a `TransformNode`
       * @param node defines the node to attach the behavior to
       */
      attach(node) {
        this._node = node;
        this._scene = node.getScene();
        if (!this._node.rotationQuaternion) {
          this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);
        }
        let lastTick = Date.now();
        this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
          const pose = this._getHandPose();
          this._node.reservedDataStore = this._node.reservedDataStore || {};
          this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};
          this._node.reservedDataStore.nearInteraction.excludedControllerId = null;
          if (pose) {
            const zoneOffset = TmpVectors.Vector3[0];
            const camera = this._scene.activeCamera;
            zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);
            const cameraLookAtQuaternion = TmpVectors.Quaternion[0];
            if (camera && (this.zoneOrientationMode === 0 || this.nodeOrientationMode === 0)) {
              const toCamera = TmpVectors.Vector3[1];
              toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();
              if (this._scene.useRightHandedSystem) {
                Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
              } else {
                Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);
              }
            }
            if (this.zoneOrientationMode === 1) {
              pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);
            } else {
              cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);
            }
            Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);
            zoneOffset.scaleInPlace(this.targetOffset);
            const targetPosition = TmpVectors.Vector3[2];
            const targetRotation = TmpVectors.Quaternion[1];
            targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);
            if (this.nodeOrientationMode === 1) {
              targetRotation.copyFrom(pose.quaternion);
            } else {
              targetRotation.copyFrom(cameraLookAtQuaternion);
            }
            const elapsed = Date.now() - lastTick;
            Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);
            Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);
            this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;
          }
          this._setVisibility(pose);
          lastTick = Date.now();
        });
      }
      _setVisibility(pose) {
        let palmVisible = true;
        let gazeVisible = true;
        const camera = this._scene.activeCamera;
        if (camera) {
          const cameraForward = camera.getForwardRay();
          if (this.handConstraintVisibility === 2 || this.handConstraintVisibility === 3) {
            gazeVisible = false;
            let gaze;
            if (this._eyeTracking) {
              gaze = this._eyeTracking.getEyeGaze();
            }
            gaze = gaze || cameraForward;
            const gazeToBehavior = TmpVectors.Vector3[0];
            if (pose) {
              pose.position.subtractToRef(gaze.origin, gazeToBehavior);
            } else {
              this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);
            }
            const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);
            const projectedSquared = projectedDistance * projectedDistance;
            if (projectedDistance > 0) {
              const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;
              if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {
                gazeVisible = true;
              }
            }
          }
          if (this.handConstraintVisibility === 1 || this.handConstraintVisibility === 3) {
            palmVisible = false;
            if (pose) {
              const palmDirection = TmpVectors.Vector3[0];
              Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);
              if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {
                palmVisible = true;
              }
            }
          }
        }
        this._node.setEnabled(palmVisible && gazeVisible);
      }
      /**
       * Detaches the behavior from the `TransformNode`
       */
      detach() {
        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);
      }
      /**
       * Links the behavior to the XR experience in which to retrieve hand transform information.
       * @param xr xr experience
       */
      linkToXRExperience(xr) {
        const featuresManager = xr.featuresManager ? xr.featuresManager : xr;
        if (!featuresManager) {
          Tools.Error("XR features manager must be available or provided directly for the Hand Menu to work");
        } else {
          try {
            this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);
          } catch {
          }
          try {
            this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);
          } catch {
            Tools.Error("Hand tracking must be enabled for the Hand Menu to work");
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
var init_engine_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js"() {
    init_tools_functions();
    init_thinEngine();
    init_internalTexture();
    ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
      const texture = new InternalTexture(
        this,
        4
        /* InternalTextureSource.Dynamic */
      );
      texture.baseWidth = width;
      texture.baseHeight = height;
      if (generateMipMaps) {
        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
      }
      texture.width = width;
      texture.height = height;
      texture.isReady = false;
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      this.updateTextureSamplingMode(samplingMode, texture);
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
      if (!texture) {
        return;
      }
      const gl = this._gl;
      const target = gl.TEXTURE_2D;
      const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
      this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
      }
      const textureType = this._getWebGLTextureType(texture.type);
      const glformat = this._getInternalFormat(format ? format : texture.format);
      const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
      gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
      if (texture.generateMipMaps) {
        gl.generateMipmap(target);
      }
      if (!wasPreviouslyBound) {
        this._bindTextureDirectly(target, null);
      }
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      }
      if (format) {
        texture.format = format;
      }
      texture._dynamicTextureSource = source;
      texture._premulAlpha = premulAlpha;
      texture.invertY = invertY || false;
      texture.isReady = true;
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture;
var init_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js"() {
    init_logger();
    init_texture();
    init_engine_dynamicTexture();
    DynamicTexture = class _DynamicTexture extends Texture {
      /** @internal */
      constructor(name, canvasOrSize, sceneOrOptions, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
        const isScene = !sceneOrOptions || sceneOrOptions._isScene;
        const scene = isScene ? sceneOrOptions : sceneOrOptions == null ? void 0 : sceneOrOptions.scene;
        const noMipmap = isScene ? !generateMipMaps : sceneOrOptions;
        super(null, scene, noMipmap, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
        this.name = name;
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._generateMipMaps = generateMipMaps;
        const engine = this._getEngine();
        if (!engine) {
          return;
        }
        if (canvasOrSize.getContext) {
          this._canvas = canvasOrSize;
          this._ownCanvas = false;
          this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);
        } else {
          this._canvas = engine.createCanvas(1, 1);
          this._ownCanvas = true;
          const optionsAsSize = canvasOrSize;
          if (optionsAsSize.width || optionsAsSize.width === 0) {
            this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);
          } else {
            this._texture = engine.createDynamicTexture(canvasOrSize, canvasOrSize, generateMipMaps, samplingMode);
          }
        }
        const textureSize = this.getSize();
        if (this._canvas.width !== textureSize.width) {
          this._canvas.width = textureSize.width;
        }
        if (this._canvas.height !== textureSize.height) {
          this._canvas.height = textureSize.height;
        }
        this._context = this._canvas.getContext("2d");
      }
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "DynamicTexture"
       */
      getClassName() {
        return "DynamicTexture";
      }
      /**
       * Gets the current state of canRescale
       */
      get canRescale() {
        return true;
      }
      _recreate(textureSize) {
        this._canvas.width = textureSize.width;
        this._canvas.height = textureSize.height;
        this.releaseInternalTexture();
        this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
      }
      /**
       * Scales the texture
       * @param ratio the scale factor to apply to both width and height
       */
      scale(ratio) {
        const textureSize = this.getSize();
        textureSize.width *= ratio;
        textureSize.height *= ratio;
        this._recreate(textureSize);
      }
      /**
       * Resizes the texture
       * @param width the new width
       * @param height the new height
       */
      scaleTo(width, height) {
        const textureSize = this.getSize();
        textureSize.width = width;
        textureSize.height = height;
        this._recreate(textureSize);
      }
      /**
       * Gets the context of the canvas used by the texture
       * @returns the canvas context of the dynamic texture
       */
      getContext() {
        return this._context;
      }
      /**
       * Clears the texture
       * @param clearColor Defines the clear color to use
       */
      clear(clearColor) {
        const size = this.getSize();
        if (clearColor) {
          this._context.fillStyle = clearColor;
        }
        this._context.clearRect(0, 0, size.width, size.height);
      }
      /**
       * Updates the texture
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
       * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
       */
      update(invertY, premulAlpha = false, allowGPUOptimization = false) {
        this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
      }
      /**
       * Draws text onto the texture
       * @param text defines the text to be drawn
       * @param x defines the placement of the text from the left
       * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
       * @param font defines the font to be used with font-style, font-size, font-name
       * @param color defines the color used for the text
       * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param update defines whether texture is immediately update (default is true)
       */
      drawText(text, x, y, font, color, fillColor, invertY, update = true) {
        const size = this.getSize();
        if (fillColor) {
          this._context.fillStyle = fillColor;
          this._context.fillRect(0, 0, size.width, size.height);
        }
        this._context.font = font;
        if (x === null || x === void 0) {
          const textSize = this._context.measureText(text);
          x = (size.width - textSize.width) / 2;
        }
        if (y === null || y === void 0) {
          const fontSize = parseInt(font.replace(/\D/g, ""));
          y = size.height / 2 + fontSize / 3.65;
        }
        this._context.fillStyle = color || "";
        this._context.fillText(text, x, y);
        if (update) {
          this.update(invertY);
        }
      }
      /**
       * Disposes the dynamic texture.
       */
      dispose() {
        var _a, _b;
        super.dispose();
        if (this._ownCanvas) {
          (_b = (_a = this._canvas) == null ? void 0 : _a.remove) == null ? void 0 : _b.call(_a);
        }
        this._canvas = null;
        this._context = null;
      }
      /**
       * Clones the texture
       * @returns the clone of the texture.
       */
      clone() {
        const scene = this.getScene();
        if (!scene) {
          return this;
        }
        const textureSize = this.getSize();
        const newTexture = new _DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.wrapU = this.wrapU;
        newTexture.wrapV = this.wrapV;
        return newTexture;
      }
      /**
       * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
       * @returns a serialized dynamic texture object
       */
      serialize() {
        const scene = this.getScene();
        if (scene && !scene.isReady()) {
          Logger.Warn("The scene must be ready before serializing the dynamic texture");
        }
        const serializationObject = super.serialize();
        if (_DynamicTexture._IsCanvasElement(this._canvas)) {
          serializationObject.base64String = this._canvas.toDataURL();
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        return serializationObject;
      }
      static _IsCanvasElement(canvas) {
        return canvas.toDataURL !== void 0;
      }
      /** @internal */
      _rebuild() {
        this.update();
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer;
var init_utilityLayerRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js"() {
    init_scene();
    init_observable();
    init_pointerEvents();
    init_pickingInfo();
    init_engineStore();
    init_hemisphericLight();
    init_math_vector();
    init_math_color();
    UtilityLayerRenderer = class _UtilityLayerRenderer {
      /**
       * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
       * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
       * @returns the camera that is used when rendering the utility layer
       */
      getRenderCamera(getRigParentIfPossible) {
        if (this._renderCamera) {
          return this._renderCamera;
        } else {
          let activeCam;
          if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
            activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
          } else {
            activeCam = this.originalScene.activeCamera;
          }
          if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
            return activeCam.rigParent;
          }
          return activeCam;
        }
      }
      /**
       * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
       * @param cam the camera that should be used when rendering the utility layer
       */
      setRenderCamera(cam) {
        this._renderCamera = cam;
      }
      /**
       * @internal
       * Light which used by gizmos to get light shading
       */
      _getSharedGizmoLight() {
        if (!this._sharedGizmoLight) {
          this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
          this._sharedGizmoLight.intensity = 2;
          this._sharedGizmoLight.groundColor = Color3.Gray();
        }
        return this._sharedGizmoLight;
      }
      /**
       * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
       */
      static get DefaultUtilityLayer() {
        if (_UtilityLayerRenderer._DefaultUtilityLayer == null) {
          return _UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
        }
        return _UtilityLayerRenderer._DefaultUtilityLayer;
      }
      /**
       * Creates an utility layer, and set it as a default utility layer
       * @param scene associated scene
       * @internal
       */
      static _CreateDefaultUtilityLayerFromScene(scene) {
        _UtilityLayerRenderer._DefaultUtilityLayer = new _UtilityLayerRenderer(scene);
        _UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
          _UtilityLayerRenderer._DefaultUtilityLayer = null;
        });
        return _UtilityLayerRenderer._DefaultUtilityLayer;
      }
      /**
       * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
       */
      static get DefaultKeepDepthUtilityLayer() {
        if (_UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
          _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new _UtilityLayerRenderer(EngineStore.LastCreatedScene);
          _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
          _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
            _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
          });
        }
        return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
      }
      /**
       * Instantiates a UtilityLayerRenderer
       * @param originalScene the original scene that will be rendered on top of
       * @param handleEvents boolean indicating if the utility layer should handle events
       * @param manualRender boolean indicating if the utility layer should render manually.
       */
      constructor(originalScene, handleEvents = true, manualRender = false) {
        this.originalScene = originalScene;
        this.handleEvents = handleEvents;
        this._pointerCaptures = {};
        this._lastPointerEvents = {};
        this._sharedGizmoLight = null;
        this._renderCamera = null;
        this.pickUtilitySceneFirst = true;
        this.shouldRender = true;
        this.onlyCheckPointerDownEvents = true;
        this.processAllEvents = false;
        this.pickingEnabled = true;
        this.onPointerOutObservable = new Observable();
        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });
        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
        this.utilityLayerScene._allowPostProcessClearColor = false;
        this.utilityLayerScene.postProcessesEnabled = false;
        this.utilityLayerScene.detachControl();
        if (handleEvents) {
          this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
            var _a;
            if (!this.utilityLayerScene.activeCamera) {
              return;
            }
            if (!this.pickingEnabled) {
              return;
            }
            if (!this.processAllEvents) {
              if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
                return;
              }
            }
            this.utilityLayerScene.pointerX = originalScene.pointerX;
            this.utilityLayerScene.pointerY = originalScene.pointerY;
            const pointerEvent = prePointerInfo.event;
            if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
              this._pointerCaptures[pointerEvent.pointerId] = false;
              return;
            }
            const getNearPickDataForScene = (scene) => {
              let scenePick = null;
              if (prePointerInfo.nearInteractionPickingInfo) {
                if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
                  scenePick = prePointerInfo.nearInteractionPickingInfo;
                } else {
                  scenePick = new PickingInfo();
                }
              } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
                scenePick = prePointerInfo.originalPickingInfo;
              } else {
                let previousActiveCamera = null;
                if (this._renderCamera) {
                  previousActiveCamera = scene._activeCamera;
                  scene._activeCamera = this._renderCamera;
                  prePointerInfo.ray = null;
                }
                scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
                if (previousActiveCamera) {
                  scene._activeCamera = previousActiveCamera;
                }
              }
              return scenePick;
            };
            const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
            if (!prePointerInfo.ray && utilityScenePick) {
              prePointerInfo.ray = utilityScenePick.ray;
            }
            if (((_a = prePointerInfo.originalPickingInfo) == null ? void 0 : _a.aimTransform) && utilityScenePick) {
              utilityScenePick.aimTransform = prePointerInfo.originalPickingInfo.aimTransform;
              utilityScenePick.gripTransform = prePointerInfo.originalPickingInfo.gripTransform;
            }
            this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
            if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
              if (!prePointerInfo.skipOnPointerObservable) {
                this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
              }
              if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
                this._pointerCaptures[pointerEvent.pointerId] = false;
              }
              return;
            }
            if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
              if (utilityScenePick && utilityScenePick.hit) {
                if (!prePointerInfo.skipOnPointerObservable) {
                  this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
                }
                prePointerInfo.skipOnPointerObservable = true;
              }
            } else {
              const originalScenePick = getNearPickDataForScene(originalScene);
              const pointerEvent2 = prePointerInfo.event;
              if (originalScenePick && utilityScenePick) {
                if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
                  if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                    prePointerInfo.skipOnPointerObservable = true;
                  } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                    this._pointerCaptures[pointerEvent2.pointerId] = true;
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                  } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                    if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                      this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                      delete this._lastPointerEvents[pointerEvent2.pointerId];
                    }
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                  }
                } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
                  this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
                  if (!prePointerInfo.skipOnPointerObservable) {
                    prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
                  }
                } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
                  if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                    prePointerInfo.skipOnPointerObservable = true;
                  } else {
                    if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                      if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                        this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                        delete this._lastPointerEvents[pointerEvent2.pointerId];
                      }
                    }
                    this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
                  }
                }
                if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
                  this._pointerCaptures[pointerEvent2.pointerId] = false;
                }
              }
            }
          });
          if (this._originalPointerObserver) {
            originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
          }
        }
        this.utilityLayerScene.autoClear = false;
        if (!manualRender) {
          this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
            if (this.shouldRender && camera == this.getRenderCamera()) {
              this.render();
            }
          });
        }
        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
          this.dispose();
        });
        this._updateCamera();
      }
      _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
        if (!prePointerInfo.skipOnPointerObservable) {
          this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
          this._lastPointerEvents[pointerEvent.pointerId] = true;
        }
      }
      /**
       * Renders the utility layers scene on top of the original scene
       */
      render() {
        this._updateCamera();
        if (this.utilityLayerScene.activeCamera) {
          const oldScene = this.utilityLayerScene.activeCamera.getScene();
          const camera = this.utilityLayerScene.activeCamera;
          camera._scene = this.utilityLayerScene;
          if (camera.leftCamera) {
            camera.leftCamera._scene = this.utilityLayerScene;
          }
          if (camera.rightCamera) {
            camera.rightCamera._scene = this.utilityLayerScene;
          }
          this.utilityLayerScene.render(false);
          camera._scene = oldScene;
          if (camera.leftCamera) {
            camera.leftCamera._scene = oldScene;
          }
          if (camera.rightCamera) {
            camera.rightCamera._scene = oldScene;
          }
        }
      }
      /**
       * Disposes of the renderer
       */
      dispose() {
        this.onPointerOutObservable.clear();
        if (this._afterRenderObserver) {
          this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
        }
        if (this._sceneDisposeObserver) {
          this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
        }
        if (this._originalPointerObserver) {
          this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
        }
        this.utilityLayerScene.dispose();
      }
      _updateCamera() {
        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
        this.utilityLayerScene.activeCamera = this.getRenderCamera();
      }
    };
    UtilityLayerRenderer._DefaultUtilityLayer = null;
    UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
  }
});

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var GizmoAnchorPoint, GizmoCoordinatesMode, Gizmo;
var init_gizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/gizmo.js"() {
    init_math_vector();
    init_mesh();
    init_camera();
    init_utilityLayerRenderer();
    init_pointerEvents();
    init_light();
    (function(GizmoAnchorPoint2) {
      GizmoAnchorPoint2[GizmoAnchorPoint2["Origin"] = 0] = "Origin";
      GizmoAnchorPoint2[GizmoAnchorPoint2["Pivot"] = 1] = "Pivot";
    })(GizmoAnchorPoint || (GizmoAnchorPoint = {}));
    (function(GizmoCoordinatesMode2) {
      GizmoCoordinatesMode2[GizmoCoordinatesMode2["World"] = 0] = "World";
      GizmoCoordinatesMode2[GizmoCoordinatesMode2["Local"] = 1] = "Local";
    })(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));
    Gizmo = class _Gizmo {
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        this._scaleRatio = value;
      }
      get scaleRatio() {
        return this._scaleRatio;
      }
      /**
       * True when the mouse pointer is hovered a gizmo mesh
       */
      get isHovered() {
        return this._isHovered;
      }
      /**
       * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
       * * When set, interactions will be enabled
       */
      get attachedMesh() {
        return this._attachedMesh;
      }
      set attachedMesh(value) {
        this._attachedMesh = value;
        if (value) {
          this._attachedNode = value;
        }
        this._rootMesh.setEnabled(value ? true : false);
        this._attachedNodeChanged(value);
      }
      /**
       * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
       * * When set, interactions will be enabled
       */
      get attachedNode() {
        return this._attachedNode;
      }
      set attachedNode(value) {
        this._attachedNode = value;
        this._attachedMesh = null;
        this._rootMesh.setEnabled(value ? true : false);
        this._attachedNodeChanged(value);
      }
      /**
       * Disposes and replaces the current meshes in the gizmo with the specified mesh
       * @param mesh The mesh to replace the default mesh of the gizmo
       */
      setCustomMesh(mesh) {
        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
          throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
        }
        this._rootMesh.getChildMeshes().forEach((c) => {
          c.dispose();
        });
        mesh.parent = this._rootMesh;
        this._customMeshSet = true;
      }
      /**
       * Additional transform applied to the gizmo.
       * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.
       * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.
       */
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      set additionalTransformNode(value) {
        this._additionalTransformNode = value;
      }
      /**
       * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
       * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
       */
      set updateGizmoRotationToMatchAttachedMesh(value) {
        this._updateGizmoRotationToMatchAttachedMesh = value;
      }
      get updateGizmoRotationToMatchAttachedMesh() {
        return this._updateGizmoRotationToMatchAttachedMesh;
      }
      /**
       * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
       */
      set updateGizmoPositionToMatchAttachedMesh(value) {
        this._updateGizmoPositionToMatchAttachedMesh = value;
      }
      get updateGizmoPositionToMatchAttachedMesh() {
        return this._updateGizmoPositionToMatchAttachedMesh;
      }
      /**
       * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.
       * (Default: GizmoAnchorPoint.Origin)
       */
      set anchorPoint(value) {
        this._anchorPoint = value;
      }
      get anchorPoint() {
        return this._anchorPoint;
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        this._coordinatesMode = coordinatesMode;
        const local = coordinatesMode == 1;
        this.updateGizmoRotationToMatchAttachedMesh = local;
        this.updateGizmoPositionToMatchAttachedMesh = true;
      }
      get coordinatesMode() {
        return this._coordinatesMode;
      }
      /**
       * When set, the gizmo will always appear the same size no matter where the camera is (default: true)
       */
      set updateScale(value) {
        this._updateScale = value;
      }
      get updateScale() {
        return this._updateScale;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _attachedNodeChanged(value) {
      }
      /**
       * Creates a gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
        this.gizmoLayer = gizmoLayer;
        this._attachedMesh = null;
        this._attachedNode = null;
        this._customRotationQuaternion = null;
        this._scaleRatio = 1;
        this._isHovered = false;
        this._customMeshSet = false;
        this._updateGizmoRotationToMatchAttachedMesh = true;
        this._updateGizmoPositionToMatchAttachedMesh = true;
        this._anchorPoint = 0;
        this._updateScale = true;
        this._coordinatesMode = 1;
        this._interactionsEnabled = true;
        this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
        this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
        this._rootMesh.rotationQuaternion = Quaternion.Identity();
        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {
          this._update();
        });
      }
      /**
       * posture that the gizmo will be display
       * When set null, default value will be used (Quaternion(0, 0, 0, 1))
       */
      get customRotationQuaternion() {
        return this._customRotationQuaternion;
      }
      set customRotationQuaternion(customRotationQuaternion) {
        this._customRotationQuaternion = customRotationQuaternion;
      }
      /**
       * Updates the gizmo to match the attached mesh's position/rotation
       */
      _update() {
        if (this.attachedNode) {
          let effectiveNode = this.attachedNode;
          if (this.attachedMesh) {
            effectiveNode = this.attachedMesh || this.attachedNode;
          }
          if (this.updateGizmoPositionToMatchAttachedMesh) {
            if (this.anchorPoint == 1 && effectiveNode.getAbsolutePivotPoint) {
              const position = effectiveNode.getAbsolutePivotPoint();
              this._rootMesh.position.copyFrom(position);
            } else {
              const row = effectiveNode.getWorldMatrix().getRow(3);
              const position = row ? row.toVector3() : new Vector3(0, 0, 0);
              this._rootMesh.position.copyFrom(position);
            }
          }
          if (this.updateGizmoRotationToMatchAttachedMesh) {
            const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === "AbstractMesh" || effectiveNode.getClassName() === "TransformNode" || effectiveNode.getClassName() === "InstancedMesh";
            const transformNode = supportedNode ? effectiveNode : void 0;
            effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion, void 0, _Gizmo.PreserveScaling ? transformNode : void 0);
            this._rootMesh.rotationQuaternion.normalize();
          } else {
            if (this._customRotationQuaternion) {
              this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);
            } else {
              this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
            }
          }
          if (this.updateScale) {
            const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
            const cameraPosition = activeCamera.globalPosition;
            this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);
            let scale = this.scaleRatio;
            if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
              if (activeCamera.orthoTop && activeCamera.orthoBottom) {
                const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;
                scale *= orthoHeight;
              }
            } else {
              const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;
              const direction = activeCamera.getDirection(camForward);
              scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);
            }
            this._rootMesh.scaling.setAll(scale);
            if (effectiveNode._getWorldMatrixDeterminant() < 0 && !_Gizmo.PreserveScaling) {
              this._rootMesh.scaling.y *= -1;
            }
          } else {
            this._rootMesh.scaling.setAll(this.scaleRatio);
          }
        }
        if (this.additionalTransformNode) {
          this._rootMesh.computeWorldMatrix(true);
          this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);
          TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion, this._rootMesh.position);
        }
      }
      /**
       * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)
       * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.
       * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.
       * @param transform local transform that needs to be transform by the pivot inverse matrix
       * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix
       * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix
       */
      _handlePivotMatrixInverse(transform, localMatrix, result) {
        if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {
          transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);
          TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);
          return;
        }
        result.copyFrom(localMatrix);
      }
      /**
       * computes the rotation/scaling/position of the transform once the Node world matrix has changed.
       */
      _matrixChanged() {
        if (!this._attachedNode) {
          return;
        }
        if (this._attachedNode._isCamera) {
          const camera = this._attachedNode;
          let worldMatrix;
          let worldMatrixUC;
          if (camera.parent) {
            const parentInv = TmpVectors.Matrix[1];
            camera.parent._worldMatrix.invertToRef(parentInv);
            this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);
            worldMatrix = TmpVectors.Matrix[0];
          } else {
            worldMatrix = this._attachedNode._worldMatrix;
          }
          if (camera.getScene().useRightHandedSystem) {
            this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);
            worldMatrixUC = TmpVectors.Matrix[1];
          } else {
            worldMatrixUC = worldMatrix;
          }
          worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          const inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
          if (inheritsTargetCamera) {
            const targetCamera = this._attachedNode;
            targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();
            if (targetCamera.rotationQuaternion) {
              targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
              targetCamera.rotationQuaternion.normalize();
            }
          }
          camera.position.copyFrom(TmpVectors.Vector3[0]);
        } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
          const transform = this._attachedNode;
          if (transform.parent) {
            const parentInv = TmpVectors.Matrix[0];
            const localMat = TmpVectors.Matrix[1];
            transform.parent.getWorldMatrix().invertToRef(parentInv);
            this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
            const matrixToDecompose = TmpVectors.Matrix[4];
            this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);
            matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
            TmpVectors.Quaternion[0].normalize();
            if (transform.isUsingPivotMatrix()) {
              const r = TmpVectors.Quaternion[1];
              Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);
              const scaleMatrix = TmpVectors.Matrix[2];
              Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);
              const rotationMatrix = TmpVectors.Matrix[2];
              r.toRotationMatrix(rotationMatrix);
              const pivotMatrix = transform.getPivotMatrix();
              const invPivotMatrix = TmpVectors.Matrix[3];
              pivotMatrix.invertToRef(invPivotMatrix);
              pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
              TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);
              TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);
              TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);
              transform.position.subtractInPlace(TmpVectors.Vector3[1]);
            }
          } else {
            const matrixToDecompose = TmpVectors.Matrix[4];
            this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);
            matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
          }
          TmpVectors.Vector3[0].scaleInPlace(1 / transform.scalingDeterminant);
          transform.scaling.copyFrom(TmpVectors.Vector3[0]);
          if (!transform.billboardMode) {
            if (transform.rotationQuaternion) {
              transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
              transform.rotationQuaternion.normalize();
            } else {
              transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();
            }
          }
        } else if (this._attachedNode.getClassName() === "Bone") {
          const bone = this._attachedNode;
          const parent = bone.getParent();
          if (parent) {
            const invParent = TmpVectors.Matrix[0];
            const boneLocalMatrix = TmpVectors.Matrix[1];
            parent.getFinalMatrix().invertToRef(invParent);
            bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);
            const lmat = bone.getLocalMatrix();
            lmat.copyFrom(boneLocalMatrix);
          } else {
            const lmat = bone.getLocalMatrix();
            lmat.copyFrom(bone.getFinalMatrix());
          }
          bone.markAsDirty();
        } else {
          const light = this._attachedNode;
          if (light.getTypeID) {
            const type = light.getTypeID();
            if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {
              const parent = light.parent;
              if (parent) {
                const invParent = TmpVectors.Matrix[0];
                const nodeLocalMatrix = TmpVectors.Matrix[1];
                parent.getWorldMatrix().invertToRef(invParent);
                light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);
                nodeLocalMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
              } else {
                this._attachedNode._worldMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
              }
              light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
              if (light.direction) {
                light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);
              }
            }
          }
        }
      }
      /**
       * refresh gizmo mesh material
       * @param gizmoMeshes
       * @param material material to apply
       */
      _setGizmoMeshMaterial(gizmoMeshes, material) {
        if (gizmoMeshes) {
          gizmoMeshes.forEach((m) => {
            m.material = material;
            if (m.color) {
              m.color = material.diffuseColor;
            }
          });
        }
      }
      /**
       * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
       * @returns {Observer<PointerInfo>} pointerObserver
       */
      static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {
        let dragging = false;
        let activeDragButton = -1;
        let forcePointerUp = false;
        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          var _a, _b;
          if (pointerInfo.pickInfo) {
            forcePointerUp = dragging && pointerInfo.event.button !== -1 && pointerInfo.event.button !== activeDragButton;
            if (forcePointerUp || pointerInfo.type === PointerEventTypes.POINTERUP) {
              gizmoAxisCache.forEach((cache) => {
                cache.active = false;
                dragging = false;
                activeDragButton = -1;
                cache.gizmoMeshes.forEach((m) => {
                  m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;
                  if (m.color) {
                    m.color = cache.material.diffuseColor;
                  }
                });
              });
            } else if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
              if (dragging) {
                return;
              }
              gizmoAxisCache.forEach((cache) => {
                var _a2, _b2;
                if (cache.colliderMeshes && cache.gizmoMeshes) {
                  const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
                  const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;
                  cache.gizmoMeshes.forEach((m) => {
                    m.material = material;
                    if (m.color) {
                      m.color = material.diffuseColor;
                    }
                  });
                }
              });
            } else if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
              if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _a.parent)) {
                dragging = true;
                activeDragButton = pointerInfo.event.button;
                const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) == null ? void 0 : _b.parent);
                statusMap.active = true;
                gizmoAxisCache.forEach((cache) => {
                  var _a2, _b2;
                  const isHovered = ((_b2 = cache.colliderMeshes) == null ? void 0 : _b2.indexOf((_a2 = pointerInfo == null ? void 0 : pointerInfo.pickInfo) == null ? void 0 : _a2.pickedMesh)) != -1;
                  const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;
                  cache.gizmoMeshes.forEach((m) => {
                    m.material = material;
                    if (m.color) {
                      m.color = material.diffuseColor;
                    }
                  });
                });
              }
            }
          }
        });
        return pointerObserver;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this._rootMesh.dispose();
        if (this._beforeRenderObserver) {
          this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
      }
    };
    Gizmo.PreserveScaling = false;
    Gizmo.UseAbsoluteScaling = true;
  }
});

// node_modules/@babylonjs/core/Events/clipboardEvents.js
var ClipboardEventTypes, ClipboardInfo;
var init_clipboardEvents = __esm({
  "node_modules/@babylonjs/core/Events/clipboardEvents.js"() {
    ClipboardEventTypes = class {
    };
    ClipboardEventTypes.COPY = 1;
    ClipboardEventTypes.CUT = 2;
    ClipboardEventTypes.PASTE = 3;
    ClipboardInfo = class {
      /**
       *Creates an instance of ClipboardInfo.
       * @param type Defines the type of event (BABYLON.ClipboardEventTypes)
       * @param event Defines the related dom event
       */
      constructor(type, event) {
        this.type = type;
        this.event = event;
      }
      /**
       *  Get the clipboard event's type from the keycode.
       * @param keyCode Defines the keyCode for the current keyboard event.
       * @returns {number}
       */
      static GetTypeFromCharacter(keyCode) {
        const charCode = keyCode;
        switch (charCode) {
          case 67:
            return ClipboardEventTypes.COPY;
          case 86:
            return ClipboardEventTypes.PASTE;
          case 88:
            return ClipboardEventTypes.CUT;
          default:
            return -1;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Types/nodeRenderGraphTypes.js
var NodeRenderGraphBlockConnectionPointTypes, NodeRenderGraphConnectionPointCompatibilityStates, NodeRenderGraphConnectionPointDirection;
var init_nodeRenderGraphTypes = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Types/nodeRenderGraphTypes.js"() {
    (function(NodeRenderGraphBlockConnectionPointTypes2) {
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Texture"] = 1] = "Texture";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBuffer"] = 2] = "TextureBackBuffer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBufferDepthStencilAttachment"] = 4] = "TextureBackBufferDepthStencilAttachment";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureDepthStencilAttachment"] = 8] = "TextureDepthStencilAttachment";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewDepth"] = 16] = "TextureViewDepth";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewNormal"] = 32] = "TextureViewNormal";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedo"] = 64] = "TextureAlbedo";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureReflectivity"] = 128] = "TextureReflectivity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldPosition"] = 256] = "TextureWorldPosition";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureVelocity"] = 512] = "TextureVelocity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureIrradiance"] = 1024] = "TextureIrradiance";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedoSqrt"] = 2048] = "TextureAlbedoSqrt";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureScreenDepth"] = 4096] = "TextureScreenDepth";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldNormal"] = 8192] = "TextureWorldNormal";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLocalPosition"] = 16384] = "TextureLocalPosition";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLinearVelocity"] = 32768] = "TextureLinearVelocity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBufferDepthStencil"] = 1048571] = "TextureAllButBackBufferDepthStencil";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBuffer"] = 1048569] = "TextureAllButBackBuffer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAll"] = 1048575] = "TextureAll";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ResourceContainer"] = 1048576] = "ResourceContainer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowGenerator"] = 2097152] = "ShadowGenerator";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowLight"] = 4194304] = "ShadowLight";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Camera"] = 16777216] = "Camera";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ObjectList"] = 33554432] = "ObjectList";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["AutoDetect"] = 268435456] = "AutoDetect";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["BasedOnInput"] = 536870912] = "BasedOnInput";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Undefined"] = 1073741824] = "Undefined";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Object"] = 2147483648] = "Object";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["All"] = 4294967295] = "All";
    })(NodeRenderGraphBlockConnectionPointTypes || (NodeRenderGraphBlockConnectionPointTypes = {}));
    (function(NodeRenderGraphConnectionPointCompatibilityStates2) {
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["HierarchyIssue"] = 2] = "HierarchyIssue";
    })(NodeRenderGraphConnectionPointCompatibilityStates || (NodeRenderGraphConnectionPointCompatibilityStates = {}));
    (function(NodeRenderGraphConnectionPointDirection2) {
      NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Input"] = 0] = "Input";
      NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Output"] = 1] = "Output";
    })(NodeRenderGraphConnectionPointDirection || (NodeRenderGraphConnectionPointDirection = {}));
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.js
var NodeRenderGraphConnectionPoint;
var init_nodeRenderGraphBlockConnectionPoint = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.js"() {
    init_observable();
    init_nodeRenderGraphTypes();
    NodeRenderGraphConnectionPoint = class {
      /** Gets the direction of the point */
      get direction() {
        return this._direction;
      }
      /**
       * Checks if the value is a texture handle
       * @param value The value to check
       * @returns True if the value is a texture handle
       */
      static IsTextureHandle(value) {
        return value !== void 0 && Number.isFinite(value);
      }
      /**
       * Checks if the value is a shadow generator task
       * @param value The value to check
       * @returns True if the value is a shadow generator
       */
      static IsShadowGenerator(value) {
        return value !== void 0 && value.mapSize !== void 0;
      }
      /**
       * Checks if the value is a shadow light
       * @param value The value to check
       * @returns True if the value is a shadow light
       */
      static IsShadowLight(value) {
        return value !== void 0 && value.setShadowProjectionMatrix !== void 0;
      }
      /**
       * Gets or sets the connection point type (default is Undefined)
       */
      get type() {
        if (this._type === NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
          if (this._ownerBlock.isInput) {
            return this._ownerBlock.type;
          }
          if (this._connectedPoint) {
            return this._connectedPoint.type;
          }
          if (this._linkedConnectionSource) {
            if (this._linkedConnectionSource.isConnected) {
              return this._linkedConnectionSource.type;
            }
            if (this._linkedConnectionSource._defaultConnectionPointType) {
              return this._linkedConnectionSource._defaultConnectionPointType;
            }
          }
          if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        if (this._type === NodeRenderGraphBlockConnectionPointTypes.BasedOnInput) {
          if (this._typeConnectionSource) {
            const typeConnectionSource = typeof this._typeConnectionSource === "function" ? this._typeConnectionSource() : this._typeConnectionSource;
            if (!typeConnectionSource.isConnected) {
              return this._defaultConnectionPointType ?? typeConnectionSource.type;
            }
            return typeConnectionSource._connectedPoint.type;
          } else if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        return this._type;
      }
      set type(value) {
        this._type = value;
      }
      /**
       * Gets a boolean indicating that the current point is connected to another NodeRenderGraphBlock
       */
      get isConnected() {
        return this.connectedPoint !== null || this.hasEndpoints;
      }
      /** Get the other side of the connection (if any) */
      get connectedPoint() {
        return this._connectedPoint;
      }
      /** Get the block that owns this connection point */
      get ownerBlock() {
        return this._ownerBlock;
      }
      /** Get the block connected on the other side of this connection (if any) */
      get sourceBlock() {
        if (!this._connectedPoint) {
          return null;
        }
        return this._connectedPoint.ownerBlock;
      }
      /** Get the block connected on the endpoints of this connection (if any) */
      get connectedBlocks() {
        if (this._endpoints.length === 0) {
          return [];
        }
        return this._endpoints.map((e) => e.ownerBlock);
      }
      /** Gets the list of connected endpoints */
      get endpoints() {
        return this._endpoints;
      }
      /** Gets a boolean indicating if that output point is connected to at least one input */
      get hasEndpoints() {
        return this._endpoints && this._endpoints.length > 0;
      }
      /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
      get innerType() {
        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
          return this.type;
        }
        return this._type;
      }
      /**
       * Creates a block suitable to be used as an input for this input point.
       * If null is returned, a block based on the point type will be created.
       * @returns The returned string parameter is the name of the output point of NodeRenderGraphBlock (first parameter of the returned array) that can be connected to the input
       */
      createCustomInputBlock() {
        return null;
      }
      /**
       * Creates a new connection point
       * @param name defines the connection point name
       * @param ownerBlock defines the block hosting this connection point
       * @param direction defines the direction of the connection point
       */
      constructor(name, ownerBlock, direction) {
        this._connectedPoint = null;
        this._acceptedConnectionPointType = null;
        this._endpoints = new Array();
        this._type = NodeRenderGraphBlockConnectionPointTypes.Undefined;
        this._linkedConnectionSource = null;
        this._isMainLinkSource = false;
        this._typeConnectionSource = null;
        this._defaultConnectionPointType = null;
        this.needDualDirectionValidation = false;
        this.acceptedConnectionPointTypes = [];
        this.excludedConnectionPointTypes = [];
        this.onConnectionObservable = new Observable();
        this.onDisconnectionObservable = new Observable();
        this.isExposedOnFrame = false;
        this.exposedPortPosition = -1;
        this._ownerBlock = ownerBlock;
        this.name = name;
        this._direction = direction;
      }
      /**
       * Gets the current class name e.g. "NodeRenderGraphConnectionPoint"
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphConnectionPoint";
      }
      /**
       * Gets a boolean indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a boolean
       */
      canConnectTo(connectionPoint) {
        return this.checkCompatibilityState(connectionPoint) === 0;
      }
      /**
       * Gets a number indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a number defining the compatibility state
       */
      checkCompatibilityState(connectionPoint) {
        const ownerBlock = this._ownerBlock;
        const otherBlock = connectionPoint.ownerBlock;
        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
          if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {
            return 0;
          } else {
            return 1;
          }
        }
        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
          return 1;
        }
        let targetBlock = otherBlock;
        let sourceBlock = ownerBlock;
        if (this.direction === 0) {
          targetBlock = ownerBlock;
          sourceBlock = otherBlock;
        }
        if (targetBlock.isAnAncestorOf(sourceBlock)) {
          return 2;
        }
        return 0;
      }
      /**
       * Connect this point to another connection point
       * @param connectionPoint defines the other connection point
       * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
       * @returns the current connection point
       */
      connectTo(connectionPoint, ignoreConstraints = false) {
        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
          throw "Cannot connect these two connectors.";
        }
        this._endpoints.push(connectionPoint);
        connectionPoint._connectedPoint = this;
        this.onConnectionObservable.notifyObservers(connectionPoint);
        connectionPoint.onConnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Disconnect this point from one of his endpoint
       * @param endpoint defines the other connection point
       * @returns the current connection point
       */
      disconnectFrom(endpoint) {
        const index = this._endpoints.indexOf(endpoint);
        if (index === -1) {
          return this;
        }
        this._endpoints.splice(index, 1);
        endpoint._connectedPoint = null;
        this.onDisconnectionObservable.notifyObservers(endpoint);
        endpoint.onDisconnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Fills the list of excluded connection point types with all types other than those passed in the parameter
       * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
       */
      addExcludedConnectionPointFromAllowedTypes(mask) {
        let bitmask = 0;
        let val = 2 ** bitmask;
        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
          if (!(mask & val)) {
            this.excludedConnectionPointTypes.push(val);
          }
          bitmask++;
          val = 2 ** bitmask;
        }
      }
      /**
       * Adds accepted connection point types
       * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed to connect to this point
       */
      addAcceptedConnectionPointTypes(mask) {
        let bitmask = 0;
        let val = 2 ** bitmask;
        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
          if (mask & val && this.acceptedConnectionPointTypes.indexOf(val) === -1) {
            this.acceptedConnectionPointTypes.push(val);
          }
          bitmask++;
          val = 2 ** bitmask;
        }
      }
      /**
       * Serializes this point in a JSON representation
       * @param isInput defines if the connection point is an input (default is true)
       * @returns the serialized point object
       */
      serialize(isInput = true) {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.displayName = this.displayName;
        if (isInput && this.connectedPoint) {
          serializationObject.inputName = this.name;
          serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
          serializationObject.targetConnectionName = this.connectedPoint.name;
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        return serializationObject;
      }
      /**
       * Release resources
       */
      dispose() {
        this.onConnectionObservable.clear();
        this.onDisconnectionObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlock.js
var NodeRenderGraphBlock;
var init_nodeRenderGraphBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_decorators();
    init_uniqueIdGenerator();
    init_nodeRenderGraphTypes();
    init_observable();
    init_logger();
    init_nodeRenderGraphBlockConnectionPoint();
    NodeRenderGraphBlock = class {
      /**
       * Gets or sets the disable flag of the task associated with this block
       */
      get disabled() {
        var _a;
        return !!((_a = this._frameGraphTask) == null ? void 0 : _a.disabled);
      }
      set disabled(value) {
        if (this._frameGraphTask) {
          this._frameGraphTask.disabled = value;
        }
      }
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Gets the list of input points
       */
      get inputs() {
        return this._inputs;
      }
      /** Gets the list of output points */
      get outputs() {
        return this._outputs;
      }
      /**
       * Gets or set the name of the block
       */
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      /**
       * Gets a boolean indicating if this block is an input
       */
      get isInput() {
        return this._isInput;
      }
      /**
       * Gets a boolean indicating if this block is a teleport out
       */
      get isTeleportOut() {
        return this._isTeleportOut;
      }
      /**
       * Gets a boolean indicating if this block is a teleport in
       */
      get isTeleportIn() {
        return this._isTeleportIn;
      }
      /**
       * Gets a boolean indicating if this block is a debug block
       */
      get isDebug() {
        return this._isDebug;
      }
      /**
       * Gets a boolean indicating that this block can only be used once per node render graph
       */
      get isUnique() {
        return this._isUnique;
      }
      /**
       * Gets the current class name e.g. "NodeRenderGraphBlock"
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphBlock";
      }
      _inputRename(name) {
        return name;
      }
      _outputRename(name) {
        return name;
      }
      /**
       * Checks if the current block is an ancestor of a given block
       * @param block defines the potential descendant block to check
       * @returns true if block is a descendant
       */
      isAnAncestorOf(block) {
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock === block) {
              return true;
            }
            if (endpoint.ownerBlock.isAnAncestorOf(block)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks if the current block is an ancestor of a given type
       * @param type defines the potential type to check
       * @returns true if block is a descendant
       */
      isAnAncestorOfType(type) {
        if (this.getClassName() === type) {
          return true;
        }
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock.isAnAncestorOfType(type)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Get the first descendant using a predicate
       * @param predicate defines the predicate to check
       * @returns descendant or null if none found
       */
      getDescendantOfPredicate(predicate) {
        if (predicate(this)) {
          return this;
        }
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);
            if (descendant) {
              return descendant;
            }
          }
        }
        return null;
      }
      /**
       * Creates a new NodeRenderGraphBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       * @param _additionalConstructionParameters defines additional parameters to pass to the block constructor
       */
      constructor(name, frameGraph, scene, ..._additionalConstructionParameters) {
        this._name = "";
        this._isInput = false;
        this._isTeleportOut = false;
        this._isTeleportIn = false;
        this._isDebug = false;
        this._isUnique = false;
        this.onBuildObservable = new Observable();
        this._inputs = new Array();
        this._outputs = new Array();
        this._codeVariableName = "";
        this._additionalConstructionParameters = null;
        this.visibleOnFrame = false;
        this._name = name;
        this._frameGraph = frameGraph;
        this._scene = scene;
        this._engine = scene.getEngine();
        this.uniqueId = UniqueIdGenerator.UniqueId;
      }
      /**
       * Register a new input. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param isOptional defines a boolean indicating that this input can be omitted
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerInput(name, type, isOptional = false, point) {
        point = point ?? new NodeRenderGraphConnectionPoint(
          name,
          this,
          0
          /* NodeRenderGraphConnectionPointDirection.Input */
        );
        point.type = type;
        point.isOptional = isOptional;
        this._inputs.push(point);
        return this;
      }
      /**
       * Register a new output. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerOutput(name, type, point) {
        point = point ?? new NodeRenderGraphConnectionPoint(
          name,
          this,
          1
          /* NodeRenderGraphConnectionPointDirection.Output */
        );
        point.type = type;
        this._outputs.push(point);
        return this;
      }
      _addDependenciesInput(additionalAllowedTypes = 0) {
        this.registerInput("dependencies", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        const dependencies = this.getInputByName("dependencies");
        dependencies.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer | NodeRenderGraphBlockConnectionPointTypes.ShadowGenerator | additionalAllowedTypes);
        return dependencies;
      }
      _buildBlock(_state) {
      }
      _customBuildStep(_state) {
      }
      _propagateInputValueToOutput(inputConnectionPoint, outputConnectionPoint) {
        if (inputConnectionPoint.connectedPoint) {
          outputConnectionPoint.value = inputConnectionPoint.connectedPoint.value;
        }
      }
      /**
       * Build the current node and generate the vertex data
       * @param state defines the current generation state
       * @returns true if already built
       */
      build(state) {
        var _a;
        if (this._buildId === state.buildId) {
          return true;
        }
        this._buildId = state.buildId;
        for (const input of this._inputs) {
          if (!input.connectedPoint) {
            if (!input.isOptional) {
              state._notConnectedNonOptionalInputs.push(input);
            }
            continue;
          }
          const block = input.connectedPoint.ownerBlock;
          if (block && block !== this) {
            block.build(state);
          }
        }
        this._customBuildStep(state);
        if (state.verbose) {
          Logger.Log(`Building ${this.name} [${this.getClassName()}]`);
        }
        if (this._frameGraphTask) {
          this._frameGraphTask.name = this.name;
        }
        this._buildBlock(state);
        if (this._frameGraphTask) {
          this._frameGraphTask.dependencies = void 0;
          const dependenciesConnectedPoint = (_a = this.getInputByName("dependencies")) == null ? void 0 : _a.connectedPoint;
          if (dependenciesConnectedPoint) {
            if (dependenciesConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {
              const container = dependenciesConnectedPoint.ownerBlock;
              for (let i = 0; i < container.inputs.length; i++) {
                const input = container.inputs[i];
                if (input.connectedPoint && input.connectedPoint.value !== void 0 && NodeRenderGraphConnectionPoint.IsTextureHandle(input.connectedPoint.value)) {
                  this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
                  this._frameGraphTask.dependencies.add(input.connectedPoint.value);
                }
              }
            } else if (NodeRenderGraphConnectionPoint.IsTextureHandle(dependenciesConnectedPoint.value)) {
              this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
              this._frameGraphTask.dependencies.add(dependenciesConnectedPoint.value);
            }
          }
          this._frameGraph.addTask(this._frameGraphTask);
        }
        this.onBuildObservable.notifyObservers(this);
        return false;
      }
      _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
        if (looseCoupling) {
          this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
        } else {
          this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
          this._inputs[inputIndex0]._isMainLinkSource = true;
        }
        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
      }
      /**
       * Initialize the block and prepare the context for build
       */
      initialize() {
      }
      /**
       * Lets the block try to connect some inputs automatically
       */
      autoConfigure() {
      }
      /**
       * Find an input by its name
       * @param name defines the name of the input to look for
       * @returns the input or null if not found
       */
      getInputByName(name) {
        const filter = this._inputs.filter((e) => e.name === name);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Find an output by its name
       * @param name defines the name of the output to look for
       * @returns the output or null if not found
       */
      getOutputByName(name) {
        const filter = this._outputs.filter((e) => e.name === name);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.id = this.uniqueId;
        serializationObject.name = this.name;
        serializationObject.visibleOnFrame = this.visibleOnFrame;
        serializationObject.disabled = this.disabled;
        if (this._additionalConstructionParameters) {
          serializationObject.additionalConstructionParameters = this._additionalConstructionParameters;
        }
        serializationObject.inputs = [];
        serializationObject.outputs = [];
        for (const input of this.inputs) {
          serializationObject.inputs.push(input.serialize());
        }
        for (const output of this.outputs) {
          serializationObject.outputs.push(output.serialize(false));
        }
        return serializationObject;
      }
      /**
       * @internal
       */
      _deserialize(serializationObject) {
        this._name = serializationObject.name;
        this.comments = serializationObject.comments;
        this.visibleOnFrame = serializationObject.visibleOnFrame;
        this.disabled = serializationObject.disabled;
        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
      }
      _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
        const serializedInputs = serializationObject.inputs;
        const serializedOutputs = serializationObject.outputs;
        if (serializedInputs) {
          serializedInputs.forEach((port) => {
            const input = this.inputs.find((i) => i.name === port.name);
            if (!input) {
              return;
            }
            if (port.displayName) {
              input.displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              input.isExposedOnFrame = port.isExposedOnFrame;
              input.exposedPortPosition = port.exposedPortPosition;
            }
          });
        }
        if (serializedOutputs) {
          serializedOutputs.forEach((port, i) => {
            if (port.displayName) {
              this.outputs[i].displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
              this.outputs[i].exposedPortPosition = port.exposedPortPosition;
            }
          });
        }
      }
      _dumpPropertiesCode() {
        const variableName = this._codeVariableName;
        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.disabled = ${this.disabled};
`;
      }
      /**
       * @internal
       */
      _dumpCodeForOutputConnections(alreadyDumped) {
        let codeString = "";
        if (alreadyDumped.indexOf(this) !== -1) {
          return codeString;
        }
        alreadyDumped.push(this);
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
          codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
        }
        return codeString;
      }
      /**
       * @internal
       */
      _dumpCode(uniqueNames, alreadyDumped) {
        alreadyDumped.push(this);
        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
          let index = 0;
          do {
            index++;
            this._codeVariableName = nameAsVariableName + index;
          } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
        }
        uniqueNames.push(this._codeVariableName);
        let codeString = `
// ${this.getClassName()}
`;
        if (this.comments) {
          codeString += `// ${this.comments}
`;
        }
        const className = this.getClassName();
        if (className === "RenderGraphInputBlock") {
          const block = this;
          const blockType = block.type;
          codeString += `var ${this._codeVariableName} = new BABYLON.NodeRenderGraphInputBlock("${this.name}", nodeRenderGraph.frameGraph, scene, BABYLON.NodeRenderGraphBlockConnectionPointTypes.${NodeRenderGraphBlockConnectionPointTypes[blockType]});
`;
        } else {
          if (this._additionalConstructionParameters) {
            codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene, ...${JSON.stringify(this._additionalConstructionParameters)});
`;
          } else {
            codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene);
`;
          }
        }
        codeString += this._dumpPropertiesCode() + "\n";
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          if (alreadyDumped.indexOf(connectedBlock) === -1) {
            codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
          }
        }
        for (const output of this.outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const connectedBlock = endpoint.ownerBlock;
            if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
              codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
            }
          }
        }
        return codeString;
      }
      /**
       * Clone the current block to a new identical block
       * @returns a copy of the current block
       */
      clone() {
        const serializationObject = this.serialize();
        const blockType = GetClass(serializationObject.customType);
        if (blockType) {
          const additionalConstructionParameters = serializationObject.additionalConstructionParameters;
          const block = additionalConstructionParameters ? new blockType("", this._frameGraph, this._scene, ...additionalConstructionParameters) : new blockType("", this._frameGraph, this._scene);
          block._deserialize(serializationObject);
          return block;
        }
        return null;
      }
      /**
       * Release resources
       */
      dispose() {
        var _a;
        for (const input of this.inputs) {
          input.dispose();
        }
        for (const output of this.outputs) {
          output.dispose();
        }
        (_a = this._frameGraphTask) == null ? void 0 : _a.dispose();
        this._frameGraphTask = void 0;
        this.onBuildObservable.clear();
      }
    };
    __decorate([
      serialize("comment")
    ], NodeRenderGraphBlock.prototype, "comments", void 0);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/pass.js
var FrameGraphPass;
var init_pass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/pass.js"() {
    FrameGraphPass = class {
      constructor(name, _parentTask, _context) {
        this.name = name;
        this._parentTask = _parentTask;
        this._context = _context;
        this.disabled = false;
      }
      setExecuteFunc(func) {
        this._executeFunc = func;
      }
      _execute() {
        if (!this.disabled) {
          this._executeFunc(this._context);
        }
      }
      _isValid() {
        return this._executeFunc !== void 0 ? null : "Execute function is not set (call setExecuteFunc to set it)";
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/cullPass.js
var FrameGraphCullPass;
var init_cullPass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/cullPass.js"() {
    init_pass();
    FrameGraphCullPass = class extends FrameGraphPass {
      /**
       * Checks if a pass is a cull pass.
       * @param pass The pass to check.
       * @returns True if the pass is a cull pass, else false.
       */
      static IsCullPass(pass) {
        return pass.setObjectList !== void 0;
      }
      /**
       * Gets the object list used by the cull pass.
       */
      get objectList() {
        return this._objectList;
      }
      /**
       * Sets the object list to use for culling.
       * @param objectList The object list to use for culling.
       */
      setObjectList(objectList) {
        this._objectList = objectList;
      }
      /** @internal */
      constructor(name, parentTask, context, engine) {
        super(name, parentTask, context);
        this._engine = engine;
      }
      /** @internal */
      _isValid() {
        const errMsg = super._isValid();
        return errMsg ? errMsg : this._objectList !== void 0 ? null : "Object list is not set (call setObjectList to set it)";
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js
var FrameGraphRenderPass;
var init_renderPass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js"() {
    init_pass();
    FrameGraphRenderPass = class extends FrameGraphPass {
      /**
       * Checks if a pass is a render pass.
       * @param pass The pass to check.
       * @returns True if the pass is a render pass, else false.
       */
      static IsRenderPass(pass) {
        return pass.setRenderTarget !== void 0;
      }
      /**
       * Gets the render target(s) used by the render pass.
       */
      get renderTarget() {
        return this._renderTarget;
      }
      /**
       * Gets the render target depth used by the render pass.
       */
      get renderTargetDepth() {
        return this._renderTargetDepth;
      }
      /** @internal */
      constructor(name, parentTask, context, engine) {
        super(name, parentTask, context);
        this._dependencies = /* @__PURE__ */ new Set();
        this._engine = engine;
      }
      /**
       * Sets the render target(s) to use for rendering.
       * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.
       */
      setRenderTarget(renderTargetHandle) {
        this._renderTarget = renderTargetHandle;
      }
      /**
       * Sets the render target depth to use for rendering.
       * @param renderTargetHandle The render target depth to use for rendering.
       */
      setRenderTargetDepth(renderTargetHandle) {
        this._renderTargetDepth = renderTargetHandle;
      }
      /**
       * Adds dependencies to the render pass.
       * @param dependencies The dependencies to add.
       */
      addDependencies(dependencies) {
        if (Array.isArray(dependencies)) {
          for (const dependency of dependencies) {
            this._dependencies.add(dependency);
          }
        } else {
          this._dependencies.add(dependencies);
        }
      }
      /**
       * Collects the dependencies of the render pass.
       * @param dependencies The set of dependencies to update.
       */
      collectDependencies(dependencies) {
        const iterator = this._dependencies.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          dependencies.add(key.value);
        }
        if (this._renderTarget) {
          if (Array.isArray(this._renderTarget)) {
            for (const handle of this._renderTarget) {
              if (handle !== void 0) {
                dependencies.add(handle);
              }
            }
          } else {
            dependencies.add(this._renderTarget);
          }
        }
        if (this._renderTargetDepth) {
          dependencies.add(this._renderTargetDepth);
        }
      }
      /** @internal */
      _execute() {
        this._frameGraphRenderTarget = this._frameGraphRenderTarget || this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth);
        this._context.bindRenderTarget(this._frameGraphRenderTarget, `frame graph render pass - ${this.name}`);
        super._execute();
        this._context._flushDebugMessages();
      }
      /** @internal */
      _isValid() {
        const errMsg = super._isValid();
        return errMsg ? errMsg : this._renderTarget !== void 0 || this.renderTargetDepth !== void 0 ? null : "Render target and render target depth cannot both be undefined.";
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js
var FrameGraphTask;
var init_frameGraphTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js"() {
    init_cullPass();
    init_renderPass();
    init_observable();
    FrameGraphTask = class {
      /**
       * The name of the task.
       */
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      /**
       * Whether the task is disabled.
       */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
      }
      /**
       * Gets the render passes of the task.
       */
      get passes() {
        return this._passes;
      }
      /**
       * Gets the disabled render passes of the task.
       */
      get passesDisabled() {
        return this._passesDisabled;
      }
      /**
       * Checks if the task is ready to be executed.
       * @returns True if the task is ready to be executed, else false.
       */
      isReady() {
        return true;
      }
      /**
       * Disposes of the task.
       */
      dispose() {
        this._reset();
        this.onTexturesAllocatedObservable.clear();
      }
      /**
       * Constructs a new frame graph task.
       * @param name The name of the task.
       * @param frameGraph The frame graph this task is associated with.
       */
      constructor(name, frameGraph) {
        this._passes = [];
        this._passesDisabled = [];
        this._disabled = false;
        this.onTexturesAllocatedObservable = new Observable();
        this.name = name;
        this._frameGraph = frameGraph;
        this._reset();
      }
      /** @internal */
      _reset() {
        this._passes.length = 0;
        this._passesDisabled.length = 0;
      }
      /** @internal */
      _addPass(pass, disabled) {
        if (disabled) {
          this._passesDisabled.push(pass);
        } else {
          this._passes.push(pass);
        }
      }
      /** @internal */
      _checkTask() {
        let outputTexture = null;
        let outputDepthTexture = null;
        let outputObjectList;
        for (const pass of this._passes) {
          const errMsg = pass._isValid();
          if (errMsg) {
            throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
          }
          if (FrameGraphRenderPass.IsRenderPass(pass)) {
            const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
            outputTexture = [];
            for (const handle of handles) {
              if (handle !== void 0) {
                outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
              }
            }
            outputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
          } else if (FrameGraphCullPass.IsCullPass(pass)) {
            outputObjectList = pass.objectList;
          }
        }
        let disabledOutputTexture = null;
        let disabledOutputTextureHandle = [];
        let disabledOutputDepthTexture = null;
        let disabledOutputObjectList;
        for (const pass of this._passesDisabled) {
          const errMsg = pass._isValid();
          if (errMsg) {
            throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
          }
          if (FrameGraphRenderPass.IsRenderPass(pass)) {
            const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
            disabledOutputTexture = [];
            for (const handle of handles) {
              if (handle !== void 0) {
                disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
              }
            }
            disabledOutputTextureHandle = handles;
            disabledOutputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
          } else if (FrameGraphCullPass.IsCullPass(pass)) {
            disabledOutputObjectList = pass.objectList;
          }
        }
        if (this._passesDisabled.length > 0) {
          if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {
            let ok = true;
            for (const handle of disabledOutputTextureHandle) {
              if (handle !== void 0 && !this._frameGraph.textureManager.isHistoryTexture(handle)) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`);
            }
          }
          if (outputDepthTexture !== disabledOutputDepthTexture) {
            throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);
          }
          if (outputObjectList !== disabledOutputObjectList) {
            throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`);
          }
        }
      }
      /** @internal */
      _getPasses() {
        return this.disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;
      }
      _checkSameRenderTarget(src, dst) {
        if (src === null || dst === null) {
          return src === dst;
        }
        if (src.length !== dst.length) {
          return false;
        }
        for (let i = 0; i < src.length; i++) {
          if (src[i] !== dst[i]) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Layers/layerSceneComponent.js
var LayerSceneComponent;
var init_layerSceneComponent = __esm({
  "node_modules/@babylonjs/core/Layers/layerSceneComponent.js"() {
    init_sceneComponent();
    init_engineStore();
    LayerSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_LAYER;
        this.scene = scene || EngineStore.LastCreatedScene;
        if (!this.scene) {
          return;
        }
        this._engine = this.scene.getEngine();
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);
        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);
        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);
        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);
        this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
        const layers = this.scene.layers;
        for (const layer of layers) {
          layer._rebuild();
        }
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        const layers = this.scene.layers;
        while (layers.length) {
          layers[0].dispose();
        }
      }
      _draw(predicate) {
        const layers = this.scene.layers;
        if (layers.length) {
          this._engine.setDepthBuffer(false);
          for (const layer of layers) {
            if (predicate(layer)) {
              layer.render();
            }
          }
          this._engine.setDepthBuffer(true);
        }
      }
      _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {
        return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;
      }
      _drawCameraBackground(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, true, true, camera.layerMask);
        });
      }
      _drawCameraForegroundWithPostProcessing(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, false, true, camera.layerMask);
        });
      }
      _drawCameraForegroundWithoutPostProcessing(camera) {
        this._draw((layer) => {
          return this._drawCameraPredicate(layer, false, false, camera.layerMask);
        });
      }
      _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {
        return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;
      }
      _drawRenderTargetBackground(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      _drawRenderTargetForegroundWithPostProcessing(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {
        this._draw((layer) => {
          return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);
        });
      }
      /**
       * Adds all the elements from the container to the scene
       * @param container the container holding the elements
       */
      addFromContainer(container) {
        if (!container.layers) {
          return;
        }
        container.layers.forEach((layer) => {
          this.scene.layers.push(layer);
        });
      }
      /**
       * Removes all the elements in the container from the scene
       * @param container contains the elements to remove
       * @param dispose if the removed element should be disposed (default: false)
       */
      removeFromContainer(container, dispose = false) {
        if (!container.layers) {
          return;
        }
        container.layers.forEach((layer) => {
          const index = this.scene.layers.indexOf(layer);
          if (index !== -1) {
            this.scene.layers.splice(index, 1);
          }
          if (dispose) {
            layer.dispose();
          }
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Layers/layer.js
var Layer;
var init_layer = __esm({
  "node_modules/@babylonjs/core/Layers/layer.js"() {
    init_observable();
    init_math_vector();
    init_math_color();
    init_engineStore();
    init_buffer();
    init_material();
    init_texture();
    init_sceneComponent();
    init_layerSceneComponent();
    init_drawWrapper();
    Layer = class _Layer {
      /**
       * Determines if the layer is drawn before (true) or after (false) post-processing.
       * If the layer is background, it is always before.
       */
      set applyPostProcess(value) {
        this._applyPostProcess = value;
      }
      get applyPostProcess() {
        return this.isBackground || this._applyPostProcess;
      }
      /**
       * Back compatibility with callback before the onDisposeObservable existed.
       * The set callback will be triggered when the layer has been disposed.
       */
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      /**
       * Back compatibility with callback before the onBeforeRenderObservable existed.
       * The set callback will be triggered just before rendering the layer.
       */
      set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
          this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
      /**
       * Back compatibility with callback before the onAfterRenderObservable existed.
       * The set callback will be triggered just after rendering the layer.
       */
      set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
          this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Instantiates a new layer.
       * This represents a full screen 2d layer.
       * This can be useful to display a picture in the  background of your scene for instance.
       * @see https://www.babylonjs-playground.com/#08A2BS#1
       * @param name Define the name of the layer in the scene
       * @param imgUrl Define the url of the texture to display in the layer
       * @param scene Define the scene the layer belongs to
       * @param isBackground Defines whether the layer is displayed in front or behind the scene
       * @param color Defines a color for the layer
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, imgUrl, scene, isBackground, color, forceGLSL = false) {
        this.name = name;
        this._applyPostProcess = true;
        this.scale = new Vector2(1, 1);
        this.offset = new Vector2(0, 0);
        this.alphaBlendingMode = 2;
        this.layerMask = 268435455;
        this.renderTargetTextures = [];
        this.renderOnlyInRenderTargetTextures = false;
        this.convertToLinearSpace = false;
        this.isEnabled = true;
        this._vertexBuffers = {};
        this.onDisposeObservable = new Observable();
        this.onBeforeRenderObservable = new Observable();
        this.onAfterRenderObservable = new Observable();
        this._shaderLanguage = 0;
        this._shadersLoaded = false;
        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;
        this.isBackground = isBackground === void 0 ? true : isBackground;
        this.color = color === void 0 ? new Color4(1, 1, 1, 1) : color;
        this._scene = scene || EngineStore.LastCreatedScene;
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_Layer.ForceGLSL) {
          this._shaderLanguage = 1;
        }
        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);
        if (!layerComponent) {
          layerComponent = new LayerSceneComponent(this._scene);
          this._scene._addComponent(layerComponent);
        }
        this._scene.layers.push(this);
        this._drawWrapper = new DrawWrapper(engine);
        const vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);
        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
        this._createIndexBuffer();
      }
      _createIndexBuffer() {
        const engine = this._scene.getEngine();
        const indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = engine.createIndexBuffer(indices);
      }
      /** @internal */
      _rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
          vb._rebuild();
        }
        this._createIndexBuffer();
      }
      /**
       * Checks if the layer is ready to be rendered
       * @returns true if the layer is ready. False otherwise.
       */
      isReady() {
        const engine = this._scene.getEngine();
        let defines = "";
        if (this.alphaTest) {
          defines = "#define ALPHATEST";
        }
        if (this.texture) {
          if (this.texture.gammaSpace) {
            if (this.convertToLinearSpace) {
              defines += "\n#define CONVERT_TO_LINEAR";
            }
          } else if (!this.convertToLinearSpace) {
            defines += "\n#define CONVERT_TO_GAMMA";
          }
        }
        if (this._previousDefines !== defines) {
          this._previousDefines = defines;
          this._drawWrapper.effect = engine.createEffect("layer", [VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], defines, void 0, void 0, void 0, void 0, this._shaderLanguage, this._shadersLoaded ? void 0 : async () => {
            if (this._shaderLanguage === 1) {
              await Promise.all([import("./layer.vertex-BGFBUI7C.js"), import("./layer.fragment-2XUEUH7K.js")]);
            } else {
              await Promise.all([import("./layer.vertex-K63F3FP7.js"), import("./layer.fragment-AJLWWQXU.js")]);
            }
            this._shadersLoaded = true;
          });
        }
        const currentEffect = this._drawWrapper.effect;
        return !!(currentEffect == null ? void 0 : currentEffect.isReady()) && (!this.texture || this.texture.isReady());
      }
      /**
       * Renders the layer in the scene.
       */
      render() {
        if (!this.isEnabled) {
          return;
        }
        const engine = this._scene.getEngine();
        if (!this.isReady()) {
          return;
        }
        const currentEffect = this._drawWrapper.effect;
        this.onBeforeRenderObservable.notifyObservers(this);
        engine.enableEffect(this._drawWrapper);
        engine.setState(false);
        if (this.texture) {
          currentEffect.setTexture("textureSampler", this.texture);
          currentEffect.setMatrix("textureMatrix", this.texture.getTextureMatrix());
        }
        currentEffect.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a);
        currentEffect.setVector2("offset", this.offset);
        currentEffect.setVector2("scale", this.scale);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);
        if (!this.alphaTest) {
          engine.setAlphaMode(this.alphaBlendingMode);
          engine.drawElementsType(Material.TriangleFillMode, 0, 6);
          engine.setAlphaMode(0);
        } else {
          engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        }
        this.onAfterRenderObservable.notifyObservers(this);
      }
      /**
       * Disposes and releases the associated resources.
       */
      dispose() {
        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
          vertexBuffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
          this._scene.getEngine()._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        if (this.texture) {
          this.texture.dispose();
          this.texture = null;
        }
        this.renderTargetTextures = [];
        const index = this._scene.layers.indexOf(this);
        this._scene.layers.splice(index, 1);
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onBeforeRenderObservable.clear();
      }
    };
    Layer.ForceGLSL = false;
  }
});

// node_modules/@babylonjs/core/Maths/math.scalar.js
var HCF, Scalar;
var init_math_scalar = __esm({
  "node_modules/@babylonjs/core/Maths/math.scalar.js"() {
    init_math_scalar_functions();
    HCF = HighestCommonFactor;
    Scalar = {
      ...math_scalar_functions_exports,
      /**
       * Two pi constants convenient for computation.
       */
      TwoPi: Math.PI * 2,
      /**
       * Returns -1 if value is negative and +1 is value is positive.
       * @param value the value
       * @returns the value itself if it's equal to zero.
       */
      Sign: Math.sign,
      /**
       * the log2 of value.
       * @param value the value to compute log2 of
       * @returns the log2 of value.
       */
      Log2: Math.log2,
      /**
       * Returns the highest common factor of two integers.
       * @param a first parameter
       * @param b second parameter
       * @returns HCF of a and b
       */
      HCF
    };
  }
});

export {
  FadeInOutBehavior,
  init_fadeInOutBehavior,
  PickingCustomization,
  Ray,
  CreatePickingRay,
  CreatePickingRayToRef,
  CreatePickingRayInCameraSpace,
  CreatePickingRayInCameraSpaceToRef,
  PickWithBoundingInfo,
  Pick,
  PickWithRay,
  MultiPick,
  MultiPickWithRay,
  GetForwardRay,
  GetForwardRayToRef,
  AddRayExtensions,
  init_ray_core,
  init_ray,
  PivotTools,
  init_pivotTools,
  PointerDragBehavior,
  init_pointerDragBehavior,
  BaseSixDofDragBehavior,
  init_baseSixDofDragBehavior,
  SixDofDragBehavior,
  init_sixDofDragBehavior,
  SurfaceMagnetismBehavior,
  init_surfaceMagnetismBehavior,
  FollowBehavior,
  init_followBehavior,
  WebXRFeatureName,
  WebXRFeaturesManager,
  init_webXRFeaturesManager,
  HandConstraintZone,
  HandConstraintOrientation,
  HandConstraintVisibility,
  HandConstraintBehavior,
  init_handConstraintBehavior,
  init_engine_dynamicTexture,
  DynamicTexture,
  init_dynamicTexture,
  UtilityLayerRenderer,
  init_utilityLayerRenderer,
  GizmoAnchorPoint,
  GizmoCoordinatesMode,
  Gizmo,
  init_gizmo,
  ClipboardEventTypes,
  ClipboardInfo,
  init_clipboardEvents,
  NodeRenderGraphBlockConnectionPointTypes,
  NodeRenderGraphConnectionPointCompatibilityStates,
  NodeRenderGraphConnectionPointDirection,
  init_nodeRenderGraphTypes,
  NodeRenderGraphConnectionPoint,
  init_nodeRenderGraphBlockConnectionPoint,
  NodeRenderGraphBlock,
  init_nodeRenderGraphBlock,
  FrameGraphPass,
  init_pass,
  FrameGraphCullPass,
  init_cullPass,
  FrameGraphRenderPass,
  init_renderPass,
  FrameGraphTask,
  init_frameGraphTask,
  LayerSceneComponent,
  init_layerSceneComponent,
  Layer,
  init_layer,
  Scalar,
  init_math_scalar
};
//# sourceMappingURL=chunk-6X4GUM5X.js.map
