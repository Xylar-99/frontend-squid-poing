{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/thinTexture.ts", "../../../dev/core/src/Materials/Textures/baseTexture.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<AbstractEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?.shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in AbstractEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Define the display name of the texture, which is used as tree item name of the dedicated node in the inspector\r\n     */\r\n    @serialize()\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public override set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public override get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public override set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public override set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public override wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public override anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public override get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected override set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public override toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | AbstractEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<AbstractEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(_fromContextLost = false): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | AbstractEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index"]
}
