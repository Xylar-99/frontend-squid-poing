import {
  CameraInputTypes,
  CameraInputsManager,
  init_cameraInputsManager
} from "./chunk-UBQI7X5Z.js";
import {
  EventConstants,
  KeyboardEventTypes,
  init_deviceInputEvents,
  init_keyboardEvents
} from "./chunk-J6IZTA6X.js";
import {
  PointerEventTypes,
  init_pointerEvents
} from "./chunk-V2QI3I5N.js";
import {
  Tools,
  init_tools
} from "./chunk-RBASUMGO.js";
import {
  Plane,
  init_math_plane
} from "./chunk-S3M42YLN.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  serialize
} from "./chunk-56URP3F6.js";
import {
  Matrix,
  TmpVectors,
  Vector3,
  init_math_vector
} from "./chunk-3SMC2E6I.js";
import {
  Epsilon,
  init_math_constants
} from "./chunk-LNF52JT4.js";
import {
  Clamp,
  init_math_scalar_functions
} from "./chunk-4MN3UCXJ.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput;
var init_BaseCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_pointerEvents();
    BaseCameraPointersInput = class {
      constructor() {
        this._currentMousePointerIdDown = -1;
        this.buttons = [0, 1, 2];
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        let previousPinchSquaredDistance = 0;
        let previousMultiTouchPanPosition = null;
        this._pointA = null;
        this._pointB = null;
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._pointerInput = (p) => {
          var _a, _b;
          const evt = p.event;
          const isTouch = evt.pointerType === "touch";
          if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
            return;
          }
          const srcElement = evt.target;
          this._altKey = evt.altKey;
          this._ctrlKey = evt.ctrlKey;
          this._metaKey = evt.metaKey;
          this._shiftKey = evt.shiftKey;
          this._buttonsPressed = evt.buttons;
          if (engine.isPointerLock) {
            const offsetX = evt.movementX;
            const offsetY = evt.movementY;
            this.onTouch(null, offsetX, offsetY);
            this._pointA = null;
            this._pointB = null;
          } else if (p.type !== PointerEventTypes.POINTERDOWN && p.type !== PointerEventTypes.POINTERDOUBLETAP && isTouch && ((_a = this._pointA) == null ? void 0 : _a.pointerId) !== evt.pointerId && ((_b = this._pointB) == null ? void 0 : _b.pointerId) !== evt.pointerId) {
            return;
          } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {
            try {
              srcElement == null ? void 0 : srcElement.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (this._pointA === null) {
              this._pointA = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType
              };
            } else if (this._pointB === null) {
              this._pointB = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType
              };
            } else {
              return;
            }
            if (this._currentMousePointerIdDown === -1 && !isTouch) {
              this._currentMousePointerIdDown = evt.pointerId;
            }
            this.onButtonDown(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
              element && element.focus();
            }
          } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
            this.onDoubleTap(evt.pointerType);
          } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {
            try {
              srcElement == null ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (!isTouch) {
              this._pointB = null;
            }
            if (engine._badOS) {
              this._pointA = this._pointB = null;
            } else {
              if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {
                this._pointA = this._pointB;
                this._pointB = null;
              } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {
                this._pointB = null;
              } else {
                this._pointA = this._pointB = null;
              }
            }
            if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
              this.onMultiTouch(
                this._pointA,
                this._pointB,
                previousPinchSquaredDistance,
                0,
                // pinchSquaredDistance
                previousMultiTouchPanPosition,
                null
                // multiTouchPanPosition
              );
              previousPinchSquaredDistance = 0;
              previousMultiTouchPanPosition = null;
            }
            this._currentMousePointerIdDown = -1;
            this.onButtonUp(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          } else if (p.type === PointerEventTypes.POINTERMOVE) {
            if (!noPreventDefault) {
              evt.preventDefault();
            }
            if (this._pointA && this._pointB === null) {
              const offsetX = evt.clientX - this._pointA.x;
              const offsetY = evt.clientY - this._pointA.y;
              this._pointA.x = evt.clientX;
              this._pointA.y = evt.clientY;
              this.onTouch(this._pointA, offsetX, offsetY);
            } else if (this._pointA && this._pointB) {
              const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;
              ed.x = evt.clientX;
              ed.y = evt.clientY;
              const distX = this._pointA.x - this._pointB.x;
              const distY = this._pointA.y - this._pointB.y;
              const pinchSquaredDistance = distX * distX + distY * distY;
              const multiTouchPanPosition = {
                x: (this._pointA.x + this._pointB.x) / 2,
                y: (this._pointA.y + this._pointB.y) / 2,
                pointerId: evt.pointerId,
                type: p.type
              };
              this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
              previousMultiTouchPanPosition = multiTouchPanPosition;
              previousPinchSquaredDistance = pinchSquaredDistance;
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);
        this._onLostFocus = () => {
          this._pointA = this._pointB = null;
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
          this.onLostFocus();
        };
        this._contextMenuBind = (evt) => this.onContextMenu(evt);
        element && element.addEventListener("contextmenu", this._contextMenuBind, false);
        const hostWindow = this.camera.getScene().getEngine().getHostWindow();
        if (hostWindow) {
          Tools.RegisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._onLostFocus) {
          const hostWindow = this.camera.getScene().getEngine().getHostWindow();
          if (hostWindow) {
            Tools.UnregisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
          }
        }
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          if (this._contextMenuBind) {
            const inputElement = this.camera.getScene().getEngine().getInputElement();
            inputElement && inputElement.removeEventListener("contextmenu", this._contextMenuBind);
          }
          this._onLostFocus = null;
        }
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._currentMousePointerIdDown = -1;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "BaseCameraPointersInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "pointers";
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       * Override this method to provide functionality on POINTERDOUBLETAP event.
       * @param type type of event
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onDoubleTap(type) {
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * Override this method to provide functionality.
       * @param point The current position of the pointer
       * @param offsetX The offsetX of the pointer when the event occurred
       * @param offsetY The offsetY of the pointer when the event occurred
       */
      onTouch(point, offsetX, offsetY) {
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * Override this method to provide functionality.
       * @param _pointA First point in the pair
       * @param _pointB Second point in the pair
       * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)
       * @param pinchSquaredDistance Sqr Distance between the points this time
       * @param previousMultiTouchPanPosition Previous center point between the points
       * @param multiTouchPanPosition Current center point between the points
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
      }
      /**
       * Called on JS contextmenu event.
       * Override this method to provide functionality.
       * @param evt the event to be handled
       */
      onContextMenu(evt) {
        evt.preventDefault();
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonDown(_evt) {
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
      }
      /**
       * Called when window becomes inactive.
       * Override this method to provide functionality.
       */
      onLostFocus() {
      }
    };
    __decorate([
      serialize()
    ], BaseCameraPointersInput.prototype, "buttons", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js
var ArcRotateCameraKeyboardMoveInput;
var init_arcRotateCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_tools();
    ArcRotateCameraKeyboardMoveInput = class {
      constructor() {
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.keysReset = [220];
        this.panningSensibility = 50;
        this.zoomingSensibility = 25;
        this.useAltToZoom = true;
        this.angularSpeed = 0.01;
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              this._ctrlPressed = evt.ctrlKey;
              this._altPressed = evt.altKey;
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            } else {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            if (this.keysLeft.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningX -= 1 / this.panningSensibility;
              } else {
                camera.inertialAlphaOffset -= this.angularSpeed;
              }
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningY += 1 / this.panningSensibility;
              } else if (this._altPressed && this.useAltToZoom) {
                camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
              } else {
                camera.inertialBetaOffset -= this.angularSpeed;
              }
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningX += 1 / this.panningSensibility;
              } else {
                camera.inertialAlphaOffset += this.angularSpeed;
              }
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningY -= 1 / this.panningSensibility;
              } else if (this._altPressed && this.useAltToZoom) {
                camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
              } else {
                camera.inertialBetaOffset += this.angularSpeed;
              }
            } else if (this.keysReset.indexOf(keyCode) !== -1) {
              if (camera.useInputToRestoreState) {
                camera.restoreState();
              }
            }
          }
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraKeyboardMoveInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysReset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "panningSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "zoomingSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "useAltToZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "angularSpeed", void 0);
    CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var ffMultiplier, ArcRotateCameraMouseWheelInput;
var init_arcRotateCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_plane();
    init_math_vector();
    init_math_constants();
    init_deviceInputEvents();
    init_math_scalar_functions();
    init_tools();
    ffMultiplier = 40;
    ArcRotateCameraMouseWheelInput = class {
      constructor() {
        this.wheelPrecision = 3;
        this.zoomToMouseLocation = false;
        this.wheelDeltaPercentage = 0;
        this.customComputeDeltaFromMouseWheel = null;
        this._viewOffset = new Vector3(0, 0, 0);
        this._globalOffset = new Vector3(0, 0, 0);
        this._inertialPanning = Vector3.Zero();
      }
      _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {
        let delta = 0;
        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
        if (mouseWheelDelta > 0) {
          delta = wheelDelta / (1 + this.wheelDeltaPercentage);
        } else {
          delta = wheelDelta * (1 + this.wheelDeltaPercentage);
        }
        return delta;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = (p) => {
          if (p.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          const event = p.event;
          let delta = 0;
          const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1;
          const wheelDelta = -(event.deltaY * platformScale);
          if (this.customComputeDeltaFromMouseWheel) {
            delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);
          } else {
            if (this.wheelDeltaPercentage) {
              delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);
              if (delta > 0) {
                let estimatedTargetRadius = this.camera.radius;
                let targetInertia = this.camera.inertialRadiusOffset + delta;
                for (let i = 0; i < 20 && Math.abs(targetInertia) > 1e-3; i++) {
                  estimatedTargetRadius -= targetInertia;
                  targetInertia *= this.camera.inertia;
                }
                estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
                delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
              }
            } else {
              delta = wheelDelta / (this.wheelPrecision * 40);
            }
          }
          if (delta) {
            if (this.zoomToMouseLocation) {
              if (!this._hitPlane) {
                this._updateHitPlane();
              }
              this._zoomToMouse(delta);
            } else {
              this.camera.inertialRadiusOffset += delta;
            }
          }
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
        if (this.zoomToMouseLocation) {
          this._inertialPanning.setAll(0);
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          this._wheel = null;
        }
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (!this.zoomToMouseLocation) {
          return;
        }
        const camera = this.camera;
        const motion = 0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;
        if (motion) {
          this._updateHitPlane();
          camera.target.addInPlace(this._inertialPanning);
          this._inertialPanning.scaleInPlace(camera.inertia);
          this._zeroIfClose(this._inertialPanning);
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraMouseWheelInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "mousewheel";
      }
      _updateHitPlane() {
        const camera = this.camera;
        const direction = camera.target.subtract(camera.position);
        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);
      }
      // Get position on the hit plane
      _getPosition() {
        const camera = this.camera;
        const scene = camera.getScene();
        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);
        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {
          this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);
          camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
          this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);
          ray.origin.addInPlace(this._globalOffset);
        }
        let distance = 0;
        if (this._hitPlane) {
          distance = ray.intersectsPlane(this._hitPlane) ?? 0;
        }
        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));
      }
      _zoomToMouse(delta) {
        const camera = this.camera;
        const inertiaComp = 1 - camera.inertia;
        if (camera.lowerRadiusLimit) {
          const lowerLimit = camera.lowerRadiusLimit ?? 0;
          if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {
            delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;
          }
        }
        if (camera.upperRadiusLimit) {
          const upperLimit = camera.upperRadiusLimit ?? 0;
          if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {
            delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;
          }
        }
        const zoomDistance = delta / inertiaComp;
        const ratio = zoomDistance / camera.radius;
        const vec = this._getPosition();
        const directionToZoomLocation = TmpVectors.Vector3[6];
        vec.subtractToRef(camera.target, directionToZoomLocation);
        directionToZoomLocation.scaleInPlace(ratio);
        directionToZoomLocation.scaleInPlace(inertiaComp);
        this._inertialPanning.addInPlace(directionToZoomLocation);
        camera.inertialRadiusOffset += delta;
      }
      // Sets x y or z of passed in vector to zero if less than Epsilon.
      _zeroIfClose(vec) {
        if (Math.abs(vec.x) < Epsilon) {
          vec.x = 0;
        }
        if (Math.abs(vec.y) < Epsilon) {
          vec.y = 0;
        }
        if (Math.abs(vec.z) < Epsilon) {
          vec.z = 0;
        }
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "zoomToMouseLocation", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput;
var init_arcRotateCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraPointersInput();
    ArcRotateCameraPointersInput = class _ArcRotateCameraPointersInput extends BaseCameraPointersInput {
      constructor() {
        super(...arguments);
        this.buttons = [0, 1, 2];
        this.angularSensibilityX = 1e3;
        this.angularSensibilityY = 1e3;
        this.pinchPrecision = 12;
        this.pinchDeltaPercentage = 0;
        this.useNaturalPinchZoom = false;
        this.pinchZoom = true;
        this.panningSensibility = 1e3;
        this.multiTouchPanning = true;
        this.multiTouchPanAndZoom = true;
        this.pinchInwards = true;
        this._isPanClick = false;
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraPointersInput";
      }
      /**
       * Move camera from multi touch panning positions.
       * @param previousMultiTouchPanPosition
       * @param multiTouchPanPosition
       */
      _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
          const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
          const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
        }
      }
      /**
       * Move camera from pinch zoom distances.
       * @param previousPinchSquaredDistance
       * @param pinchSquaredDistance
       */
      _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
        const radius = this.camera.radius || _ArcRotateCameraPointersInput.MinimumRadiusForPinch;
        if (this.useNaturalPinchZoom) {
          this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
        } else if (this.pinchDeltaPercentage) {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * radius * this.pinchDeltaPercentage;
        } else {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        }
      }
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * @param point current touch point
       * @param offsetX offset on X
       * @param offsetY offset on Y
       */
      onTouch(point, offsetX, offsetY) {
        if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
          this.camera.inertialPanningX += -offsetX / this.panningSensibility;
          this.camera.inertialPanningY += offsetY / this.panningSensibility;
        } else {
          this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
          this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
        }
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       */
      onDoubleTap() {
        if (this.camera.useInputToRestoreState) {
          this.camera.restoreState();
        }
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * @param pointA point A
       * @param pointB point B
       * @param previousPinchSquaredDistance distance between points in previous pinch
       * @param pinchSquaredDistance distance between points in current pinch
       * @param previousMultiTouchPanPosition multi-touch position in previous step
       * @param multiTouchPanPosition multi-touch position in current step
       */
      onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
          return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
          return;
        }
        if (this.multiTouchPanAndZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.multiTouchPanning && this.pinchZoom) {
          this._twoFingerActivityCount++;
          if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {
            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
            this._isPinching = true;
          } else {
            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
          }
        } else if (this.multiTouchPanning) {
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.pinchZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
        }
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * @param evt Defines the event to track
       */
      onButtonDown(evt) {
        this._isPanClick = evt.button === this.camera._panningMouseButton;
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
      /**
       * Called when window becomes inactive.
       */
      onLostFocus() {
        this._isPanClick = false;
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
    };
    ArcRotateCameraPointersInput.MinimumRadiusForPinch = 1e-3;
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "useNaturalPinchZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanning", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
    CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;
  }
});

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager;
var init_arcRotateCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js"() {
    init_arcRotateCameraPointersInput();
    init_arcRotateCameraKeyboardMoveInput();
    init_arcRotateCameraMouseWheelInput();
    init_cameraInputsManager();
    ArcRotateCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new ArcRotateCameraInputsManager.
       * @param camera Defines the camera the inputs belong to
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Add mouse wheel input support to the input manager.
       * @returns the current input manager
       */
      addMouseWheel() {
        this.add(new ArcRotateCameraMouseWheelInput());
        return this;
      }
      /**
       * Add pointers input support to the input manager.
       * @returns the current input manager
       */
      addPointers() {
        this.add(new ArcRotateCameraPointersInput());
        return this;
      }
      /**
       * Add keyboard input support to the input manager.
       * @returns the current input manager
       */
      addKeyboard() {
        this.add(new ArcRotateCameraKeyboardMoveInput());
        return this;
      }
    };
  }
});

export {
  BaseCameraPointersInput,
  init_BaseCameraPointersInput,
  ArcRotateCameraKeyboardMoveInput,
  init_arcRotateCameraKeyboardMoveInput,
  ArcRotateCameraMouseWheelInput,
  init_arcRotateCameraMouseWheelInput,
  ArcRotateCameraPointersInput,
  init_arcRotateCameraPointersInput,
  ArcRotateCameraInputsManager,
  init_arcRotateCameraInputsManager
};
//# sourceMappingURL=chunk-SEEYX54J.js.map
