import {
  init_kernelBlurVaryingDeclaration
} from "./chunk-WME2ESWV.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-CTSQY2GW.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurVertex.js
var name, shader;
var init_kernelBlurVertex = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurVertex.js"() {
    init_shaderStore();
    name = "kernelBlurVertex";
    shader = `vertexOutputs.sampleCoord{X}=vertexOutputs.sampleCenter+uniforms.delta*KERNEL_OFFSET{X};`;
    if (!ShaderStore.IncludesShadersStoreWGSL[name]) {
      ShaderStore.IncludesShadersStoreWGSL[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.vertex.js
var name2, shader2, kernelBlurVertexShaderWGSL;
var init_kernelBlur_vertex = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.vertex.js"() {
    init_shaderStore();
    init_kernelBlurVaryingDeclaration();
    init_kernelBlurVertex();
    name2 = "kernelBlurVertexShader";
    shader2 = `attribute position: vec2f;uniform delta: vec2f;varying sampleCenter: vec2f;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.sampleCenter=(input.position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
    if (!ShaderStore.ShadersStoreWGSL[name2]) {
      ShaderStore.ShadersStoreWGSL[name2] = shader2;
    }
    kernelBlurVertexShaderWGSL = { name: name2, shader: shader2 };
  }
});

export {
  kernelBlurVertexShaderWGSL,
  init_kernelBlur_vertex
};
//# sourceMappingURL=chunk-J6626TTZ.js.map
