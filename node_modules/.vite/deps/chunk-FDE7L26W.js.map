{
  "version": 3,
  "sources": ["../../../dev/core/src/Meshes/instancedMesh.ts"],
  "sourcesContent": ["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport type { IMeshDataOptions } from \"../Meshes/abstractMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Geometry } from \"./geometry\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public override get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public override _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public override _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public override _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public override get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public override set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public override set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public override get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public override set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public override get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public override set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public override get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public override set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * @returns the total number of vertices (integer).\r\n     */\r\n    public override getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public override getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh internal Geometry object\r\n     */\r\n    public get geometry(): Nullable<Geometry> {\r\n        return this._sourceMesh._geometry;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public override isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public override getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    public override copyVerticesData(kind: string, vertexData: { [kind: string]: Float32Array }): void {\r\n        this._sourceMesh.copyVerticesData(kind, vertexData);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (false as default)\r\n     * @param stride defines the vertex stride (optional)\r\n     * @returns the current mesh\r\n     */\r\n    public override setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\r\n     * @returns the source mesh\r\n     */\r\n    public override updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices the source data\r\n     * @param totalVertices defines the total number of vertices referenced by indices (could be null)\r\n     * @returns source mesh\r\n     */\r\n    public override setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns true if data kind is present\r\n     */\r\n    public override isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * @returns an array of indices (IndicesArray).\r\n     */\r\n    public override getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public override get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    public override refreshBoundingInfo(applySkeletonOrOptions: boolean | IMeshDataOptions = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        let options: IMeshDataOptions;\r\n        if (typeof applySkeletonOrOptions === \"object\") {\r\n            options = applySkeletonOrOptions;\r\n        } else {\r\n            options = {\r\n                applySkeleton: applySkeletonOrOptions,\r\n                applyMorph: applyMorph,\r\n            };\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getData(options, null, VertexBuffer.PositionKind), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public override getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public override get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera defines the camera to use to pick the LOD level\r\n     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\r\n     */\r\n    public override getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public override instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        (this.getEngine() as ThinEngine).releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.InstancedMesh\", InstancedMesh);\r\n"],
  "mappings": "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",
  "names": []
}
