{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../dev/core/src/Cameras/freeCamera.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * [true] Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public override checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * [false] Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public override clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public override inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public override detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > AbstractEngine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public override dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.FreeCamera\", FreeCamera);\r\n"],
  "mappings": "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",
  "names": ["_CameraProperty"]
}
