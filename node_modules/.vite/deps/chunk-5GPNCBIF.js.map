{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/shaderMaterial.ts"],
  "sourcesContent": ["import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Effect, IEffectCreationOptions, IShaderPath } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\nimport type { WebGPUEngine } from \"core/Engines/webgpuEngine\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindSceneUniformBuffer,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareDefinesAndAttributesForMorphTargets,\r\n    PushAttributesForInstances,\r\n} from \"./materialHelper.functions\";\r\nimport type { IVector2Like, IVector3Like, IVector4Like } from \"core/Maths/math.like\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * Defines additional code to call to prepare the shader code\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: IShaderPath | string;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: IVector2Like } = {};\r\n    private _vectors3: { [name: string]: IVector3Like } = {};\r\n    private _vectors4: { [name: string]: IVector4Like } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: IShaderPath | string, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: IShaderPath | string) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a texture from the material.\r\n     * @param name Define the name of the texture to remove\r\n     */\r\n    public removeTexture(name: string): void {\r\n        delete this._textures[name];\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: IVector2Like): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: IVector3Like): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: IVector4Like): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public override isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        let fallbacks: Nullable<EffectFallbacks> = null;\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (uniforms.indexOf(\"viewProjection\") !== -1 && uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks = new EffectFallbacks();\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (uniforms.indexOf(\"mBones\") === -1) {\r\n                    uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = defines.indexOf(\"#define UV1\") !== -1;\r\n            const uv2 = defines.indexOf(\"#define UV2\") !== -1;\r\n            const tangent = defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = defines.indexOf(\"#define NORMAL\") !== -1;\r\n            const color = defines.indexOf(\"#define VERTEXCOLOR\") !== -1;\r\n            numInfluencers = PrepareDefinesAndAttributesForMorphTargets(\r\n                manager,\r\n                defines,\r\n                attribs,\r\n                mesh!,\r\n                true, // usePositionMorph\r\n                normal, // useNormalMorph\r\n                tangent, // useTangentMorph\r\n                uv, // useUVMorph\r\n                uv2, // useUV2Morph\r\n                color // useColorMorph\r\n            );\r\n            if (manager.isUsingTextureForTargets) {\r\n                if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetCount\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this.needAlphaTestingForMesh(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        // Fog\r\n        if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            defines.push(\"#define FOG\");\r\n            if (uniforms.indexOf(\"view\") === -1) {\r\n                uniforms.push(\"view\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogInfos\") === -1) {\r\n                uniforms.push(\"vFogInfos\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogColor\") === -1) {\r\n                uniforms.push(\"vFogColor\");\r\n            }\r\n        }\r\n\r\n        // Misc\r\n        if (this._useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n            if (uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\r\n                uniforms.push(\"logarithmicDepthConstant\");\r\n            }\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(this.name, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(undefined, true) : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                    extraInitializationsAsync: this._options.extraInitializationsAsync,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public override bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const effect = effectOverride ?? this.getEffect();\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const uniforms = this._options.uniforms;\r\n        if (uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        if (uniforms.indexOf(\"view\") !== -1) {\r\n            effect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bind(world: Matrix, mesh?: AbstractMesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\r\n                        scene.finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", scene.getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", scene.activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Misc\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\r\n            }\r\n\r\n            // Fog\r\n            if (mesh) {\r\n                BindFogParameters(scene, mesh, effect);\r\n            }\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            const engineWebGPU = scene.getEngine() as WebGPUEngine;\r\n\r\n            // External texture\r\n            const setExternalTexture = engineWebGPU.setExternalTexture;\r\n            if (setExternalTexture) {\r\n                for (name in this._externalTextures) {\r\n                    setExternalTexture.call(engineWebGPU, name, this._externalTextures[name]);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            const setTextureSampler = engineWebGPU.setTextureSampler;\r\n            if (setTextureSampler) {\r\n                for (name in this._textureSamplers) {\r\n                    setTextureSampler.call(engineWebGPU, name, this._textureSamplers[name]);\r\n                }\r\n            }\r\n\r\n            // Storage buffers\r\n            const setStorageBuffer = engineWebGPU.setStorageBuffer;\r\n            if (setStorageBuffer) {\r\n                for (name in this._storageBuffers) {\r\n                    setStorageBuffer.call(engineWebGPU, name, this._storageBuffers[name]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            BindMorphTargetParameters(mesh, effect);\r\n            if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {\r\n                mesh.morphTargetManager._bind(effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public override clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.floatsArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.floatsArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            const v2 = this._vectors2[name];\r\n            serializationObject.vectors2[name] = [v2.x, v2.y];\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            const v3 = this._vectors3[name];\r\n            serializationObject.vectors3[name] = [v3.x, v3.y, v3.z];\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            const v4 = this._vectors4[name];\r\n            serializationObject.vectors4[name] = [v4.x, v4.y, v4.z, v4.w];\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray: Texture[] = [];\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n"],
  "mappings": "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",
  "names": ["drawWrapper"]
}
