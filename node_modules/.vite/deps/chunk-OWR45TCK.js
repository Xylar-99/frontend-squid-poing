import {
  init_shadowMapVertexMetric
} from "./chunk-4FPJJTNC.js";
import {
  init_instancesVertex
} from "./chunk-6NM5PJJG.js";
import {
  init_bakedVertexAnimation,
  init_bakedVertexAnimationDeclaration
} from "./chunk-L6Z2ABCQ.js";
import {
  init_meshUboDeclaration
} from "./chunk-FUK2RYNC.js";
import {
  init_sceneUboDeclaration
} from "./chunk-LJEBA4GM.js";
import {
  init_morphTargetsVertexGlobalDeclaration
} from "./chunk-VFR3XPFG.js";
import {
  init_morphTargetsVertexDeclaration
} from "./chunk-L3ZOTM5U.js";
import {
  init_morphTargetsVertexGlobal
} from "./chunk-F4FU255O.js";
import {
  init_morphTargetsVertex
} from "./chunk-LNOZHWAB.js";
import {
  init_bonesVertex
} from "./chunk-C2N5LSRD.js";
import {
  init_clipPlaneVertex
} from "./chunk-4XQISIIE.js";
import {
  init_bonesDeclaration
} from "./chunk-LB2SJ2E7.js";
import {
  init_clipPlaneVertexDeclaration
} from "./chunk-RDWIQHHP.js";
import {
  init_helperFunctions
} from "./chunk-6ZJTV4QJ.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-CTSQY2GW.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneVertexDeclaration.js
var name, shader;
var init_sceneVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneVertexDeclaration.js"() {
    init_shaderStore();
    name = "sceneVertexDeclaration";
    shader = `uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;
`;
    if (!ShaderStore.IncludesShadersStore[name]) {
      ShaderStore.IncludesShadersStore[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js
var name2, shader2;
var init_meshVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js"() {
    init_shaderStore();
    name2 = "meshVertexDeclaration";
    shader2 = `uniform mat4 world;uniform float visibility;
`;
    if (!ShaderStore.IncludesShadersStore[name2]) {
      ShaderStore.IncludesShadersStore[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js
var name3, shader3;
var init_shadowMapVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js"() {
    init_shaderStore();
    init_sceneVertexDeclaration();
    init_meshVertexDeclaration();
    name3 = "shadowMapVertexDeclaration";
    shader3 = `#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;
    if (!ShaderStore.IncludesShadersStore[name3]) {
      ShaderStore.IncludesShadersStore[name3] = shader3;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js
var name4, shader4;
var init_shadowMapUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    name4 = "shadowMapUboDeclaration";
    shader4 = `layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
    if (!ShaderStore.IncludesShadersStore[name4]) {
      ShaderStore.IncludesShadersStore[name4] = shader4;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexExtraDeclaration.js
var name5, shader5;
var init_shadowMapVertexExtraDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexExtraDeclaration.js"() {
    init_shaderStore();
    name5 = "shadowMapVertexExtraDeclaration";
    shader5 = `#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
    if (!ShaderStore.IncludesShadersStore[name5]) {
      ShaderStore.IncludesShadersStore[name5] = shader5;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js
var name6, shader6;
var init_shadowMapVertexNormalBias = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js"() {
    init_shaderStore();
    name6 = "shadowMapVertexNormalBias";
    shader6 = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;
    if (!ShaderStore.IncludesShadersStore[name6]) {
      ShaderStore.IncludesShadersStore[name6] = shader6;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js
var name7, shader7, shadowMapVertexShader;
var init_shadowMap_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js"() {
    init_shaderStore();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_helperFunctions();
    init_shadowMapVertexDeclaration();
    init_shadowMapUboDeclaration();
    init_shadowMapVertexExtraDeclaration();
    init_clipPlaneVertexDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_shadowMapVertexNormalBias();
    init_shadowMapVertexMetric();
    init_clipPlaneVertex();
    name7 = "shadowMapVertexShader";
    shader7 = `attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;
    if (!ShaderStore.ShadersStore[name7]) {
      ShaderStore.ShadersStore[name7] = shader7;
    }
    shadowMapVertexShader = { name: name7, shader: shader7 };
  }
});

export {
  shadowMapVertexShader,
  init_shadowMap_vertex
};
//# sourceMappingURL=chunk-OWR45TCK.js.map
