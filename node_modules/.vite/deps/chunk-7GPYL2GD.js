import {
  Mesh,
  VertexData,
  init_mesh,
  init_mesh_vertexData
} from "./chunk-SLNQLWMK.js";
import {
  init_compatibilityOptions,
  useOpenGLOrientationForUV
} from "./chunk-N2AH5G42.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-5UL5TUIP.js";
import {
  Tools,
  init_tools
} from "./chunk-RBASUMGO.js";
import {
  Matrix,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4,
  init_math_vector
} from "./chunk-3SMC2E6I.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-LZS7X66T.js";
import {
  Color3,
  Color4,
  init_math_color
} from "./chunk-52D66CJC.js";
import {
  Epsilon,
  init_math_constants
} from "./chunk-LNF52JT4.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width !== void 0 ? options.width : options.size !== void 0 ? options.size : 1;
  const height = options.height !== void 0 ? options.height : options.size !== void 0 ? options.size : 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name, options = {}, scene = null) {
  const plane = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
var PlaneBuilder;
var init_planeBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js"() {
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    PlaneBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreatePlane
    };
    VertexData.CreatePlane = CreatePlaneVertexData;
    Mesh.CreatePlane = (name, size, scene, updatable, sideOrientation) => {
      const options = {
        size,
        width: size,
        height: size,
        sideOrientation,
        updatable
      };
      return CreatePlane(name, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/groundMesh.js
var GroundMesh;
var init_groundMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/groundMesh.js"() {
    init_math_vector();
    init_buffer();
    init_mesh();
    Mesh._GroundMeshParser = (parsedMesh, scene) => {
      return GroundMesh.Parse(parsedMesh, scene);
    };
    GroundMesh = class _GroundMesh extends Mesh {
      constructor(name, scene) {
        super(name, scene);
        this.generateOctree = false;
      }
      /**
       * "GroundMesh"
       * @returns "GroundMesh"
       */
      getClassName() {
        return "GroundMesh";
      }
      /**
       * The minimum of x and y subdivisions
       */
      get subdivisions() {
        return Math.min(this._subdivisionsX, this._subdivisionsY);
      }
      /**
       * X subdivisions
       */
      get subdivisionsX() {
        return this._subdivisionsX;
      }
      /**
       * Y subdivisions
       */
      get subdivisionsY() {
        return this._subdivisionsY;
      }
      /**
       * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes
       * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes
       * to get performance improvements when using an octree.
       * @param chunksCount the number of submeshes the mesh will be divided into
       * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)
       */
      optimize(chunksCount, octreeBlocksSize = 32) {
        this._subdivisionsX = chunksCount;
        this._subdivisionsY = chunksCount;
        this.subdivide(chunksCount);
        const thisAsAny = this;
        if (thisAsAny.createOrUpdateSubmeshesOctree) {
          thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
        }
      }
      /**
       * Returns a height (y) value in the World system :
       * the ground altitude at the coordinates (x, z) expressed in the World system.
       * @param x x coordinate
       * @param z z coordinate
       * @returns the ground y position if (x, z) are outside the ground surface.
       */
      getHeightAtCoordinates(x, z) {
        const world = this.getWorldMatrix();
        const invMat = TmpVectors.Matrix[5];
        world.invertToRef(invMat);
        const tmpVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
          return this.position.y;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
          this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
        Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
        return tmpVect.y;
      }
      /**
       * Returns a normalized vector (Vector3) orthogonal to the ground
       * at the ground coordinates (x, z) expressed in the World system.
       * @param x x coordinate
       * @param z z coordinate
       * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
       */
      getNormalAtCoordinates(x, z) {
        const normal = new Vector3(0, 1, 0);
        this.getNormalAtCoordinatesToRef(x, z, normal);
        return normal;
      }
      /**
       * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
       * at the ground coordinates (x, z) expressed in the World system.
       * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.
       * @param x x coordinate
       * @param z z coordinate
       * @param ref vector to store the result
       * @returns the GroundMesh.
       */
      getNormalAtCoordinatesToRef(x, z, ref) {
        const world = this.getWorldMatrix();
        const tmpMat = TmpVectors.Matrix[5];
        world.invertToRef(tmpMat);
        const tmpVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
          return this;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
          this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
        return this;
      }
      /**
       * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
       * if the ground has been updated.
       * This can be used in the render loop.
       * @returns the GroundMesh.
       */
      updateCoordinateHeights() {
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
        }
        this._computeHeightQuads();
        return this;
      }
      // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
      _getFacetAt(x, z) {
        const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
        const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
        const quad = this._heightQuads[row * this._subdivisionsX + col];
        let facet;
        if (z < quad.slope.x * x + quad.slope.y) {
          facet = quad.facet1;
        } else {
          facet = quad.facet2;
        }
        return facet;
      }
      //  Creates and populates the heightMap array with "facet" elements :
      // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
      // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
      // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
      // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
      // Returns the GroundMesh.
      _initHeightQuads() {
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        this._heightQuads = new Array();
        for (let row = 0; row < subdivisionsY; row++) {
          for (let col = 0; col < subdivisionsX; col++) {
            const quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
            this._heightQuads[row * subdivisionsX + col] = quad;
          }
        }
        return this;
      }
      // Compute each quad element values and update the heightMap array :
      // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
      // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
      // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
      // Returns the GroundMesh.
      _computeHeightQuads() {
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
          return this;
        }
        const v1 = TmpVectors.Vector3[3];
        const v2 = TmpVectors.Vector3[2];
        const v3 = TmpVectors.Vector3[1];
        const v4 = TmpVectors.Vector3[0];
        const v1v2 = TmpVectors.Vector3[4];
        const v1v3 = TmpVectors.Vector3[5];
        const v1v4 = TmpVectors.Vector3[6];
        const norm1 = TmpVectors.Vector3[7];
        const norm2 = TmpVectors.Vector3[8];
        let i = 0;
        let j = 0;
        let k = 0;
        let cd = 0;
        let h = 0;
        let d1 = 0;
        let d2 = 0;
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        for (let row = 0; row < subdivisionsY; row++) {
          for (let col = 0; col < subdivisionsX; col++) {
            i = col * 3;
            j = row * (subdivisionsX + 1) * 3;
            k = (row + 1) * (subdivisionsX + 1) * 3;
            v1.x = positions[j + i];
            v1.y = positions[j + i + 1];
            v1.z = positions[j + i + 2];
            v2.x = positions[j + i + 3];
            v2.y = positions[j + i + 4];
            v2.z = positions[j + i + 5];
            v3.x = positions[k + i];
            v3.y = positions[k + i + 1];
            v3.z = positions[k + i + 2];
            v4.x = positions[k + i + 3];
            v4.y = positions[k + i + 4];
            v4.z = positions[k + i + 5];
            cd = (v4.z - v1.z) / (v4.x - v1.x);
            h = v1.z - cd * v1.x;
            v2.subtractToRef(v1, v1v2);
            v3.subtractToRef(v1, v1v3);
            v4.subtractToRef(v1, v1v4);
            Vector3.CrossToRef(v1v4, v1v3, norm1);
            Vector3.CrossToRef(v1v2, v1v4, norm2);
            norm1.normalize();
            norm2.normalize();
            d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
            d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
            const quad = this._heightQuads[row * subdivisionsX + col];
            quad.slope.copyFromFloats(cd, h);
            quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
            quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
          }
        }
        return this;
      }
      /**
       * Serializes this ground mesh
       * @param serializationObject object to write serialization to
       */
      serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.subdivisionsX = this._subdivisionsX;
        serializationObject.subdivisionsY = this._subdivisionsY;
        serializationObject.minX = this._minX;
        serializationObject.maxX = this._maxX;
        serializationObject.minZ = this._minZ;
        serializationObject.maxZ = this._maxZ;
        serializationObject.width = this._width;
        serializationObject.height = this._height;
      }
      /**
       * Parses a serialized ground mesh
       * @param parsedMesh the serialized mesh
       * @param scene the scene to create the ground mesh in
       * @returns the created ground mesh
       */
      static Parse(parsedMesh, scene) {
        const result = new _GroundMesh(parsedMesh.name, scene);
        result._subdivisionsX = parsedMesh.subdivisionsX || 1;
        result._subdivisionsY = parsedMesh.subdivisionsY || 1;
        result._minX = parsedMesh.minX;
        result._maxX = parsedMesh.maxX;
        result._minZ = parsedMesh.minZ;
        result._maxZ = parsedMesh.maxZ;
        result._width = parsedMesh.width;
        result._height = parsedMesh.height;
        return result;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
function CreateGroundVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const subdivisionsX = (options.subdivisionsX || options.subdivisions || 1) | 0;
  const subdivisionsY = (options.subdivisionsY || options.subdivisions || 1) | 0;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      const position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      const normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTiledGroundVertexData(options) {
  const xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  const zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  const xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  const zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  const subdivisions = options.subdivisions || { w: 1, h: 1 };
  const precision = options.precision || { w: 1, h: 1 };
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  const tileSize = {
    w: (xmax - xmin) / subdivisions.w,
    h: (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    const base = positions.length / 3;
    const rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    const position = Vector3.Zero();
    const normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGroundFromHeightMapVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  let invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    const temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      const heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      let r = options.buffer[pos] / 255;
      let g = options.buffer[pos + 1] / 255;
      let b = options.buffer[pos + 2] / 255;
      const a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      const gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      if (options.heightBuffer) {
        options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      const idx2 = col + 1 + row * (options.subdivisions + 1);
      const idx3 = col + row * (options.subdivisions + 1);
      const idx4 = col + (row + 1) * (options.subdivisions + 1);
      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGround(name, options = {}, scene) {
  const ground = new GroundMesh(name, scene);
  ground._setReady(false);
  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  ground._width = options.width || 1;
  ground._height = options.height || 1;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  const vertexData = CreateGroundVertexData(options);
  vertexData.applyToMesh(ground, options.updatable);
  ground._setReady(true);
  return ground;
}
function CreateTiledGround(name, options, scene = null) {
  const tiledGround = new Mesh(name, scene);
  const vertexData = CreateTiledGroundVertexData(options);
  vertexData.applyToMesh(tiledGround, options.updatable);
  return tiledGround;
}
function CreateGroundFromHeightMap(name, url, options = {}, scene = null) {
  const width = options.width || 10;
  const height = options.height || 10;
  const subdivisions = options.subdivisions || 1 | 0;
  const minHeight = options.minHeight || 0;
  const maxHeight = options.maxHeight || 1;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  const updatable = options.updatable;
  const onReady = options.onReady;
  scene = scene || EngineStore.LastCreatedScene;
  const ground = new GroundMesh(name, scene);
  ground._subdivisionsX = subdivisions;
  ground._subdivisionsY = subdivisions;
  ground._width = width;
  ground._height = height;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  ground._setReady(false);
  let heightBuffer;
  if (options.passHeightBufferInCallback) {
    heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));
  }
  const onBufferLoaded = (buffer, bufferWidth, bufferHeight) => {
    const vertexData = CreateGroundFromHeightMapVertexData({
      width,
      height,
      subdivisions,
      minHeight,
      maxHeight,
      colorFilter: filter,
      buffer,
      bufferWidth,
      bufferHeight,
      alphaFilter,
      heightBuffer
    });
    vertexData.applyToMesh(ground, updatable);
    if (onReady) {
      onReady(ground, heightBuffer);
    }
    ground._setReady(true);
  };
  if (typeof url === "string") {
    const onload = (img) => {
      const bufferWidth = img.width;
      const bufferHeight = img.height;
      if (scene.isDisposed) {
        return;
      }
      const buffer = scene == null ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);
      onBufferLoaded(buffer, bufferWidth, bufferHeight);
    };
    Tools.LoadImage(url, onload, options.onError ? options.onError : () => {
    }, scene.offlineProvider);
  } else {
    onBufferLoaded(url.data, url.width, url.height);
  }
  return ground;
}
var GroundBuilder;
var init_groundBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_groundMesh();
    init_tools();
    init_engineStore();
    init_math_constants();
    init_compatibilityOptions();
    GroundBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateGround,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateGroundFromHeightMap,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTiledGround
    };
    VertexData.CreateGround = CreateGroundVertexData;
    VertexData.CreateTiledGround = CreateTiledGroundVertexData;
    VertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;
    Mesh.CreateGround = (name, width, height, subdivisions, scene, updatable) => {
      const options = {
        width,
        height,
        subdivisions,
        updatable
      };
      return CreateGround(name, options, scene);
    };
    Mesh.CreateTiledGround = (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {
      const options = {
        xmin,
        zmin,
        xmax,
        zmax,
        subdivisions,
        precision,
        updatable
      };
      return CreateTiledGround(name, options, scene);
    };
    Mesh.CreateGroundFromHeightMap = (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {
      const options = {
        width,
        height,
        subdivisions,
        minHeight,
        maxHeight,
        updatable,
        onReady,
        alphaFilter
      };
      return CreateGroundFromHeightMap(name, url, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateSegmentedBoxVertexData(options) {
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const widthSegments = (options.widthSegments || options.segments || 1) | 0;
  const heightSegments = (options.heightSegments || options.segments || 1) | 0;
  const depthSegments = (options.depthSegments || options.segments || 1) | 0;
  const rotationMatrix = new Matrix();
  const translationMatrix = new Matrix();
  const transformMatrix = new Matrix();
  const bottomPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  bottomPlane.transform(transformMatrix);
  const topPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);
  topPlane.transform(transformMatrix);
  const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negXPlane.transform(transformMatrix);
  const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posXPlane.transform(transformMatrix);
  const negZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);
  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negZPlane.transform(transformMatrix);
  const posZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);
  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posZPlane.transform(transformMatrix);
  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);
  return bottomPlane;
}
function CreateBox(name, options = {}, scene = null) {
  const box = new Mesh(name, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var BoxBuilder;
var init_boxBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    init_groundBuilder();
    BoxBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateBox
    };
    VertexData.CreateBox = CreateBoxVertexData;
    Mesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {
      const options = {
        size,
        sideOrientation,
        updatable
      };
      return CreateBox(name, options, scene);
    };
  }
});

export {
  CreatePlaneVertexData,
  CreatePlane,
  PlaneBuilder,
  init_planeBuilder,
  GroundMesh,
  init_groundMesh,
  CreateGroundVertexData,
  CreateTiledGroundVertexData,
  CreateGroundFromHeightMapVertexData,
  CreateGround,
  CreateTiledGround,
  CreateGroundFromHeightMap,
  GroundBuilder,
  init_groundBuilder,
  CreateBoxVertexData,
  CreateSegmentedBoxVertexData,
  CreateBox,
  BoxBuilder,
  init_boxBuilder
};
//# sourceMappingURL=chunk-7GPYL2GD.js.map
