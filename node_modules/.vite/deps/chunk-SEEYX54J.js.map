{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/Inputs/BaseCameraPointersInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts", "../../../dev/core/src/Cameras/arcRotateCameraInputsManager.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    /**\r\n     * Which pointer ID is currently down (only for mouse events, not used for touch events)\r\n     */\r\n    private _currentMousePointerIdDown: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (\r\n                p.type !== PointerEventTypes.POINTERDOWN &&\r\n                p.type !== PointerEventTypes.POINTERDOUBLETAP &&\r\n                isTouch &&\r\n                this._pointA?.pointerId !== evt.pointerId &&\r\n                this._pointB?.pointerId !== evt.pointerId\r\n            ) {\r\n                return; // If we get a non-down event for a touch that we're not tracking, ignore it\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else {\r\n                    return; // We are already tracking two pointers so ignore this one\r\n                }\r\n\r\n                if (this._currentMousePointerIdDown === -1 && !isTouch) {\r\n                    this._currentMousePointerIdDown = evt.pointerId;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentMousePointerIdDown = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = (evt: Event) => this.onContextMenu(evt as PointerEvent);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentMousePointerIdDown = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type type of event\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point The current position of the pointer\r\n     * @param offsetX The offsetX of the pointer when the event occurred\r\n     * @param offsetY The offsetY of the pointer when the event occurred\r\n     */\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the event to be handled\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonDown(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public onButtonUp(_evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\n/**\r\n * Manage the keyboard inputs to control the movement of an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the up action (increase alpha)\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the down action (decrease alpha)\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the left action (increase beta)\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the right action (decrease beta)\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the list of key codes associated with the reset action.\r\n     * Those keys reset the camera to its last stored state (with the method camera.storeState())\r\n     */\r\n    @serialize()\r\n    public keysReset = [220];\r\n\r\n    /**\r\n     * Defines the panning sensibility of the inputs.\r\n     * (How fast is the camera panning)\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 50.0;\r\n\r\n    /**\r\n     * Defines the zooming sensibility of the inputs.\r\n     * (How fast is the camera zooming)\r\n     */\r\n    @serialize()\r\n    public zoomingSensibility: number = 25.0;\r\n\r\n    /**\r\n     * Defines whether maintaining the alt key down switch the movement mode from\r\n     * orientation to zoom.\r\n     */\r\n    @serialize()\r\n    public useAltToZoom: boolean = true;\r\n\r\n    /**\r\n     * Rotation speed of the camera\r\n     */\r\n    @serialize()\r\n    public angularSpeed = 0.01;\r\n\r\n    private _keys = new Array<number>();\r\n    private _ctrlPressed: boolean;\r\n    private _altPressed: boolean;\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // was there a second variable defined?\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    this._ctrlPressed = evt.ctrlKey;\r\n                    this._altPressed = evt.altKey;\r\n\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysReset.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n\r\n                        if (evt.preventDefault) {\r\n                            if (!noPreventDefault) {\r\n                                evt.preventDefault();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX -= 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY += 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset += 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset -= this.angularSpeed;\r\n                    }\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningX += 1 / this.panningSensibility;\r\n                    } else {\r\n                        camera.inertialAlphaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    if (this._ctrlPressed && this.camera._useCtrlForPanning) {\r\n                        camera.inertialPanningY -= 1 / this.panningSensibility;\r\n                    } else if (this._altPressed && this.useAltToZoom) {\r\n                        camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;\r\n                    } else {\r\n                        camera.inertialBetaOffset += this.angularSpeed;\r\n                    }\r\n                } else if (this.keysReset.indexOf(keyCode) !== -1) {\r\n                    if (camera.useInputToRestoreState) {\r\n                        camera.restoreState();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Firefox uses a different scheme to report scroll distances to other\r\n * browsers. Rather than use complicated methods to calculate the exact\r\n * multiple we need to apply, let's just cheat and use a constant.\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n */\r\nconst ffMultiplier = 40;\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public wheelPrecision = 3.0;\r\n\r\n    /**\r\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\r\n     * zooms to the location of the mouse pointer or not.  The default is false.\r\n     */\r\n    @serialize()\r\n    public zoomToMouseLocation = false;\r\n\r\n    /**\r\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\r\n     */\r\n    @serialize()\r\n    public wheelDeltaPercentage = 0;\r\n\r\n    /**\r\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\r\n     */\r\n    public customComputeDeltaFromMouseWheel: Nullable<(wheelDelta: number, input: ArcRotateCameraMouseWheelInput, event: IWheelEvent) => number> = null;\r\n\r\n    private _wheel: Nullable<(p: PointerInfo, s: EventState) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _hitPlane: Nullable<Plane>;\r\n    private _viewOffset: Vector3 = new Vector3(0, 0, 0);\r\n    private _globalOffset: Vector3 = new Vector3(0, 0, 0);\r\n\r\n    protected _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta: number, radius: number) {\r\n        let delta = 0;\r\n        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\r\n        if (mouseWheelDelta > 0) {\r\n            delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\r\n        } else {\r\n            delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._wheel = (p) => {\r\n            //sanity check - this should be a PointerWheel event.\r\n            if (p.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n            const event = <IWheelEvent>p.event;\r\n            let delta = 0;\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            const wheelDelta = -(event.deltaY * platformScale);\r\n\r\n            if (this.customComputeDeltaFromMouseWheel) {\r\n                delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\r\n            } else {\r\n                if (this.wheelDeltaPercentage) {\r\n                    delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\r\n\r\n                    // If zooming in, estimate the target radius and use that to compute the delta for inertia\r\n                    // this will stop multiple scroll events zooming in from adding too much inertia\r\n                    if (delta > 0) {\r\n                        let estimatedTargetRadius = this.camera.radius;\r\n                        let targetInertia = this.camera.inertialRadiusOffset + delta;\r\n                        for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\r\n                            estimatedTargetRadius -= targetInertia;\r\n                            targetInertia *= this.camera.inertia;\r\n                        }\r\n                        estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\r\n                        delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\r\n                    }\r\n                } else {\r\n                    delta = wheelDelta / (this.wheelPrecision * 40);\r\n                }\r\n            }\r\n\r\n            if (delta) {\r\n                if (this.zoomToMouseLocation) {\r\n                    // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\r\n                    // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\r\n                    // the first zoom will be to the center of the screen\r\n                    if (!this._hitPlane) {\r\n                        this._updateHitPlane();\r\n                    }\r\n\r\n                    this._zoomToMouse(delta);\r\n                } else {\r\n                    this.camera.inertialRadiusOffset += delta;\r\n                }\r\n            }\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n\r\n        if (this.zoomToMouseLocation) {\r\n            this._inertialPanning.setAll(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (!this.zoomToMouseLocation) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\r\n        if (motion) {\r\n            // if zooming is still happening as a result of inertia, then we also need to update\r\n            // the hit plane.\r\n            this._updateHitPlane();\r\n\r\n            // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\r\n            // uses a different panningInertia which could cause this panning to get out of sync with\r\n            // the zooming, and for this to work they must be exactly in sync.\r\n            camera.target.addInPlace(this._inertialPanning);\r\n            this._inertialPanning.scaleInPlace(camera.inertia);\r\n            this._zeroIfClose(this._inertialPanning);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    private _updateHitPlane() {\r\n        const camera = this.camera;\r\n        const direction = camera.target.subtract(camera.position);\r\n        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\r\n    }\r\n\r\n    // Get position on the hit plane\r\n    private _getPosition(): Vector3 {\r\n        const camera = this.camera;\r\n        const scene = camera.getScene();\r\n\r\n        // since the _hitPlane is always updated to be orthogonal to the camera position vector\r\n        // we don't have to worry about this ray shooting off to infinity. This ray creates\r\n        // a vector defining where we want to zoom to.\r\n        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\r\n        // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\r\n        // Because the offset is in view space, we need to convert it to world space first\r\n        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\r\n            this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\r\n            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n            this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\r\n            ray.origin.addInPlace(this._globalOffset);\r\n        }\r\n\r\n        let distance = 0;\r\n        if (this._hitPlane) {\r\n            distance = ray.intersectsPlane(this._hitPlane) ?? 0;\r\n        }\r\n\r\n        // not using this ray again, so modifying its vectors here is fine\r\n        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\r\n    }\r\n\r\n    private _inertialPanning: Vector3 = Vector3.Zero();\r\n\r\n    private _zoomToMouse(delta: number) {\r\n        const camera = this.camera;\r\n        const inertiaComp = 1 - camera.inertia;\r\n        if (camera.lowerRadiusLimit) {\r\n            const lowerLimit = camera.lowerRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\r\n                delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n        if (camera.upperRadiusLimit) {\r\n            const upperLimit = camera.upperRadiusLimit ?? 0;\r\n            if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\r\n                delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\r\n            }\r\n        }\r\n\r\n        const zoomDistance = delta / inertiaComp;\r\n        const ratio = zoomDistance / camera.radius;\r\n        const vec = this._getPosition();\r\n\r\n        // Now this vector tells us how much we also need to pan the camera\r\n        // so the targeted mouse location becomes the center of zooming.\r\n\r\n        const directionToZoomLocation = TmpVectors.Vector3[6];\r\n        vec.subtractToRef(camera.target, directionToZoomLocation);\r\n        directionToZoomLocation.scaleInPlace(ratio);\r\n        directionToZoomLocation.scaleInPlace(inertiaComp);\r\n        this._inertialPanning.addInPlace(directionToZoomLocation);\r\n\r\n        camera.inertialRadiusOffset += delta;\r\n    }\r\n\r\n    // Sets x y or z of passed in vector to zero if less than Epsilon.\r\n    private _zeroIfClose(vec: Vector3) {\r\n        if (Math.abs(vec.x) < Epsilon) {\r\n            vec.x = 0;\r\n        }\r\n        if (Math.abs(vec.y) < Epsilon) {\r\n            vec.y = 0;\r\n        }\r\n        if (Math.abs(vec.z) < Epsilon) {\r\n            vec.z = 0;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public override buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    private _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from pinch zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    private _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public override onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public override onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (\r\n                this._isPinching ||\r\n                (this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance)\r\n            ) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n", "import type { ArcRotateCamera } from \"./arcRotateCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { CameraInputsManager } from \"../Cameras/cameraInputsManager\";\r\n\r\n/**\r\n * Default Inputs manager for the ArcRotateCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {\r\n    /**\r\n     * Instantiates a new ArcRotateCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: ArcRotateCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addMouseWheel(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraMouseWheelInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add pointers input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addPointers(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraPointersInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    public addKeyboard(): ArcRotateCameraInputsManager {\r\n        this.add(new ArcRotateCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
