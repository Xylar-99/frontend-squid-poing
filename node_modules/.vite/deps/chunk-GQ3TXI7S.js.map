{
  "version": 3,
  "sources": ["../../../dev/core/src/Collisions/intersectionInfo.ts", "../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts", "../../../dev/core/src/Meshes/subMesh.ts", "../../../dev/core/src/Materials/materialStencilState.ts", "../../../dev/core/src/Materials/material.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class IntersectionInfo {\r\n    public faceId = 0;\r\n    public subMeshId = 0;\r\n\r\n    constructor(\r\n        public bu: Nullable<number>,\r\n        public bv: Nullable<number>,\r\n        public distance: number\r\n    ) {}\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in local space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in world space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true, immediate = false): void {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose(immediate);\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (this._getDrawWrapper()?.effect ?? null);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId, true, immediate);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose(immediate);\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial && this._mesh.getScene()._hasDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: AbstractEngine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;\r\n            const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;\r\n            const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);\r\n\r\n            let offset = 0;\r\n            if (indices.length === 0) {\r\n                // Unindexed mesh\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = index;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index;\r\n                }\r\n            } else {\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = indices[index];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index];\r\n                }\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     * @param immediate If true, the effect will be disposed immediately (false by default)\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache(undefined, immediate);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class that holds the different stencil states of a material\r\n * Usage example: https://playground.babylonjs.com/#CW5PRI#10\r\n */\r\nexport class MaterialStencilState implements IStencilState {\r\n    /**\r\n     * Creates a material stencil state instance\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets all the stencil states to default values\r\n     */\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = Constants.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = Constants.KEEP;\r\n        this.opDepthFail = Constants.KEEP;\r\n        this.opStencilDepthPass = Constants.REPLACE;\r\n    }\r\n\r\n    private _func: number;\r\n    /**\r\n     * Gets or sets the stencil function\r\n     */\r\n    @serialize()\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        this._func = value;\r\n    }\r\n\r\n    private _funcRef: number;\r\n    /**\r\n     * Gets or sets the stencil function reference\r\n     */\r\n    @serialize()\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        this._funcRef = value;\r\n    }\r\n\r\n    private _funcMask: number;\r\n    /**\r\n     * Gets or sets the stencil function mask\r\n     */\r\n    @serialize()\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        this._funcMask = value;\r\n    }\r\n\r\n    private _opStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil test fails\r\n     */\r\n    @serialize()\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        this._opStencilFail = value;\r\n    }\r\n\r\n    private _opDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the depth test fails\r\n     */\r\n    @serialize()\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        this._opDepthFail = value;\r\n    }\r\n\r\n    private _opStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        this._opStencilDepthPass = value;\r\n    }\r\n\r\n    private _mask: number;\r\n    /**\r\n     * Gets or sets the stencil mask\r\n     */\r\n    @serialize()\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        this._mask = value;\r\n    }\r\n\r\n    private _enabled: boolean;\r\n    /**\r\n     * Enables or disables the stencil test\r\n     */\r\n    @serialize()\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name, useful for serialization or dynamic coding.\r\n     * @returns \"MaterialStencilState\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialStencilState\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param stencilState defines stencil state where to copy the info\r\n     */\r\n    public copyTo(stencilState: MaterialStencilState): void {\r\n        SerializationHelper.Clone(() => stencilState, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this stencil configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a stencil state configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty image processing flag value\r\n     */\r\n    public static readonly ImageProcessingDirtyFlag = Constants.MATERIAL_ImageProcessingDirtyFlag;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _forceGLSL = false;\r\n\r\n    /** @internal */\r\n    public get _supportGlowLayer() {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _glowModeEnabled(value: boolean) {\r\n        // Do nothing here\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: Nullable<number> = null;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    protected _useLogarithmicDepth: boolean;\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        if (value && !fragmentDepthSupported) {\r\n            Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\r\n        }\r\n\r\n        this._useLogarithmicDepth = value && fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    public _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean, forceGLSL = false) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n        this._forceGLSL = forceGLSL;\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        this._createUniformBuffer();\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createUniformBuffer() {\r\n        const engine = this.getScene().getEngine();\r\n\r\n        this._uniformBuffer?.dispose();\r\n\r\n        if (engine.isWebGPU && !this._forceGLSL) {\r\n            // Switch main UBO to non UBO to connect to leftovers UBO in webgpu\r\n            this._uniformBuffer = new UniformBuffer(engine, undefined, undefined, this.name, true);\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        } else {\r\n            this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, this.name);\r\n        }\r\n\r\n        this._uniformBufferLayoutBuilt = false;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getEffectiveOrientation(mesh: Mesh): number {\r\n        return this.sideOrientation !== null ? this.sideOrientation : mesh.sideOrientation;\r\n    }\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    protected get _hasTransparencyMode(): boolean {\r\n        return this._transparencyMode != null;\r\n    }\r\n\r\n    protected get _transparencyModeIsBlend(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHABLEND || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    protected get _transparencyModeIsTest(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHATEST || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     * @deprecated Please use needAlphaBlendingForMesh instead\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     * @deprecated Please use needAlphaTestingForMesh instead\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha testing should be turned on for the mesh\r\n     */\r\n    public needAlphaTestingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        drawWrapper._wasPreviouslyReady = false;\r\n                        drawWrapper._wasPreviouslyUsingInstances = null;\r\n                        drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        drawWrapper._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect defines the effect used to bind the material\r\n     * @param _subMesh defines the subMesh that the material has been bound for\r\n     */\r\n    protected _afterBind(mesh?: AbstractMesh, effect: Nullable<Effect> = null, _subMesh?: SubMesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        this._scene.getSceneUniformBuffer().unbindEffect();\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name);\r\n                if (targetPlugin) {\r\n                    plugin.copyTo(targetPlugin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result: AbstractMesh[] = [];\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.ImageProcessingDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._ImageProcessingDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        const scene = this.getScene();\r\n        if (scene.blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = scene.meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                const material = subMesh.getMaterial() || (scene._hasDefaultMaterial ? scene.defaultMaterial : null);\r\n                if (material !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._PrePassDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param _forceDisposeEffect kept for backward compat. We reference count the effect now.\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(_forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    private _disposeMeshResources(mesh: AbstractMesh | undefined) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        const materialForRenderPass = mesh._internalAbstractMeshDataInfo._materialForRenderPass;\r\n        if (this._storeEffectOnSubMeshes) {\r\n            if (mesh.subMeshes && materialForRenderPass) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    const drawWrappers = subMesh._drawWrappers;\r\n                    for (let renderPassIndex = 0; renderPassIndex < drawWrappers.length; renderPassIndex++) {\r\n                        const effect = drawWrappers[renderPassIndex]?.effect;\r\n                        if (!effect) {\r\n                            continue;\r\n                        }\r\n                        const material = materialForRenderPass[renderPassIndex];\r\n                        if (material === this) {\r\n                            geometry?._releaseVertexArrayObject(effect);\r\n                            subMesh._removeDrawWrapper(renderPassIndex, true, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            geometry?._releaseVertexArrayObject(this._drawWrapper.effect);\r\n        }\r\n\r\n        if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n            mesh.material = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                if (!plugin.doNotSerialize) {\r\n                    serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _ParsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
