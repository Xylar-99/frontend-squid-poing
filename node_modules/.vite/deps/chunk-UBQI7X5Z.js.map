{
  "version": 3,
  "sources": ["../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../dev/core/src/Cameras/targetCamera.ts"],
  "sourcesContent": ["import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    @serialize()\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    @serialize()\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const worldForward = TmpVectors.Vector3[0];\r\n        const localForward = TmpVectors.Vector3[1];\r\n        localForward.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n        this.getDirectionToRef(localForward, worldForward);\r\n        worldForward.scaleInPlace(distance);\r\n        return this.globalPosition.add(worldForward);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
