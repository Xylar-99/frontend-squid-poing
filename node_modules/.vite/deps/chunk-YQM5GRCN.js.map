{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/abstractSound.ts", "../../../dev/core/src/AudioV2/audioUtils.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractSoundInstance.ts"],
  "sourcesContent": ["import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractNamedAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _AbstractAudioSubGraph } from \"./subNodes/abstractAudioSubGraph\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\nimport { _GetVolumeAudioProperty, _GetVolumeAudioSubNode } from \"./subNodes/volumeAudioSubNode\";\nimport type { AbstractAudioAnalyzer, IAudioAnalyzerOptions } from \"./subProperties/abstractAudioAnalyzer\";\nimport type { AbstractSpatialAudio, ISpatialAudioOptions } from \"./subProperties/abstractSpatialAudio\";\nimport type { AbstractStereoAudio, IStereoAudioOptions } from \"./subProperties/abstractStereoAudio\";\nimport { _AudioAnalyzer } from \"./subProperties/audioAnalyzer\";\n\n/** @internal */\nexport interface IAbstractSoundOptionsBase {\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    autoplay: boolean;\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    maxInstances: number;\n}\n\n/** @internal */\nexport interface IAbstractSoundPlayOptionsBase {\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    loop: boolean;\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    startOffset: number;\n}\n\n/**\n * Options for creating a sound.\n */\nexport interface IAbstractSoundOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptions, IAudioAnalyzerOptions, ISpatialAudioOptions, IStereoAudioOptions {\n    /**\n     * The output bus for the sound. Defaults to `null`.\n     * - If not set or `null`, the sound is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n}\n\n/**\n * Options for playing a sound.\n */\nexport interface IAbstractSoundPlayOptions extends IAbstractSoundPlayOptionsBase, IVolumeAudioOptions {}\n\n/**\n * Options stored in a sound.\n * @internal\n */\nexport interface IAbstractSoundStoredOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptionsBase {}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSound extends AbstractNamedAudioNode {\n    private _analyzer: Nullable<AbstractAudioAnalyzer> = null;\n    private _newestInstance: Nullable<_AbstractSoundInstance> = null;\n    private _outBus: Nullable<PrimaryAudioBus> = null;\n    private _privateInstances = new Set<_AbstractSoundInstance>();\n    private _state: SoundState = SoundState.Stopped;\n\n    protected _instances: ReadonlySet<_AbstractSoundInstance> = this._privateInstances;\n    protected abstract readonly _options: IAbstractSoundStoredOptions;\n    protected abstract _subGraph: _AbstractAudioSubGraph;\n\n    /**\n     * Observable for when the sound stops playing.\n     */\n    public readonly onEndedObservable = new Observable<AbstractSound>();\n\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine, AudioNodeType.HAS_INPUTS_AND_OUTPUTS); // Inputs are for instances.\n    }\n\n    /**\n     * The analyzer features of the sound.\n     */\n    public get analyzer(): AbstractAudioAnalyzer {\n        return this._analyzer ?? (this._analyzer = new _AudioAnalyzer(this._subGraph));\n    }\n\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    public get autoplay(): boolean {\n        return this._options.autoplay;\n    }\n\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    public get currentTime(): number {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n\n    public set currentTime(value: number) {\n        this.startOffset = value;\n\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    public get loop(): boolean {\n        return this._options.loop;\n    }\n\n    public set loop(value: boolean) {\n        this._options.loop = value;\n    }\n\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    public get maxInstances(): number {\n        return this._options.maxInstances;\n    }\n\n    public set maxInstances(value: number) {\n        this._options.maxInstances = value;\n    }\n\n    /**\n     * The output bus for the sound. Defaults to `null`.\n     * - If not set or `null`, the sound is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    public get outBus(): Nullable<PrimaryAudioBus> {\n        return this._outBus;\n    }\n\n    public set outBus(outBus: Nullable<PrimaryAudioBus>) {\n        if (this._outBus === outBus) {\n            return;\n        }\n\n        if (this._outBus) {\n            this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n            if (!this._disconnect(this._outBus)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n\n        this._outBus = outBus;\n\n        if (this._outBus) {\n            this._outBus.onDisposeObservable.add(this._onOutBusDisposed);\n            if (!this._connect(this._outBus)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n    }\n\n    /**\n     * The spatial features of the sound.\n     */\n    public abstract spatial: AbstractSpatialAudio;\n\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    public get startOffset(): number {\n        return this._options.startOffset;\n    }\n\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /**\n     * The state of the sound.\n     */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /**\n     * The stereo features of the sound.\n     */\n    public abstract stereo: AbstractStereoAudio;\n\n    /**\n     * The output volume of the sound.\n     */\n    public get volume(): number {\n        return _GetVolumeAudioProperty(this._subGraph, \"volume\");\n    }\n\n    public set volume(value: number) {\n        // The volume subnode is created on initialization and should always exist.\n        const node = _GetVolumeAudioSubNode(this._subGraph);\n        if (!node) {\n            throw new Error(\"No volume subnode\");\n        }\n\n        node.volume = value;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._analyzer?.dispose();\n        this._analyzer = null;\n\n        this._newestInstance = null;\n        this._outBus = null;\n\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public abstract play(options?: Partial<IAbstractSoundPlayOptions>): void;\n\n    /**\n     * Pauses the sound.\n     */\n    public pause(): void {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n\n        this._state = SoundState.Paused;\n    }\n\n    /**\n     * Resumes the sound.\n     */\n    public resume(): void {\n        if (this._state !== SoundState.Paused) {\n            return;\n        }\n\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n\n        this._state = SoundState.Started;\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     */\n    public abstract stop(): void;\n\n    protected _beforePlay(instance: _AbstractSoundInstance): void {\n        if (this.state === SoundState.Paused && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n\n    protected _afterPlay(instance: _AbstractSoundInstance): void {\n        this._state = instance.state;\n    }\n\n    protected _getNewestInstance(): Nullable<_AbstractSoundInstance> {\n        if (this._instances.size === 0) {\n            return null;\n        }\n\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n\n        return this._newestInstance;\n    }\n\n    protected _setState(state: SoundState): void {\n        this._state = state;\n    }\n\n    protected abstract _createInstance(): _AbstractSoundInstance;\n\n    protected _stopExcessInstances(): void {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === SoundState.Started).length - this.maxInstances;\n            const it = this._instances.values();\n\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n\n    private _onInstanceEnded: (instance: _AbstractSoundInstance) => void = (instance) => {\n        if (this._newestInstance === instance) {\n            this._newestInstance = null;\n        }\n\n        this._privateInstances.delete(instance);\n\n        if (this._instances.size === 0) {\n            this._state = SoundState.Stopped;\n            this.onEndedObservable.notifyObservers(this);\n        }\n    };\n\n    private _onOutBusDisposed = () => {\n        this.outBus = null;\n    };\n}\n", "export const _FileExtensionRegex = new RegExp(\"\\\\.(\\\\w{3,4})($|\\\\?)\");\n\n/** @internal */\nexport function _CleanUrl(url: string) {\n    return url.replace(/#/gm, \"%23\");\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { AbstractSound, IAbstractSoundPlayOptions, IAbstractSoundPlayOptionsBase } from \"./abstractSound\";\n\n/**\n * Options for creating a sound instance.\n * @internal\n * */\nexport interface IAbstractSoundInstanceOptions extends IAbstractSoundPlayOptionsBase {}\n\n/** @internal */\nexport abstract class _AbstractSoundInstance extends AbstractAudioNode {\n    protected _sound: AbstractSound;\n    protected _state: SoundState = SoundState.Stopped;\n\n    /** Observable triggered when the sound instance's playback ends */\n    public readonly onEndedObservable = new Observable<_AbstractSoundInstance>();\n\n    /** Observable triggered if the sound instance encounters an error and can not be played */\n    public readonly onErrorObservable = new Observable<any>();\n\n    /** Observable triggered when the sound instance's state changes */\n    public readonly onStateChangedObservable = new Observable<_AbstractSoundInstance>();\n\n    protected abstract readonly _options: IAbstractSoundInstanceOptions;\n\n    protected constructor(sound: AbstractSound) {\n        super(sound.engine, AudioNodeType.HAS_OUTPUTS);\n\n        this._sound = sound;\n    }\n\n    public abstract currentTime: number;\n\n    public abstract readonly startTime: number;\n\n    /** The playback state of the sound instance */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n\n    public abstract play(options: Partial<IAbstractSoundPlayOptions>): void;\n    public abstract pause(): void;\n    public abstract resume(): void;\n    public abstract stop(): void;\n\n    protected _setState(value: SoundState) {\n        if (this._state === value) {\n            return;\n        }\n\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA,IAiEsB;AAjEtB;;;AAGA;AAMA;AAIA;AAoDM,IAAgB,gBAAhB,cAAsC,uBAAsB;MAgB9D,YAAsB,MAAc,QAAqB;AACrD;UAAM;UAAM;UAAM;;QAAA;AAhBd,aAAA,YAA6C;AAC7C,aAAA,kBAAoD;AACpD,aAAA,UAAqC;AACrC,aAAA,oBAAoB,oBAAI,IAAG;AAC3B,aAAA,SAAM;AAEJ,aAAA,aAAkD,KAAK;AAOjD,aAAA,oBAAoB,IAAI,WAAU;AAkP1C,aAAA,mBAA+D,CAAC,aAAY;AAChF,cAAI,KAAK,oBAAoB,UAAU;AACnC,iBAAK,kBAAkB;UAC3B;AAEA,eAAK,kBAAkB,OAAO,QAAQ;AAEtC,cAAI,KAAK,WAAW,SAAS,GAAG;AAC5B,iBAAK,SAAM;AACX,iBAAK,kBAAkB,gBAAgB,IAAI;UAC/C;QACJ;AAEQ,aAAA,oBAAoB,MAAK;AAC7B,eAAK,SAAS;QAClB;MA7PA;;;;MAKA,IAAW,WAAQ;AACf,eAAO,KAAK,cAAc,KAAK,YAAY,IAAI,eAAe,KAAK,SAAS;MAChF;;;;MAKA,IAAW,WAAQ;AACf,eAAO,KAAK,SAAS;MACzB;;;;MAKA,IAAW,cAAW;AAClB,cAAM,WAAW,KAAK,mBAAkB;AACxC,eAAO,WAAW,SAAS,cAAc;MAC7C;MAEA,IAAW,YAAY,OAAa;AAChC,aAAK,cAAc;AAEnB,cAAM,WAAW,KAAK,mBAAkB;AACxC,YAAI,UAAU;AACV,mBAAS,cAAc;QAC3B;MACJ;;;;MAKA,IAAW,OAAI;AACX,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,KAAK,OAAc;AAC1B,aAAK,SAAS,OAAO;MACzB;;;;MAKA,IAAW,eAAY;AACnB,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,aAAa,OAAa;AACjC,aAAK,SAAS,eAAe;MACjC;;;;;;MAOA,IAAW,SAAM;AACb,eAAO,KAAK;MAChB;MAEA,IAAW,OAAO,QAAiC;AAC/C,YAAI,KAAK,YAAY,QAAQ;AACzB;QACJ;AAEA,YAAI,KAAK,SAAS;AACd,eAAK,QAAQ,oBAAoB,eAAe,KAAK,iBAAiB;AACtE,cAAI,CAAC,KAAK,YAAY,KAAK,OAAO,GAAG;AACjC,kBAAM,IAAI,MAAM,mBAAmB;UACvC;QACJ;AAEA,aAAK,UAAU;AAEf,YAAI,KAAK,SAAS;AACd,eAAK,QAAQ,oBAAoB,IAAI,KAAK,iBAAiB;AAC3D,cAAI,CAAC,KAAK,SAAS,KAAK,OAAO,GAAG;AAC9B,kBAAM,IAAI,MAAM,gBAAgB;UACpC;QACJ;MACJ;;;;MAUA,IAAW,cAAW;AAClB,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,YAAY,OAAa;AAChC,aAAK,SAAS,cAAc;MAChC;;;;MAKA,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;;;MAUA,IAAW,SAAM;AACb,eAAO,wBAAwB,KAAK,WAAW,QAAQ;MAC3D;MAEA,IAAW,OAAO,OAAa;AAE3B,cAAM,OAAO,uBAAuB,KAAK,SAAS;AAClD,YAAI,CAAC,MAAM;AACP,gBAAM,IAAI,MAAM,mBAAmB;QACvC;AAEA,aAAK,SAAS;MAClB;;;;MAKgB,UAAO;AAzN3B;AA0NQ,cAAM,QAAO;AAEb,aAAK,KAAI;AAET,mBAAK,cAAL,mBAAgB;AAChB,aAAK,YAAY;AAEjB,aAAK,kBAAkB;AACvB,aAAK,UAAU;AAEf,aAAK,kBAAkB,MAAK;AAC5B,aAAK,kBAAkB,MAAK;MAChC;;;;MAYO,QAAK;AACR,cAAM,KAAK,KAAK,WAAW,OAAM;AACjC,iBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,eAAK,MAAM,MAAK;QACpB;AAEA,aAAK,SAAM;MACf;;;;MAKO,SAAM;AACT,YAAI,KAAK,WAAM,GAAwB;AACnC;QACJ;AAEA,cAAM,KAAK,KAAK,WAAW,OAAM;AACjC,iBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,eAAK,MAAM,OAAM;QACrB;AAEA,aAAK,SAAM;MACf;MAQU,YAAY,UAAgC;AAClD,YAAI,KAAK,UAAK,KAA0B,KAAK,WAAW,OAAO,GAAG;AAC9D,eAAK,OAAM;AACX;QACJ;AAEA,iBAAS,kBAAkB,QAAQ,KAAK,gBAAgB;AACxD,aAAK,kBAAkB,IAAI,QAAQ;AACnC,aAAK,kBAAkB;MAC3B;MAEU,WAAW,UAAgC;AACjD,aAAK,SAAS,SAAS;MAC3B;MAEU,qBAAkB;AACxB,YAAI,KAAK,WAAW,SAAS,GAAG;AAC5B,iBAAO;QACX;AAEA,YAAI,CAAC,KAAK,iBAAiB;AACvB,gBAAM,KAAK,KAAK,WAAW,OAAM;AACjC,mBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,iBAAK,kBAAkB,KAAK;UAChC;QACJ;AAEA,eAAO,KAAK;MAChB;MAEU,UAAU,OAAiB;AACjC,aAAK,SAAS;MAClB;MAIU,uBAAoB;AAC1B,YAAI,KAAK,eAAe,UAAU;AAC9B,gBAAM,0BAA0B,MAAM,KAAK,KAAK,UAAU,EAAE;YAAO,CAAC,aAAa,SAAS,UAAK;;UAAuB,EAAE,SAAS,KAAK;AACtI,gBAAM,KAAK,KAAK,WAAW,OAAM;AAEjC,mBAAS,IAAI,GAAG,IAAI,yBAAyB,KAAK;AAC9C,kBAAM,WAAW,GAAG,KAAI,EAAG;AAC3B,qBAAS,KAAI;UACjB;QACJ;MACJ;;;;;;AC5TE,SAAU,UAAU,KAAW;AACjC,SAAO,IAAI,QAAQ,OAAO,KAAK;AACnC;AALA,IAAa;AAAb;;AAAO,IAAM,sBAAsB,IAAI,OAAO,sBAAsB;;;;;ACApE,IAYsB;AAZtB;;;AAEA;AAUM,IAAgB,yBAAhB,cAA+C,kBAAiB;MAelE,YAAsB,OAAoB;AACtC;UAAM,MAAM;UAAM;;QAAA;AAdZ,aAAA,SAAM;AAGA,aAAA,oBAAoB,IAAI,WAAU;AAGlC,aAAA,oBAAoB,IAAI,WAAU;AAGlC,aAAA,2BAA2B,IAAI,WAAU;AAOrD,aAAK,SAAS;MAClB;;MAOA,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;MAGgB,UAAO;AACnB,cAAM,QAAO;AACb,aAAK,KAAI;AACT,aAAK,kBAAkB,MAAK;AAC5B,aAAK,yBAAyB,MAAK;MACvC;MAOU,UAAU,OAAiB;AACjC,YAAI,KAAK,WAAW,OAAO;AACvB;QACJ;AAEA,aAAK,SAAS;AACd,aAAK,yBAAyB,gBAAgB,IAAI;MACtD;;;;",
  "names": []
}
