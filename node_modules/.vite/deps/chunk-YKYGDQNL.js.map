{
  "version": 3,
  "sources": ["../../../dev/core/src/Animations/runtimeAnimation.ts", "../../../dev/core/src/Animations/animatable.core.ts", "../../../dev/core/src/Animations/animatable.ts", "../../../dev/core/src/Animations/animationGroup.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport {\r\n    Animation,\r\n    _staticOffsetValueColor3,\r\n    _staticOffsetValueColor4,\r\n    _staticOffsetValueQuaternion,\r\n    _staticOffsetValueSize,\r\n    _staticOffsetValueVector2,\r\n    _staticOffsetValueVector3,\r\n} from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    private _yoyoDirection: number = 1;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target;\r\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\r\n                const name = targetPropertyPath[index];\r\n                property = property[name];\r\n                if (property === undefined) {\r\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\r\n                }\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n\r\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\r\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n        const target = runtimeAnimation.target;\r\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n        if (!target._lateAnimationHolders) {\r\n            target._lateAnimationHolders = {};\r\n        }\r\n\r\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n                totalWeight: 0,\r\n                totalAdditiveWeight: 0,\r\n                animations: [],\r\n                additiveAnimations: [],\r\n                originalValue: originalValue,\r\n            };\r\n        }\r\n\r\n        if (runtimeAnimation.isAdditive) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n        } else {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\r\n                if (this._currentValue.addToRef) {\r\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\r\n                } else {\r\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\r\n                }\r\n            } else {\r\n                destination[this._targetPath] = this._currentValue;\r\n            }\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\r\n     */\r\n    public goToFrame(frame: number, weight = -1): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, weight);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const frameRange = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n        let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n        let highLimitValue = 0;\r\n\r\n        // Apply the yoyo function if required\r\n        let yoyoLoop = false;\r\n        const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\r\n        if (yoyoMode) {\r\n            const position = (absoluteFrame - from) / frameRange;\r\n\r\n            // Apply the yoyo curve\r\n            const sin = Math.sin(position * Math.PI);\r\n            const yoyoPosition = Math.abs(sin);\r\n\r\n            // Map the yoyo position back to the range\r\n            absoluteFrame = yoyoPosition * frameRange + from;\r\n\r\n            const direction = sin >= 0 ? 1 : -1;\r\n            if (this._yoyoDirection !== direction) {\r\n                yoyoLoop = true;\r\n            }\r\n\r\n            this._yoyoDirection = direction;\r\n        }\r\n\r\n        this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n        this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n        if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\r\n            // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            const keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                const fromValue = animation._interpolate(from, this._animationState);\r\n                const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    offsetValue = _staticOffsetValueColor4;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + frameRange * hostNormalizedFrame;\r\n        } else {\r\n            if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n            } else {\r\n                currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n            }\r\n        }\r\n\r\n        const events = this._events;\r\n\r\n        // Reset event/state if looping\r\n        if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset event, the animation is looping\r\n                    events[index].isDone = false;\r\n                }\r\n            }\r\n\r\n            this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Animation } from \"./animation\";\r\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _previousWeight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** [0] defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** [100] defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** [false] defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** [false] defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false, skipOnAnimationEnd = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    if (!skipOnAnimationEnd) {\r\n                        this._raiseOnAnimationEnd();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                if (!skipOnAnimationEnd) {\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (this._weight === 0 && this._previousWeight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        this._previousWeight = this._weight;\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForMatrices(holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForQuaternions(\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindings(scene: Scene): void {\r\n    if (!scene._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\r\n        const target = scene._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    const originalAnimationIsLoopRelativeFromCurrent =\r\n                        originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\r\n                        } else if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            if (finalValue.addToRef) {\r\n                                finalValue.addToRef(originalValue, finalValue);\r\n                            } else {\r\n                                finalValue += originalValue;\r\n                            }\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    scene._registeredForLateAnimationBindings.reset();\r\n}\r\n\r\n/** @internal */\r\nexport function RegisterTargetForLateAnimationBinding(scene: Scene, runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize all the inter dependecies between the animations and Scene and Bone\r\n * @param sceneClass defines the scene prototype to use\r\n * @param boneClass defines the bone prototype to use\r\n */\r\nexport function AddAnimationExtensions(sceneClass: typeof Scene, boneClass: typeof Bone): void {\r\n    if (boneClass) {\r\n        boneClass.prototype.copyAnimationRange = function (\r\n            source: Bone,\r\n            rangeName: string,\r\n            frameOffset: number,\r\n            rescaleAsRequired = false,\r\n            skelDimensionsRatio: Nullable<Vector3> = null\r\n        ): boolean {\r\n            // all animation may be coming from a library skeleton, so may need to create animation\r\n            if (this.animations.length === 0) {\r\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n                this.animations[0].setKeys([]);\r\n            }\r\n\r\n            // get animation info / verify there is such a range from the source bone\r\n            const sourceRange = source.animations[0].getRange(rangeName);\r\n            if (!sourceRange) {\r\n                return false;\r\n            }\r\n            const from = sourceRange.from;\r\n            const to = sourceRange.to;\r\n            const sourceKeys = source.animations[0].getKeys();\r\n\r\n            // rescaling prep\r\n            const sourceBoneLength = source.length;\r\n            const sourceParent = source.getParent();\r\n            const parent = this.getParent();\r\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n            const dimensionsScalingReqd =\r\n                rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n            const destKeys = this.animations[0].getKeys();\r\n\r\n            // loop vars declaration\r\n            let orig: { frame: number; value: Matrix };\r\n            let origTranslation: Vector3;\r\n            let mat: Matrix;\r\n\r\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n                orig = sourceKeys[key];\r\n                if (orig.frame >= from && orig.frame <= to) {\r\n                    if (rescaleAsRequired) {\r\n                        mat = orig.value.clone();\r\n\r\n                        // scale based on parent ratio, when bone has parent\r\n                        if (parentScalingReqd) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                            // use original when root bone, and no data for skelDimensionsRatio\r\n                        } else {\r\n                            mat = orig.value;\r\n                        }\r\n                    } else {\r\n                        mat = orig.value;\r\n                    }\r\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n                }\r\n            }\r\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n            return true;\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    sceneClass.prototype._animate = function (customDeltaTime?: number): void {\r\n        if (!this.animationsEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Getting time\r\n        const now = PrecisionDate.Now;\r\n        if (!this._animationTimeLast) {\r\n            if (this._pendingData.length > 0) {\r\n                return;\r\n            }\r\n            this._animationTimeLast = now;\r\n        }\r\n\r\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n        this._animationTimeLast = now;\r\n\r\n        const animatables = this._activeAnimatables;\r\n        if (animatables.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._animationTime += this.deltaTime;\r\n        const animationTime = this._animationTime;\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n\r\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n                index--; // Array was updated\r\n            }\r\n        }\r\n\r\n        // Late animation bindings\r\n        ProcessLateAnimationBindings(this);\r\n    };\r\n\r\n    sceneClass.prototype.sortActiveAnimatables = function (): void {\r\n        this._activeAnimatables.sort((a, b) => {\r\n            return a.playOrder - b.playOrder;\r\n        });\r\n    };\r\n\r\n    sceneClass.prototype.beginWeightedAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        weight = 1.0,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n        returnedAnimatable.weight = weight;\r\n\r\n        return returnedAnimatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        if (stopCurrent) {\r\n            this.stopAnimation(target, undefined, targetMask);\r\n        }\r\n\r\n        if (!animatable) {\r\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n        }\r\n\r\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n        // Local animations\r\n        if (target.animations && shouldRunTargetAnimations) {\r\n            animatable.appendAnimations(target, target.animations);\r\n        }\r\n\r\n        // Children animations\r\n        if (target.getAnimatables) {\r\n            const animatables = target.getAnimatables();\r\n            for (let index = 0; index < animatables.length; index++) {\r\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n            }\r\n        }\r\n\r\n        animatable.reset();\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginHierarchyAnimation = function (\r\n        target: any,\r\n        directDescendantsOnly: boolean,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectAnimation = function (\r\n        target: any,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (\r\n        target: Node,\r\n        directDescendantsOnly: boolean,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio?: number,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                return this._activeAnimatables[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n        const result = [];\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                result.push(this._activeAnimatables[index]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n        for (const animatable of animatables) {\r\n            animatable.stop(animationName, targetMask);\r\n        }\r\n    };\r\n\r\n    sceneClass.prototype.stopAllAnimations = function (): void {\r\n        if (this._activeAnimatables) {\r\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n                this._activeAnimatables[i].stop(undefined, undefined, true);\r\n            }\r\n            this._activeAnimatables.length = 0;\r\n        }\r\n\r\n        for (const group of this.animationGroups) {\r\n            group.stop();\r\n        }\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\nimport { AddAnimationExtensions } from \"./animatable.core\";\r\nimport type { Animatable } from \"./animatable.core\";\r\nimport type { Animation } from \"./animation\";\r\nimport { Scene } from \"core/scene\";\r\n\r\nexport * from \"./animatable.core\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\n// Connect everything!\r\nAddAnimationExtensions(Scene, Bone);\r\n", "import type { Animatable } from \"./animatable.core\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IMakeAnimationAdditiveOptions } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { AnimationGroupMask } from \"./animationGroupMask\";\r\nimport \"./animatable\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating an additive group animation\r\n */\r\nexport interface IMakeAnimationGroupAdditiveOptions extends IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * Defines if the animation group should be cloned or not (default is false)\r\n     */\r\n    cloneOriginalAnimationGroup?: boolean;\r\n    /**\r\n     * The name of the cloned animation group if cloneOriginalAnimationGroup is true\r\n     */\r\n    clonedAnimationGroupName?: string;\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n    private _weight = -1;\r\n    private _playOrder = 0;\r\n    private _enableBlending: Nullable<boolean> = null;\r\n    private _blendingSpeed: Nullable<number> = null;\r\n    private _numActiveAnimatables = 0;\r\n    private _shouldStart = true;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    private _mask: Nullable<AnimationGroupMask> = null;\r\n\r\n    /**\r\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\r\n     */\r\n    public get mask() {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: Nullable<AnimationGroupMask>) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n\r\n        this.syncWithMask(true);\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\r\n     * Note however that the call won't have any effect if the animation group has not been started yet.\r\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\r\n     */\r\n    public syncWithMask(forceUpdate = false) {\r\n        if (!this.mask && !forceUpdate) {\r\n            this._numActiveAnimatables = this._targetedAnimations.length;\r\n            return;\r\n        }\r\n\r\n        this._numActiveAnimatables = 0;\r\n\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\r\n                this._numActiveAnimatables++;\r\n                if (animatable.paused) {\r\n                    animatable.restart();\r\n                }\r\n            } else {\r\n                if (!animatable.paused) {\r\n                    animatable.pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animations for the targets not retained by the animation group mask.\r\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\r\n     */\r\n    public removeUnmaskedAnimations() {\r\n        if (!this.mask || this.mask.disabled) {\r\n            return;\r\n        }\r\n\r\n        // Removes all animatables (in case the animation group has already been started)\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask.retainsTarget(animatable.target.name)) {\r\n                animatable.stop();\r\n                this._animatables.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n\r\n        // Removes the targeted animations\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n\r\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\r\n                this._targetedAnimations.splice(index, 1);\r\n                --index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    public set from(value: number) {\r\n        if (this._from === value) {\r\n            return;\r\n        }\r\n\r\n        this._from = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.fromFrame = this._from;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    public set to(value: number) {\r\n        if (this._to === value) {\r\n            return;\r\n        }\r\n\r\n        this._to = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.toFrame = this._to;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the weight to apply to all animations of the group\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (this._weight === value) {\r\n            return;\r\n        }\r\n\r\n        this._weight = value;\r\n        this.setWeightForAllAnimatables(this._weight);\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the order of play of the animation group (default: 0)\r\n     */\r\n    public get playOrder() {\r\n        return this._playOrder;\r\n    }\r\n\r\n    public set playOrder(value: number) {\r\n        if (this._playOrder === value) {\r\n            return;\r\n        }\r\n\r\n        this._playOrder = value;\r\n\r\n        if (this._animatables.length > 0) {\r\n            for (let i = 0; i < this._animatables.length; i++) {\r\n                this._animatables[i].playOrder = this._playOrder;\r\n            }\r\n\r\n            this._scene.sortActiveAnimatables();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the animations of the animation group to blend with current running animations\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\r\n     */\r\n    public get enableBlending() {\r\n        return this._enableBlending;\r\n    }\r\n\r\n    public set enableBlending(value: Nullable<boolean>) {\r\n        if (this._enableBlending === value) {\r\n            return;\r\n        }\r\n\r\n        this._enableBlending = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.enableBlending = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animation blending speed\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\r\n     */\r\n    public get blendingSpeed() {\r\n        return this._blendingSpeed;\r\n    }\r\n\r\n    public set blendingSpeed(value: Nullable<number>) {\r\n        if (this._blendingSpeed === value) {\r\n            return;\r\n        }\r\n\r\n        this._blendingSpeed = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.blendingSpeed = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length (in seconds) of the animation group\r\n     * This function assumes that all animations are played at the same framePerSecond speed!\r\n     * Note: you can only call this method after you've added at least one targeted animation!\r\n     * @param from Starting frame range (default is AnimationGroup.from)\r\n     * @param to Ending frame range (default is AnimationGroup.to)\r\n     * @returns The length in seconds\r\n     */\r\n    public getLength(from?: number, to?: number): number {\r\n        from = from ?? this._from;\r\n        to = to ?? this._to;\r\n\r\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\r\n\r\n        return (to - from) / fps;\r\n    }\r\n\r\n    /**\r\n     * Merge the array of animation groups into a new animation group\r\n     * @param animationGroups List of animation groups to merge\r\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\r\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\r\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\r\n     * @returns The new animation group or null if no animation groups were passed\r\n     */\r\n    public static MergeAnimationGroups(animationGroups: Array<AnimationGroup>, disposeSource = true, normalize = false, weight?: number): Nullable<AnimationGroup> {\r\n        if (animationGroups.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        weight = weight ?? animationGroups[0].weight;\r\n\r\n        let beginFrame = Number.MAX_VALUE;\r\n        let endFrame = -Number.MAX_VALUE;\r\n\r\n        if (normalize) {\r\n            for (const animationGroup of animationGroups) {\r\n                if (animationGroup.from < beginFrame) {\r\n                    beginFrame = animationGroup.from;\r\n                }\r\n\r\n                if (animationGroup.to > endFrame) {\r\n                    endFrame = animationGroup.to;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\r\n\r\n        for (const animationGroup of animationGroups) {\r\n            if (normalize) {\r\n                animationGroup.normalize(beginFrame, endFrame);\r\n            }\r\n\r\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\r\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\r\n            }\r\n\r\n            if (disposeSource) {\r\n                animationGroup.dispose();\r\n            }\r\n        }\r\n\r\n        return mergedAnimationGroup;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\r\n     * @param playOrder Defines the order of play of the animation group (default is 0)\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null,\r\n        weight = -1,\r\n        playOrder = 0\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this._weight = weight;\r\n        this._playOrder = playOrder;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation();\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        if (this._enableBlending !== null) {\r\n            animation.enableBlending = this._enableBlending;\r\n        }\r\n\r\n        if (this._blendingSpeed !== null) {\r\n            animation.blendingSpeed = this._blendingSpeed;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n        this._shouldStart = true;\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * Remove an animation from the group\r\n     * @param animation defines the animation we want to remove\r\n     */\r\n    public removeTargetedAnimation(animation: Animation) {\r\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            if (targetedAnimation.animation === animation) {\r\n                this._targetedAnimations.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[] = [];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._numActiveAnimatables) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags.length = 0;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._shouldStart = false;\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags.length = 0;\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.weight = this._weight;\r\n            animatable.playOrder = this._playOrder;\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._scene.sortActiveAnimatables();\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if there are animatable available\r\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop(true);\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from after pausing it\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     * @returns the animation group\r\n     */\r\n    public stop(skipOnAnimationEnd = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\r\n        }\r\n\r\n        // We will take care of removing all stopped animatables\r\n        let curIndex = 0;\r\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\r\n            const animatable = this._scene._activeAnimatables[index];\r\n            if (animatable._runtimeAnimations.length > 0) {\r\n                this._scene._activeAnimatables[curIndex++] = animatable;\r\n            } else if (skipOnAnimationEnd) {\r\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\r\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\r\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\r\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\r\n            }\r\n        }\r\n        this._scene._activeAnimatables.length = curIndex;\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     *\r\n     * @since 6.12.4\r\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\r\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\r\n     * @param weight defines the weight to use\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\r\n     * @param frame the frame number to go to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     * @returns the animationGroup\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame, useWeight);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\r\n     * @returns current animation frame.\r\n     */\r\n    public getCurrentFrame(): number {\r\n        return this.animatables[0]?.masterFrame || 0;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this.isStarted) {\r\n            this.stop();\r\n        }\r\n        this._targetedAnimations.length = 0;\r\n        this._animatables.length = 0;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable, skipOnAnimationEnd = false) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\r\n            this._isStarted = false;\r\n            if (!skipOnAnimationEnd) {\r\n                this.onAnimationGroupEndObservable.notifyObservers(this);\r\n            }\r\n            this._animatables.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\r\n\r\n        newGroup._from = this.from;\r\n        newGroup._to = this.to;\r\n        newGroup._speedRatio = this.speedRatio;\r\n        newGroup._loopAnimation = this.loopAnimation;\r\n        newGroup._isAdditive = this.isAdditive;\r\n        newGroup._enableBlending = this.enableBlending;\r\n        newGroup._blendingSpeed = this.blendingSpeed;\r\n        newGroup.metadata = this.metadata;\r\n        newGroup.mask = this.mask;\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.speedRatio = this.speedRatio;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.isAdditive = this.isAdditive;\r\n        serializationObject.weight = this.weight;\r\n        serializationObject.playOrder = this.playOrder;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (parsedAnimationGroup.speedRatio !== undefined) {\r\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\r\n        }\r\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\r\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\r\n        }\r\n\r\n        if (parsedAnimationGroup.isAdditive !== undefined) {\r\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\r\n        }\r\n\r\n        if (parsedAnimationGroup.weight !== undefined) {\r\n            animationGroup._weight = parsedAnimationGroup.weight;\r\n        }\r\n\r\n        if (parsedAnimationGroup.playOrder !== undefined) {\r\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\r\n        }\r\n\r\n        if (parsedAnimationGroup.enableBlending !== undefined) {\r\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\r\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame: number, range?: string, cloneOriginal?: boolean, clonedName?: string): AnimationGroup;\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param options defines the options to use when converting keyframes\r\n     * @returns a new AnimationGroup if options.cloneOriginalAnimationGroup is true or the original AnimationGroup if options.cloneOriginalAnimationGroup is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, options?: IMakeAnimationGroupAdditiveOptions): AnimationGroup;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimationGroup: AnimationGroup,\r\n        referenceFrameOrOptions?: number | IMakeAnimationGroupAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): AnimationGroup {\r\n        let options: IMakeAnimationGroupAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions,\r\n                range: range,\r\n                cloneOriginalAnimationGroup: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (options.cloneOriginalAnimationGroup) {\r\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        if (options.clipKeys) {\r\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\r\n            let from = Number.MAX_VALUE;\r\n            let to = -Number.MAX_VALUE;\r\n\r\n            const targetedAnimations = animationGroup.targetedAnimations;\r\n            for (let index = 0; index < targetedAnimations.length; index++) {\r\n                const targetedAnimation = targetedAnimations[index];\r\n                const animation = targetedAnimation.animation;\r\n                const keys = animation.getKeys();\r\n\r\n                if (from > keys[0].frame) {\r\n                    from = keys[0].frame;\r\n                }\r\n\r\n                if (to < keys[keys.length - 1].frame) {\r\n                    to = keys[keys.length - 1].frame;\r\n                }\r\n            }\r\n\r\n            animationGroup._from = from;\r\n            animationGroup._to = to;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the keys that are inside a given key range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeys(sourceAnimationGroup: AnimationGroup, fromKey: number, toKey: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeysInPlace(animationGroup: AnimationGroup, fromKey: number, toKey: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the frames that are inside a given frame range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFrames(sourceAnimationGroup: AnimationGroup, fromFrame: number, toFrame: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFramesInPlace(animationGroup: AnimationGroup, fromFrame: number, toFrame: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param start defines the lower bound of the range\r\n     * @param end defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipInPlace(animationGroup: AnimationGroup, start: number, end: number, dontCloneAnimations?: boolean, useFrame = false): AnimationGroup {\r\n        let from = Number.MAX_VALUE;\r\n        let to = -Number.MAX_VALUE;\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\r\n\r\n            if (useFrame) {\r\n                // Make sure we have keys corresponding to the bounds of the frame range\r\n                animation.createKeyForFrame(start);\r\n                animation.createKeyForFrame(end);\r\n            }\r\n\r\n            const keys = animation.getKeys();\r\n            const newKeys: IAnimationKey[] = [];\r\n\r\n            let startFrame = Number.MAX_VALUE;\r\n            for (let k = 0; k < keys.length; k++) {\r\n                const key = keys[k];\r\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\r\n                    const newKey: IAnimationKey = {\r\n                        frame: key.frame,\r\n                        value: key.value.clone ? key.value.clone() : key.value,\r\n                        inTangent: key.inTangent,\r\n                        outTangent: key.outTangent,\r\n                        interpolation: key.interpolation,\r\n                        lockedTangent: key.lockedTangent,\r\n                    };\r\n                    if (startFrame === Number.MAX_VALUE) {\r\n                        startFrame = newKey.frame;\r\n                    }\r\n                    newKey.frame -= startFrame;\r\n                    newKeys.push(newKey);\r\n                }\r\n            }\r\n\r\n            if (newKeys.length === 0) {\r\n                targetedAnimations.splice(index, 1);\r\n                index--;\r\n                continue;\r\n            }\r\n\r\n            if (from > newKeys[0].frame) {\r\n                from = newKeys[0].frame;\r\n            }\r\n\r\n            if (to < newKeys[newKeys.length - 1].frame) {\r\n                to = newKeys[newKeys.length - 1].frame;\r\n            }\r\n\r\n            animation.setKeys(newKeys, true);\r\n            targetedAnimation.animation = animation; // in case the animation has been cloned\r\n        }\r\n\r\n        animationGroup._from = from;\r\n        animationGroup._to = to;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["target", "index", "index", "targetedAnimations"]
}
