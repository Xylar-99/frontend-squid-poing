import {
  FlowGraphCoordinator,
  init_flowGraphCoordinator
} from "./chunk-DX3VPGQ2.js";
import {
  FlowGraphEventBlock,
  init_flowGraphEventBlock
} from "./chunk-QIIXI3SZ.js";
import {
  FlowGraphExecutionBlock,
  init_flowGraphExecutionBlock
} from "./chunk-SUQ4KXF7.js";
import {
  RichType,
  defaultValueParseFunction,
  getRichTypeByFlowGraphType,
  init_flowGraphRichTypes,
  init_serialization,
  needsPathConverter
} from "./chunk-SB4SRMN7.js";
import {
  RGBDTextureTools,
  _UpdateRGBDAsync,
  init_baseTexture_polynomial,
  init_environmentTextureTools,
  init_rgbdTextureTools
} from "./chunk-DZWIAK62.js";
import {
  AutoReleaseWorkerPool,
  init_workerPool
} from "./chunk-MNHBFJEG.js";
import {
  init_abstractEngine_cubeTexture
} from "./chunk-JUUJS7TI.js";
import {
  InstancedMesh,
  init_instancedMesh
} from "./chunk-FDE7L26W.js";
import {
  RawTexture,
  init_rawTexture
} from "./chunk-4GJSM5LB.js";
import {
  Bone,
  init_bone
} from "./chunk-7HGRXGKP.js";
import {
  Animation,
  AnimationRange,
  init_animation,
  init_animationRange
} from "./chunk-E4YQUF7V.js";
import {
  AbstractMesh,
  Geometry,
  Mesh,
  init_abstractMesh,
  init_geometry,
  init_mesh
} from "./chunk-SLNQLWMK.js";
import {
  TransformNode,
  init_transformNode
} from "./chunk-TKSFKGF2.js";
import {
  Camera,
  init_camera
} from "./chunk-WHBMKD76.js";
import {
  ShadowLight,
  init_shadowLight
} from "./chunk-TJD3QTV2.js";
import {
  Light,
  init_light
} from "./chunk-MGZMLHJ7.js";
import {
  Node,
  init_node
} from "./chunk-665N4OZU.js";
import {
  DetailMapConfiguration,
  MaterialFlags,
  MaterialHelperGeometryRendering,
  MaterialPluginBase,
  PrePassConfiguration,
  init_materialFlags,
  init_materialHelper_geometryrendering,
  init_materialPluginBase,
  init_material_detailMapConfiguration,
  init_prePassConfiguration
} from "./chunk-J6IHOZS2.js";
import {
  PushMaterial,
  init_pushMaterial
} from "./chunk-IKPNWS4N.js";
import {
  MaterialDefines,
  init_materialDefines
} from "./chunk-6RLDECPQ.js";
import {
  BoundingInfo,
  Material,
  init_boundingInfo,
  init_material
} from "./chunk-GQ3TXI7S.js";
import {
  ImageProcessingConfiguration,
  Scene,
  init_imageProcessingConfiguration,
  init_scene
} from "./chunk-DR3K4Z6K.js";
import {
  SceneComponentConstants,
  init_sceneComponent
} from "./chunk-J6IZTA6X.js";
import {
  EffectFallbacks,
  init_effectFallbacks
} from "./chunk-UTIQS6D2.js";
import {
  Texture,
  init_texture
} from "./chunk-FF2BXABR.js";
import {
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindTextureMatrix,
  HandleFallbacksForShadows,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformsAndSamplersList,
  addClipPlaneUniforms,
  bindClipPlane,
  init_clipPlaneMaterialHelper,
  init_materialHelper_functions
} from "./chunk-VSOUHOYD.js";
import {
  BaseTexture,
  init_baseTexture
} from "./chunk-37N5W4NZ.js";
import {
  SmartArray,
  init_smartArray
} from "./chunk-LMRRMO22.js";
import {
  Buffer,
  VertexBuffer,
  init_buffer
} from "./chunk-5UL5TUIP.js";
import {
  Tools,
  init_tools
} from "./chunk-RBASUMGO.js";
import {
  DeepCopier,
  init_deepCopier
} from "./chunk-QWFUDOFV.js";
import {
  Decode,
  init_stringTools
} from "./chunk-V73FELAU.js";
import {
  AbstractEngine,
  _retryWithInterval,
  init_abstractEngine,
  init_timingTools
} from "./chunk-KKMPA6IU.js";
import {
  IsWindowObjectExist,
  PrecisionDate,
  init_domManagement,
  init_precisionDate
} from "./chunk-MYQLYDRR.js";
import {
  Logger,
  init_logger
} from "./chunk-RB67CL7C.js";
import {
  SerializationHelper,
  Tags,
  init_decorators_serialization,
  init_tags
} from "./chunk-VWRIBYIQ.js";
import {
  __decorate,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor3,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-56URP3F6.js";
import {
  _WarnImport,
  init_devTools
} from "./chunk-ZOMZ6NXY.js";
import {
  Matrix,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4,
  init_math_vector
} from "./chunk-3SMC2E6I.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-LZS7X66T.js";
import {
  Observable,
  init_observable
} from "./chunk-H6EIW4LR.js";
import {
  Color3,
  TmpColors,
  init_math_color
} from "./chunk-52D66CJC.js";
import {
  GetClass,
  RegisterClass,
  init_typeStore
} from "./chunk-FYD2IJRD.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Animations/animationEvent.js
var AnimationEvent;
var init_animationEvent = __esm({
  "node_modules/@babylonjs/core/Animations/animationEvent.js"() {
    AnimationEvent = class _AnimationEvent {
      /**
       * Initializes the animation event
       * @param frame The frame for which the event is triggered
       * @param action The event to perform when triggered
       * @param onlyOnce Specifies if the event should be triggered only once
       */
      constructor(frame, action, onlyOnce) {
        this.frame = frame;
        this.action = action;
        this.onlyOnce = onlyOnce;
        this.isDone = false;
      }
      /** @internal */
      _clone() {
        return new _AnimationEvent(this.frame, this.action, this.onlyOnce);
      }
    };
  }
});

// node_modules/@babylonjs/core/assetContainer.js
var AbstractAssetContainer, KeepAssets, InstantiatedEntries, AssetContainer;
var init_assetContainer = __esm({
  "node_modules/@babylonjs/core/assetContainer.js"() {
    init_mesh();
    init_transformNode();
    init_abstractMesh();
    init_logger();
    init_engineStore();
    init_instancedMesh();
    init_light();
    init_camera();
    init_tools();
    init_tags();
    AbstractAssetContainer = class {
      constructor() {
        this.rootNodes = [];
        this.cameras = [];
        this.lights = [];
        this.meshes = [];
        this.skeletons = [];
        this.particleSystems = [];
        this.animations = [];
        this.animationGroups = [];
        this.multiMaterials = [];
        this.materials = [];
        this.morphTargetManagers = [];
        this.geometries = [];
        this.transformNodes = [];
        this.actionManagers = [];
        this.textures = [];
        this._environmentTexture = null;
        this.postProcesses = [];
        this.sounds = null;
        this.effectLayers = [];
        this.layers = [];
        this.reflectionProbes = [];
      }
      /**
       * Texture used in all pbr material as the reflection texture.
       * As in the majority of the scene they are the same (exception for multi room and so on),
       * this is easier to reference from here than from all the materials.
       */
      get environmentTexture() {
        return this._environmentTexture;
      }
      set environmentTexture(value) {
        this._environmentTexture = value;
      }
      /**
       * @returns all meshes, lights, cameras, transformNodes and bones
       */
      getNodes() {
        let nodes = [];
        nodes = nodes.concat(this.meshes);
        nodes = nodes.concat(this.lights);
        nodes = nodes.concat(this.cameras);
        nodes = nodes.concat(this.transformNodes);
        this.skeletons.forEach((skeleton) => nodes = nodes.concat(skeleton.bones));
        return nodes;
      }
    };
    KeepAssets = class extends AbstractAssetContainer {
    };
    InstantiatedEntries = class {
      constructor() {
        this.rootNodes = [];
        this.skeletons = [];
        this.animationGroups = [];
      }
      /**
       * Disposes the instantiated entries from the scene
       */
      dispose() {
        this.rootNodes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.rootNodes.length = 0;
        this.skeletons.slice(0).forEach((o) => {
          o.dispose();
        });
        this.skeletons.length = 0;
        this.animationGroups.slice(0).forEach((o) => {
          o.dispose();
        });
        this.animationGroups.length = 0;
      }
    };
    AssetContainer = class extends AbstractAssetContainer {
      /**
       * Instantiates an AssetContainer.
       * @param scene The scene the AssetContainer belongs to.
       */
      constructor(scene) {
        super();
        this._wasAddedToScene = false;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this.scene = scene;
        this["proceduralTextures"] = [];
        scene.onDisposeObservable.add(() => {
          if (!this._wasAddedToScene) {
            this.dispose();
          }
        });
        this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {
          for (const geometry of this.geometries) {
            geometry._rebuild();
          }
          for (const mesh of this.meshes) {
            mesh._rebuild();
          }
          for (const system of this.particleSystems) {
            system.rebuild();
          }
          for (const texture of this.textures) {
            texture._rebuild();
          }
        });
      }
      /**
       * Given a list of nodes, return a topological sorting of them.
       * @param nodes
       * @returns a sorted array of nodes
       */
      _topologicalSort(nodes) {
        const nodesUidMap = /* @__PURE__ */ new Map();
        for (const node of nodes) {
          nodesUidMap.set(node.uniqueId, node);
        }
        const dependencyGraph = {
          dependsOn: /* @__PURE__ */ new Map(),
          // given a node id, what are the ids of the nodes it depends on
          dependedBy: /* @__PURE__ */ new Map()
          // given a node id, what are the ids of the nodes that depend on it
        };
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          dependencyGraph.dependsOn.set(nodeId, /* @__PURE__ */ new Set());
          dependencyGraph.dependedBy.set(nodeId, /* @__PURE__ */ new Set());
        }
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          const dependsOn = dependencyGraph.dependsOn.get(nodeId);
          if (node instanceof InstancedMesh) {
            const masterMesh = node.sourceMesh;
            if (nodesUidMap.has(masterMesh.uniqueId)) {
              dependsOn.add(masterMesh.uniqueId);
              dependencyGraph.dependedBy.get(masterMesh.uniqueId).add(nodeId);
            }
          }
          const dependedBy = dependencyGraph.dependedBy.get(nodeId);
          for (const child of node.getDescendants()) {
            const childId = child.uniqueId;
            if (nodesUidMap.has(childId)) {
              dependedBy.add(childId);
              const childDependsOn = dependencyGraph.dependsOn.get(childId);
              childDependsOn.add(nodeId);
            }
          }
        }
        const sortedNodes = [];
        const leaves = [];
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          if (dependencyGraph.dependsOn.get(nodeId).size === 0) {
            leaves.push(node);
            nodesUidMap.delete(nodeId);
          }
        }
        const visitList = leaves;
        while (visitList.length > 0) {
          const nodeToVisit = visitList.shift();
          sortedNodes.push(nodeToVisit);
          const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId);
          for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {
            const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId);
            dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);
            if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {
              visitList.push(nodesUidMap.get(dependedByVisitedNodeId));
              nodesUidMap.delete(dependedByVisitedNodeId);
            }
          }
        }
        if (nodesUidMap.size > 0) {
          Logger.Error("SceneSerializer._topologicalSort: There were unvisited nodes:");
          nodesUidMap.forEach((node) => Logger.Error(node.name));
        }
        return sortedNodes;
      }
      _addNodeAndDescendantsToList(list, addedIds, rootNode, predicate) {
        if (!rootNode || predicate && !predicate(rootNode) || addedIds.has(rootNode.uniqueId)) {
          return;
        }
        list.push(rootNode);
        addedIds.add(rootNode.uniqueId);
        for (const child of rootNode.getDescendants(true)) {
          this._addNodeAndDescendantsToList(list, addedIds, child, predicate);
        }
      }
      /**
       * Check if a specific node is contained in this asset container.
       * @param node the node to check
       * @returns true if the node is contained in this container, otherwise false.
       */
      _isNodeInContainer(node) {
        if (node instanceof AbstractMesh && this.meshes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Light && this.lights.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {
          return true;
        }
        return false;
      }
      /**
       * For every node in the scene, check if its parent node is also in the scene.
       * @returns true if every node's parent is also in the scene, otherwise false.
       */
      _isValidHierarchy() {
        for (const node of this.meshes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.transformNodes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.lights) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.cameras) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        return true;
      }
      /**
       * Instantiate or clone all meshes and add the new ones to the scene.
       * Skeletons and animation groups will all be cloned
       * @param nameFunction defines an optional function used to get new names for clones
       * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
       * @param options defines an optional list of options to control how to instantiate / clone models
       * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
       * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone
       * @returns a list of rootNodes, skeletons and animation groups that were duplicated
       */
      instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
        }
        const conversionMap = {};
        const storeMap = {};
        const result = new InstantiatedEntries();
        const alreadySwappedSkeletons = [];
        const alreadySwappedMaterials = [];
        const localOptions = {
          doNotInstantiate: true,
          ...options
        };
        const onClone = (source, clone) => {
          conversionMap[source.uniqueId] = clone.uniqueId;
          storeMap[clone.uniqueId] = clone;
          if (nameFunction) {
            clone.name = nameFunction(source.name);
          }
          if (clone instanceof Mesh) {
            const clonedMesh = clone;
            if (clonedMesh.morphTargetManager) {
              const oldMorphTargetManager = source.morphTargetManager;
              clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
              for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {
                const oldTarget = oldMorphTargetManager.getTarget(index);
                const newTarget = clonedMesh.morphTargetManager.getTarget(index);
                conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;
                storeMap[newTarget.uniqueId] = newTarget;
              }
            }
          }
        };
        const nodesToSort = [];
        const idsOnSortList = /* @__PURE__ */ new Set();
        for (const transformNode of this.transformNodes) {
          if (transformNode.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);
          }
        }
        for (const mesh of this.meshes) {
          if (mesh.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);
          }
        }
        const sortedNodes = this._topologicalSort(nodesToSort);
        const onNewCreated = (source, clone) => {
          onClone(source, clone);
          if (source.parent) {
            const replicatedParentId = conversionMap[source.parent.uniqueId];
            const replicatedParent = storeMap[replicatedParentId];
            if (replicatedParent) {
              clone.parent = replicatedParent;
            } else {
              clone.parent = source.parent;
            }
          }
          if (clone.position && source.position) {
            clone.position.copyFrom(source.position);
          }
          if (clone.rotationQuaternion && source.rotationQuaternion) {
            clone.rotationQuaternion.copyFrom(source.rotationQuaternion);
          }
          if (clone.rotation && source.rotation) {
            clone.rotation.copyFrom(source.rotation);
          }
          if (clone.scaling && source.scaling) {
            clone.scaling.copyFrom(source.scaling);
          }
          if (clone.material) {
            const mesh = clone;
            if (mesh.material) {
              if (cloneMaterials) {
                const sourceMaterial = source.material;
                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
                  let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
                  alreadySwappedMaterials.push(sourceMaterial);
                  conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                  if (sourceMaterial.getClassName() === "MultiMaterial") {
                    const multi = sourceMaterial;
                    for (const material of multi.subMaterials) {
                      if (!material) {
                        continue;
                      }
                      swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                      alreadySwappedMaterials.push(material);
                      conversionMap[material.uniqueId] = swap.uniqueId;
                      storeMap[swap.uniqueId] = swap;
                    }
                    multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);
                  }
                }
                if (mesh.getClassName() !== "InstancedMesh") {
                  mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];
                }
              } else {
                if (mesh.material.getClassName() === "MultiMaterial") {
                  if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                    this.scene.addMultiMaterial(mesh.material);
                  }
                } else {
                  if (this.scene.materials.indexOf(mesh.material) === -1) {
                    this.scene.addMaterial(mesh.material);
                  }
                }
              }
            }
          }
          if (clone.parent === null) {
            result.rootNodes.push(clone);
          }
        };
        sortedNodes.forEach((node) => {
          if (node.getClassName() === "InstancedMesh") {
            const instancedNode = node;
            const sourceMesh = instancedNode.sourceMesh;
            const replicatedSourceId = conversionMap[sourceMesh.uniqueId];
            const replicatedSource = typeof replicatedSourceId === "number" ? storeMap[replicatedSourceId] : sourceMesh;
            const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);
            onNewCreated(instancedNode, replicatedInstancedNode);
          } else {
            let canInstance = true;
            if (node.getClassName() === "TransformNode" || node.getClassName() === "Node" || node.skeleton || !node.getTotalVertices || node.getTotalVertices() === 0) {
              canInstance = false;
            } else if (localOptions.doNotInstantiate) {
              if (typeof localOptions.doNotInstantiate === "function") {
                canInstance = !localOptions.doNotInstantiate(node);
              } else {
                canInstance = !localOptions.doNotInstantiate;
              }
            }
            const replicatedNode = canInstance ? node.createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);
            if (!replicatedNode) {
              throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);
            }
            onNewCreated(node, replicatedNode);
          }
        });
        this.skeletons.forEach((s) => {
          if (localOptions.predicate && !localOptions.predicate(s)) {
            return;
          }
          const clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
          for (const m of this.meshes) {
            if (m.skeleton === s && !m.isAnInstance) {
              const copy = storeMap[conversionMap[m.uniqueId]];
              if (!copy || copy.isAnInstance) {
                continue;
              }
              copy.skeleton = clone;
              if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
                continue;
              }
              alreadySwappedSkeletons.push(clone);
              for (const bone of clone.bones) {
                if (bone._linkedTransformNode) {
                  bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];
                }
              }
            }
          }
          result.skeletons.push(clone);
        });
        this.animationGroups.forEach((o) => {
          if (localOptions.predicate && !localOptions.predicate(o)) {
            return;
          }
          const clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, (oldTarget) => {
            const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];
            return newTarget || oldTarget;
          });
          result.animationGroups.push(clone);
        });
        return result;
      }
      /**
       * Adds all the assets from the container to the scene.
       */
      addAllToScene() {
        if (this._wasAddedToScene) {
          return;
        }
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = true;
        this.addToScene(null);
        if (this.environmentTexture) {
          this.scene.environmentTexture = this.environmentTexture;
        }
        for (const component of this.scene._serializableComponents) {
          component.addFromContainer(this);
        }
        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      }
      /**
       * Adds assets from the container to the scene.
       * @param predicate defines a predicate used to select which entity will be added (can be null)
       */
      addToScene(predicate = null) {
        const addedNodes = [];
        this.cameras.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addCamera(o);
          addedNodes.push(o);
        });
        this.lights.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addLight(o);
          addedNodes.push(o);
        });
        this.meshes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMesh(o);
          addedNodes.push(o);
        });
        this.skeletons.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addSkeleton(o);
        });
        this.animations.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addAnimation(o);
        });
        this.animationGroups.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addAnimationGroup(o);
        });
        this.multiMaterials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMultiMaterial(o);
        });
        this.materials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMaterial(o);
        });
        this.morphTargetManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMorphTargetManager(o);
        });
        this.geometries.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addGeometry(o);
        });
        this.transformNodes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addTransformNode(o);
          addedNodes.push(o);
        });
        this.actionManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addActionManager(o);
        });
        this.textures.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addTexture(o);
        });
        this.reflectionProbes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addReflectionProbe(o);
        });
        for (const addedNode of addedNodes) {
          if (addedNode.parent && this.scene.getNodes().indexOf(addedNode.parent) === -1) {
            if (addedNode.setParent) {
              addedNode.setParent(null);
            } else {
              addedNode.parent = null;
            }
          }
        }
      }
      /**
       * Removes all the assets in the container from the scene
       */
      removeAllFromScene() {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = false;
        this.removeFromScene(null);
        if (this.environmentTexture === this.scene.environmentTexture) {
          this.scene.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this);
        }
      }
      /**
       * Removes assets in the container from the scene
       * @param predicate defines a predicate used to select which entity will be added (can be null)
       */
      removeFromScene(predicate = null) {
        this.cameras.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeCamera(o);
        });
        this.lights.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeLight(o);
        });
        this.meshes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMesh(o, true);
        });
        this.skeletons.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeSkeleton(o);
        });
        this.animations.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeAnimation(o);
        });
        this.animationGroups.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeAnimationGroup(o);
        });
        this.multiMaterials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMultiMaterial(o);
        });
        this.materials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMaterial(o);
        });
        this.morphTargetManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMorphTargetManager(o);
        });
        this.geometries.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeGeometry(o);
        });
        this.transformNodes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeTransformNode(o);
        });
        this.actionManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeActionManager(o);
        });
        this.textures.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeTexture(o);
        });
        this.reflectionProbes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeReflectionProbe(o);
        });
      }
      /**
       * Disposes all the assets in the container
       */
      dispose() {
        this.cameras.slice(0).forEach((o) => {
          o.dispose();
        });
        this.cameras.length = 0;
        this.lights.slice(0).forEach((o) => {
          o.dispose();
        });
        this.lights.length = 0;
        this.meshes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.meshes.length = 0;
        this.skeletons.slice(0).forEach((o) => {
          o.dispose();
        });
        this.skeletons.length = 0;
        this.animationGroups.slice(0).forEach((o) => {
          o.dispose();
        });
        this.animationGroups.length = 0;
        this.multiMaterials.slice(0).forEach((o) => {
          o.dispose();
        });
        this.multiMaterials.length = 0;
        this.materials.slice(0).forEach((o) => {
          o.dispose();
        });
        this.materials.length = 0;
        this.geometries.slice(0).forEach((o) => {
          o.dispose();
        });
        this.geometries.length = 0;
        this.transformNodes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.transformNodes.length = 0;
        this.actionManagers.slice(0).forEach((o) => {
          o.dispose();
        });
        this.actionManagers.length = 0;
        this.textures.slice(0).forEach((o) => {
          o.dispose();
        });
        this.textures.length = 0;
        this.reflectionProbes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.reflectionProbes.length = 0;
        this.morphTargetManagers.slice(0).forEach((o) => {
          o.dispose();
        });
        this.morphTargetManagers.length = 0;
        if (this.environmentTexture) {
          this.environmentTexture.dispose();
          this.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this, true);
        }
        if (this._onContextRestoredObserver) {
          this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
      }
      _moveAssets(sourceAssets, targetAssets, keepAssets) {
        if (!sourceAssets || !targetAssets) {
          return;
        }
        for (const asset of sourceAssets) {
          let move = true;
          if (keepAssets) {
            for (const keepAsset of keepAssets) {
              if (asset === keepAsset) {
                move = false;
                break;
              }
            }
          }
          if (move) {
            targetAssets.push(asset);
            asset._parentContainer = this;
          }
        }
      }
      /**
       * Removes all the assets contained in the scene and adds them to the container.
       * @param keepAssets Set of assets to keep in the scene. (default: empty)
       */
      moveAllFromScene(keepAssets) {
        this._wasAddedToScene = false;
        if (keepAssets === void 0) {
          keepAssets = new KeepAssets();
        }
        for (const key in this) {
          if (Object.prototype.hasOwnProperty.call(this, key)) {
            this[key] = this[key] || (key === "_environmentTexture" ? null : []);
            this._moveAssets(this.scene[key], this[key], keepAssets[key]);
          }
        }
        this.environmentTexture = this.scene.environmentTexture;
        this.removeAllFromScene();
      }
      /**
       * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
       * @returns the root mesh
       */
      createRootMesh() {
        const rootMesh = new Mesh("assetContainerRootMesh", this.scene);
        this.meshes.forEach((m) => {
          if (!m.parent) {
            rootMesh.addChild(m);
          }
        });
        this.meshes.unshift(rootMesh);
        return rootMesh;
      }
      /**
       * Merge animations (direct and animation groups) from this asset container into a scene
       * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
       * @param animatables set of animatables to retarget to a node from the scene
       * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
       * @returns an array of the new AnimationGroup added to the scene (empty array if none)
       */
      mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {
        if (!scene) {
          Logger.Error("No scene available to merge animations to");
          return [];
        }
        const _targetConverter = targetConverter ? targetConverter : (target) => {
          let node = null;
          const targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
          const name = target.name.split(".").join("").split("_primitive")[0];
          switch (targetProperty) {
            case "position":
            case "rotationQuaternion":
              node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);
              break;
            case "influence":
              node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);
              break;
            default:
              node = scene.getNodeByName(target.name) || scene.getNodeByName(name);
          }
          return node;
        };
        const nodesInAC = this.getNodes();
        nodesInAC.forEach((nodeInAC) => {
          const nodeInScene = _targetConverter(nodeInAC);
          if (nodeInScene !== null) {
            for (const animationInAC of nodeInAC.animations) {
              const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {
                return animationInScene.targetProperty === animationInAC.targetProperty;
              });
              for (const animationWithSameProperty of animationsWithSameProperty) {
                const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
                if (index > -1) {
                  nodeInScene.animations.splice(index, 1);
                }
              }
            }
            nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
          }
        });
        const newAnimationGroups = [];
        this.animationGroups.slice().forEach((animationGroupInAC) => {
          newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
          animationGroupInAC.animatables.forEach((animatable) => {
            animatable.stop();
          });
        });
        animatables.forEach((animatable) => {
          const target = _targetConverter(animatable.target);
          if (target) {
            scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
            scene.stopAnimation(animatable.target);
          }
        });
        return newAnimationGroups;
      }
      /**
       * @since 6.15.0
       * This method checks for any node that has no parent
       * and is not in the rootNodes array, and adds the node
       * there, if so.
       */
      populateRootNodes() {
        this.rootNodes.length = 0;
        this.meshes.forEach((m) => {
          if (!m.parent && this.rootNodes.indexOf(m) === -1) {
            this.rootNodes.push(m);
          }
        });
        this.transformNodes.forEach((t) => {
          if (!t.parent && this.rootNodes.indexOf(t) === -1) {
            this.rootNodes.push(t);
          }
        });
        this.lights.forEach((l) => {
          if (!l.parent && this.rootNodes.indexOf(l) === -1) {
            this.rootNodes.push(l);
          }
        });
        this.cameras.forEach((c) => {
          if (!c.parent && this.rootNodes.indexOf(c) === -1) {
            this.rootNodes.push(c);
          }
        });
      }
      /**
       * @since 6.26.0
       * Given a root asset, this method will traverse its hierarchy and add it, its children and any materials/skeletons/animation groups to the container.
       * @param root root node
       */
      addAllAssetsToContainer(root) {
        if (!root) {
          return;
        }
        const nodesToVisit = [];
        const visitedNodes = /* @__PURE__ */ new Set();
        nodesToVisit.push(root);
        while (nodesToVisit.length > 0) {
          const nodeToVisit = nodesToVisit.pop();
          if (nodeToVisit instanceof Mesh) {
            if (nodeToVisit.geometry && this.geometries.indexOf(nodeToVisit.geometry) === -1) {
              this.geometries.push(nodeToVisit.geometry);
            }
            this.meshes.push(nodeToVisit);
          } else if (nodeToVisit instanceof TransformNode) {
            this.transformNodes.push(nodeToVisit);
          } else if (nodeToVisit instanceof Light) {
            this.lights.push(nodeToVisit);
          } else if (nodeToVisit instanceof Camera) {
            this.cameras.push(nodeToVisit);
          }
          if (nodeToVisit instanceof AbstractMesh) {
            if (nodeToVisit.material && this.materials.indexOf(nodeToVisit.material) === -1) {
              this.materials.push(nodeToVisit.material);
              for (const texture of nodeToVisit.material.getActiveTextures()) {
                if (this.textures.indexOf(texture) === -1) {
                  this.textures.push(texture);
                }
              }
            }
            if (nodeToVisit.skeleton && this.skeletons.indexOf(nodeToVisit.skeleton) === -1) {
              this.skeletons.push(nodeToVisit.skeleton);
            }
            if (nodeToVisit.morphTargetManager && this.morphTargetManagers.indexOf(nodeToVisit.morphTargetManager) === -1) {
              this.morphTargetManagers.push(nodeToVisit.morphTargetManager);
            }
          }
          for (const child of nodeToVisit.getChildren()) {
            if (!visitedNodes.has(child)) {
              nodesToVisit.push(child);
            }
          }
          visitedNodes.add(nodeToVisit);
        }
        this.populateRootNodes();
      }
      /**
       * Get from a list of objects by tags
       * @param list the list of objects to use
       * @param tagsQuery the query to use
       * @param filter a predicate to filter for tags
       * @returns
       */
      _getByTags(list, tagsQuery, filter) {
        if (tagsQuery === void 0) {
          return list;
        }
        const listByTags = [];
        for (const i in list) {
          const item = list[i];
          if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {
            listByTags.push(item);
          }
        }
        return listByTags;
      }
      /**
       * Get a list of meshes by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Mesh
       */
      getMeshesByTags(tagsQuery, filter) {
        return this._getByTags(this.meshes, tagsQuery, filter);
      }
      /**
       * Get a list of cameras by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Camera
       */
      getCamerasByTags(tagsQuery, filter) {
        return this._getByTags(this.cameras, tagsQuery, filter);
      }
      /**
       * Get a list of lights by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Light
       */
      getLightsByTags(tagsQuery, filter) {
        return this._getByTags(this.lights, tagsQuery, filter);
      }
      /**
       * Get a list of materials by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Material
       */
      getMaterialsByTags(tagsQuery, filter) {
        return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));
      }
      /**
       * Get a list of transform nodes by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of TransformNode
       */
      getTransformNodesByTags(tagsQuery, filter) {
        return this._getByTags(this.transformNodes, tagsQuery, filter);
      }
    };
  }
});

// node_modules/@babylonjs/core/Audio/audioEngine.js
var AudioEngine;
var init_audioEngine = __esm({
  "node_modules/@babylonjs/core/Audio/audioEngine.js"() {
    init_observable();
    init_logger();
    init_abstractEngine();
    init_domManagement();
    AbstractEngine.AudioEngineFactory = (hostElement, audioContext, audioDestination) => {
      return new AudioEngine(hostElement, audioContext, audioDestination);
    };
    AudioEngine = class {
      /**
       * Gets the current AudioContext if available.
       */
      get audioContext() {
        if (!this._audioContextInitialized) {
          this._initializeAudioContext();
        }
        return this._audioContext;
      }
      /**
       * Instantiates a new audio engine.
       *
       * There should be only one per page as some browsers restrict the number
       * of audio contexts you can create.
       * @param hostElement defines the host element where to display the mute icon if necessary
       * @param audioContext defines the audio context to be used by the audio engine
       * @param audioDestination defines the audio destination node to be used by audio engine
       */
      constructor(hostElement = null, audioContext = null, audioDestination = null) {
        this._audioContext = null;
        this._audioContextInitialized = false;
        this._muteButton = null;
        this._audioDestination = null;
        this.canUseWebAudio = false;
        this.WarnedWebAudioUnsupported = false;
        this.isMP3supported = false;
        this.isOGGsupported = false;
        this.unlocked = false;
        this.useCustomUnlockedButton = false;
        this.onAudioUnlockedObservable = new Observable();
        this.onAudioLockedObservable = new Observable();
        this._tryToRun = false;
        this._onResize = () => {
          this._moveButtonToTopLeft();
        };
        if (!IsWindowObjectExist()) {
          return;
        }
        if (typeof window.AudioContext !== "undefined") {
          this.canUseWebAudio = true;
        }
        const audioElem = document.createElement("audio");
        this._hostElement = hostElement;
        this._audioContext = audioContext;
        this._audioDestination = audioDestination;
        try {
          if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") || audioElem.canPlayType("audio/mp3").replace(/^no$/, ""))) {
            this.isMP3supported = true;
          }
        } catch (e) {
        }
        try {
          if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
            this.isOGGsupported = true;
          }
        } catch (e) {
        }
      }
      /**
       * Flags the audio engine in Locked state.
       * This happens due to new browser policies preventing audio to autoplay.
       */
      lock() {
        this._triggerSuspendedState();
      }
      /**
       * Unlocks the audio engine once a user action has been done on the dom.
       * This is helpful to resume play once browser policies have been satisfied.
       */
      unlock() {
        var _a, _b;
        if (((_a = this._audioContext) == null ? void 0 : _a.state) === "running") {
          this._hideMuteButton();
          if (!this.unlocked) {
            this.unlocked = true;
            this.onAudioUnlockedObservable.notifyObservers(this);
          }
          return;
        }
        if (this._tryToRun) {
          (_b = this._audioContext) == null ? void 0 : _b.suspend().then(() => {
            this._tryToRun = false;
            this._triggerRunningState();
          });
        } else {
          this._triggerRunningState();
        }
      }
      /** @internal */
      _resumeAudioContextOnStateChange() {
        var _a;
        (_a = this._audioContext) == null ? void 0 : _a.addEventListener("statechange", () => {
          var _a2;
          if (this.unlocked && ((_a2 = this._audioContext) == null ? void 0 : _a2.state) !== "running") {
            this._resumeAudioContext();
          }
        }, {
          once: true,
          passive: true,
          signal: AbortSignal.timeout(3e3)
        });
      }
      _resumeAudioContext() {
        var _a;
        if ((_a = this._audioContext) == null ? void 0 : _a.resume) {
          return this._audioContext.resume();
        }
        return Promise.resolve();
      }
      _initializeAudioContext() {
        try {
          if (this.canUseWebAudio) {
            if (!this._audioContext) {
              this._audioContext = new AudioContext();
            }
            this.masterGain = this._audioContext.createGain();
            this.masterGain.gain.value = 1;
            if (!this._audioDestination) {
              this._audioDestination = this._audioContext.destination;
            }
            this.masterGain.connect(this._audioDestination);
            this._audioContextInitialized = true;
            if (this._audioContext.state === "running") {
              this._triggerRunningState();
            }
          }
        } catch (e) {
          this.canUseWebAudio = false;
          Logger.Error("Web Audio: " + e.message);
        }
      }
      _triggerRunningState() {
        if (this._tryToRun) {
          return;
        }
        this._tryToRun = true;
        this._resumeAudioContext().then(() => {
          this._tryToRun = false;
          if (this._muteButton) {
            this._hideMuteButton();
          }
          this.unlocked = true;
          this.onAudioUnlockedObservable.notifyObservers(this);
        }).catch(() => {
          this._tryToRun = false;
          this.unlocked = false;
        });
      }
      _triggerSuspendedState() {
        this.unlocked = false;
        this.onAudioLockedObservable.notifyObservers(this);
        this._displayMuteButton();
      }
      _displayMuteButton() {
        if (this.useCustomUnlockedButton || this._muteButton) {
          return;
        }
        this._muteButton = document.createElement("BUTTON");
        this._muteButton.className = "babylonUnmuteIcon";
        this._muteButton.id = "babylonUnmuteIconBtn";
        this._muteButton.title = "Unmute";
        const imageUrl = !window.SVGSVGElement ? "https://cdn.babylonjs.com/Assets/audio.png" : "data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E";
        const css = ".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(" + imageUrl + ");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }";
        const style = document.createElement("style");
        style.appendChild(document.createTextNode(css));
        document.getElementsByTagName("head")[0].appendChild(style);
        document.body.appendChild(this._muteButton);
        this._moveButtonToTopLeft();
        this._muteButton.addEventListener("touchend", () => {
          this._triggerRunningState();
        }, true);
        this._muteButton.addEventListener("click", () => {
          this.unlock();
        }, true);
        window.addEventListener("resize", this._onResize);
      }
      _moveButtonToTopLeft() {
        if (this._hostElement && this._muteButton) {
          this._muteButton.style.top = this._hostElement.offsetTop + 20 + "px";
          this._muteButton.style.left = this._hostElement.offsetLeft + 20 + "px";
        }
      }
      _hideMuteButton() {
        if (this._muteButton) {
          document.body.removeChild(this._muteButton);
          this._muteButton = null;
        }
      }
      /**
       * Destroy and release the resources associated with the audio context.
       */
      dispose() {
        if (this.canUseWebAudio && this._audioContextInitialized) {
          if (this._connectedAnalyser && this._audioContext) {
            this._connectedAnalyser.stopDebugCanvas();
            this._connectedAnalyser.dispose();
            this.masterGain.disconnect();
            this.masterGain.connect(this._audioContext.destination);
            this._connectedAnalyser = null;
          }
          this.masterGain.gain.value = 1;
        }
        this.WarnedWebAudioUnsupported = false;
        this._hideMuteButton();
        window.removeEventListener("resize", this._onResize);
        this.onAudioUnlockedObservable.clear();
        this.onAudioLockedObservable.clear();
      }
      /**
       * Gets the global volume sets on the master gain.
       * @returns the global volume if set or -1 otherwise
       */
      getGlobalVolume() {
        if (this.canUseWebAudio && this._audioContextInitialized) {
          return this.masterGain.gain.value;
        } else {
          return -1;
        }
      }
      /**
       * Sets the global volume of your experience (sets on the master gain).
       * @param newVolume Defines the new global volume of the application
       */
      setGlobalVolume(newVolume) {
        if (this.canUseWebAudio && this._audioContextInitialized) {
          this.masterGain.gain.value = newVolume;
        }
      }
      /**
       * Connect the audio engine to an audio analyser allowing some amazing
       * synchronization between the sounds/music and your visualization (VuMeter for instance).
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser
       * @param analyser The analyser to connect to the engine
       */
      connectToAnalyser(analyser) {
        if (this._connectedAnalyser) {
          this._connectedAnalyser.stopDebugCanvas();
        }
        if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {
          this._connectedAnalyser = analyser;
          this.masterGain.disconnect();
          this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Audio/sound.js
var Sound;
var init_sound = __esm({
  "node_modules/@babylonjs/core/Audio/sound.js"() {
    init_tools();
    init_observable();
    init_math_vector();
    init_logger();
    init_devTools();
    init_engineStore();
    init_typeStore();
    init_abstractEngine();
    init_timingTools();
    Sound = class _Sound {
      /**
       * Does the sound loop after it finishes playing once.
       */
      get loop() {
        return this._loop;
      }
      set loop(value) {
        if (value === this._loop) {
          return;
        }
        this._loop = value;
        this.updateOptions({ loop: value });
      }
      /**
       * Gets the current time for the sound.
       */
      get currentTime() {
        var _a;
        if (this._htmlAudioElement) {
          return this._htmlAudioElement.currentTime;
        }
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.audioContext) && (this.isPlaying || this.isPaused)) {
          const timeSinceLastStart = this.isPaused ? 0 : AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;
          return this._currentTime + timeSinceLastStart;
        }
        return 0;
      }
      /**
       * Does this sound enables spatial sound.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      get spatialSound() {
        return this._spatialSound;
      }
      /**
       * Does this sound enables spatial sound.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      set spatialSound(newValue) {
        if (newValue == this._spatialSound) {
          return;
        }
        const wasPlaying = this.isPlaying;
        this.pause();
        if (newValue) {
          this._spatialSound = newValue;
          this._updateSpatialParameters();
        } else {
          this._disableSpatialSound();
        }
        if (wasPlaying) {
          this.play();
        }
      }
      /**
       * Create a sound and attach it to a scene
       * @param name Name of your sound
       * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers
       * @param scene defines the scene the sound belongs to
       * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
       * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
       */
      constructor(name, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {
        var _a;
        this.autoplay = false;
        this._loop = false;
        this.useCustomAttenuation = false;
        this.isPlaying = false;
        this.isPaused = false;
        this.refDistance = 1;
        this.rolloffFactor = 1;
        this.maxDistance = 100;
        this.distanceModel = "linear";
        this.metadata = null;
        this.onEndedObservable = new Observable();
        this._spatialSound = false;
        this._panningModel = "equalpower";
        this._playbackRate = 1;
        this._streaming = false;
        this._startTime = 0;
        this._currentTime = 0;
        this._position = Vector3.Zero();
        this._localDirection = new Vector3(1, 0, 0);
        this._volume = 1;
        this._isReadyToPlay = false;
        this._isDirectional = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._coneOuterGain = 0;
        this._isOutputConnected = false;
        this._urlType = "Unknown";
        this.name = name;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this._scene = scene;
        _Sound._SceneComponentInitialization(scene);
        this._readyToPlayCallback = readyToPlayCallback;
        this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {
          if (currentDistance < maxDistance) {
            return currentVolume * (1 - currentDistance / maxDistance);
          } else {
            return 0;
          }
        };
        if (options) {
          this.autoplay = options.autoplay || false;
          this._loop = options.loop || false;
          if (options.volume !== void 0) {
            this._volume = options.volume;
          }
          this._spatialSound = options.spatialSound ?? false;
          this.maxDistance = options.maxDistance ?? 100;
          this.useCustomAttenuation = options.useCustomAttenuation ?? false;
          this.rolloffFactor = options.rolloffFactor || 1;
          this.refDistance = options.refDistance || 1;
          this.distanceModel = options.distanceModel || "linear";
          this._playbackRate = options.playbackRate || 1;
          this._streaming = options.streaming ?? false;
          this._length = options.length;
          this._offset = options.offset;
        }
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && AbstractEngine.audioEngine.audioContext) {
          this._soundGain = AbstractEngine.audioEngine.audioContext.createGain();
          this._soundGain.gain.value = this._volume;
          this._inputAudioNode = this._soundGain;
          this._outputAudioNode = this._soundGain;
          if (this._spatialSound) {
            this._createSpatialParameters();
          }
          this._scene.mainSoundTrack.addSound(this);
          let validParameter = true;
          if (urlOrArrayBuffer) {
            try {
              if (typeof urlOrArrayBuffer === "string") {
                this._urlType = "String";
                this._url = urlOrArrayBuffer;
              } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
                this._urlType = "ArrayBuffer";
              } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {
                this._urlType = "MediaElement";
              } else if (urlOrArrayBuffer instanceof MediaStream) {
                this._urlType = "MediaStream";
              } else if (urlOrArrayBuffer instanceof AudioBuffer) {
                this._urlType = "AudioBuffer";
              } else if (Array.isArray(urlOrArrayBuffer)) {
                this._urlType = "Array";
              }
              let urls = [];
              let codecSupportedFound = false;
              switch (this._urlType) {
                case "MediaElement":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "MediaStream":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "ArrayBuffer":
                  if (urlOrArrayBuffer.byteLength > 0) {
                    codecSupportedFound = true;
                    this._soundLoaded(urlOrArrayBuffer);
                  }
                  break;
                case "AudioBuffer":
                  this._audioBufferLoaded(urlOrArrayBuffer);
                  break;
                case "String":
                  urls.push(urlOrArrayBuffer);
                // eslint-disable-next-line no-fallthrough
                case "Array":
                  if (urls.length === 0) {
                    urls = urlOrArrayBuffer;
                  }
                  for (let i = 0; i < urls.length; i++) {
                    const url = urls[i];
                    codecSupportedFound = options && options.skipCodecCheck || url.indexOf(".mp3", url.length - 4) !== -1 && AbstractEngine.audioEngine.isMP3supported || url.indexOf(".ogg", url.length - 4) !== -1 && AbstractEngine.audioEngine.isOGGsupported || url.indexOf(".wav", url.length - 4) !== -1 || url.indexOf(".m4a", url.length - 4) !== -1 || url.indexOf(".mp4", url.length - 4) !== -1 || url.indexOf("blob:") !== -1;
                    if (codecSupportedFound) {
                      if (!this._streaming) {
                        this._scene._loadFile(url, (data) => {
                          this._soundLoaded(data);
                        }, void 0, true, true, (exception) => {
                          if (exception) {
                            Logger.Error("XHR " + exception.status + " error on: " + url + ".");
                          }
                          Logger.Error("Sound creation aborted.");
                          this._scene.mainSoundTrack.removeSound(this);
                        });
                      } else {
                        this._htmlAudioElement = new Audio(url);
                        this._htmlAudioElement.controls = false;
                        this._htmlAudioElement.loop = this.loop;
                        Tools.SetCorsBehavior(url, this._htmlAudioElement);
                        this._htmlAudioElement.preload = "auto";
                        this._htmlAudioElement.addEventListener("canplaythrough", () => {
                          this._isReadyToPlay = true;
                          if (this.autoplay) {
                            this.play(0, this._offset, this._length);
                          }
                          if (this._readyToPlayCallback) {
                            this._readyToPlayCallback();
                          }
                        }, { once: true });
                        document.body.appendChild(this._htmlAudioElement);
                        this._htmlAudioElement.load();
                      }
                      break;
                    }
                  }
                  break;
                default:
                  validParameter = false;
                  break;
              }
              if (!validParameter) {
                Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
              } else {
                if (!codecSupportedFound) {
                  this._isReadyToPlay = true;
                  if (this._readyToPlayCallback) {
                    setTimeout(() => {
                      if (this._readyToPlayCallback) {
                        this._readyToPlayCallback();
                      }
                    }, 1e3);
                  }
                }
              }
            } catch (ex) {
              Logger.Error("Unexpected error. Sound creation aborted.");
              this._scene.mainSoundTrack.removeSound(this);
            }
          }
        } else {
          this._scene.mainSoundTrack.addSound(this);
          if (AbstractEngine.audioEngine && !AbstractEngine.audioEngine.WarnedWebAudioUnsupported) {
            Logger.Error("Web Audio is not supported by your browser.");
            AbstractEngine.audioEngine.WarnedWebAudioUnsupported = true;
          }
          if (this._readyToPlayCallback) {
            setTimeout(() => {
              if (this._readyToPlayCallback) {
                this._readyToPlayCallback();
              }
            }, 1e3);
          }
        }
      }
      /**
       * Release the sound and its associated resources
       */
      dispose() {
        var _a;
        if ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
          if (this.isPlaying) {
            this.stop();
          }
          this._isReadyToPlay = false;
          if (this.soundTrackId === -1) {
            this._scene.mainSoundTrack.removeSound(this);
          } else if (this._scene.soundTracks) {
            this._scene.soundTracks[this.soundTrackId].removeSound(this);
          }
          if (this._soundGain) {
            this._soundGain.disconnect();
            this._soundGain = null;
          }
          if (this._soundPanner) {
            this._soundPanner.disconnect();
            this._soundPanner = null;
          }
          if (this._soundSource) {
            this._soundSource.disconnect();
            this._soundSource = null;
          }
          this._audioBuffer = null;
          if (this._htmlAudioElement) {
            this._htmlAudioElement.pause();
            this._htmlAudioElement.src = "";
            document.body.removeChild(this._htmlAudioElement);
            this._htmlAudioElement = null;
          }
          if (this._streamingSource) {
            this._streamingSource.disconnect();
            this._streamingSource = null;
          }
          if (this._connectedTransformNode && this._registerFunc) {
            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
            this._connectedTransformNode = null;
          }
          this._clearTimeoutsAndObservers();
        }
      }
      /**
       * Gets if the sounds is ready to be played or not.
       * @returns true if ready, otherwise false
       */
      isReady() {
        return this._isReadyToPlay;
      }
      /**
       * Get the current class name.
       * @returns current class name
       */
      getClassName() {
        return "Sound";
      }
      _audioBufferLoaded(buffer) {
        var _a;
        if (!((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.audioContext)) {
          return;
        }
        this._audioBuffer = buffer;
        this._isReadyToPlay = true;
        if (this.autoplay) {
          this.play(0, this._offset, this._length);
        }
        if (this._readyToPlayCallback) {
          this._readyToPlayCallback();
        }
      }
      _soundLoaded(audioData) {
        var _a;
        if (!((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.audioContext)) {
          return;
        }
        AbstractEngine.audioEngine.audioContext.decodeAudioData(audioData, (buffer) => {
          this._audioBufferLoaded(buffer);
        }, (err) => {
          Logger.Error("Error while decoding audio data for: " + this.name + " / Error: " + err);
        });
      }
      /**
       * Sets the data of the sound from an audiobuffer
       * @param audioBuffer The audioBuffer containing the data
       */
      setAudioBuffer(audioBuffer) {
        var _a;
        if ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
          this._audioBuffer = audioBuffer;
          this._isReadyToPlay = true;
        }
      }
      /**
       * Updates the current sounds options such as maxdistance, loop...
       * @param options A JSON object containing values named as the object properties
       */
      updateOptions(options) {
        if (options) {
          this.loop = options.loop ?? this.loop;
          this.maxDistance = options.maxDistance ?? this.maxDistance;
          this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;
          this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;
          this.refDistance = options.refDistance ?? this.refDistance;
          this.distanceModel = options.distanceModel ?? this.distanceModel;
          this._playbackRate = options.playbackRate ?? this._playbackRate;
          this._length = options.length ?? void 0;
          this.spatialSound = options.spatialSound ?? this._spatialSound;
          this._setOffset(options.offset ?? void 0);
          this.setVolume(options.volume ?? this._volume);
          this._updateSpatialParameters();
          if (this.isPlaying) {
            if (this._streaming && this._htmlAudioElement) {
              this._htmlAudioElement.playbackRate = this._playbackRate;
              if (this._htmlAudioElement.loop !== this.loop) {
                this._htmlAudioElement.loop = this.loop;
              }
            } else {
              if (this._soundSource) {
                this._soundSource.playbackRate.value = this._playbackRate;
                if (this._soundSource.loop !== this.loop) {
                  this._soundSource.loop = this.loop;
                }
                if (this._offset !== void 0 && this._soundSource.loopStart !== this._offset) {
                  this._soundSource.loopStart = this._offset;
                }
                if (this._length !== void 0 && this._length !== this._soundSource.loopEnd) {
                  this._soundSource.loopEnd = (this._offset | 0) + this._length;
                }
              }
            }
          }
        }
      }
      _createSpatialParameters() {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && AbstractEngine.audioEngine.audioContext) {
          if (this._scene.headphone) {
            this._panningModel = "HRTF";
          }
          this._soundPanner = this._soundPanner ?? AbstractEngine.audioEngine.audioContext.createPanner();
          if (this._soundPanner && this._outputAudioNode) {
            this._updateSpatialParameters();
            this._soundPanner.connect(this._outputAudioNode);
            this._inputAudioNode = this._soundPanner;
          }
        }
      }
      _disableSpatialSound() {
        var _a;
        if (!this._spatialSound) {
          return;
        }
        this._inputAudioNode = this._soundGain;
        (_a = this._soundPanner) == null ? void 0 : _a.disconnect();
        this._soundPanner = null;
        this._spatialSound = false;
      }
      _updateSpatialParameters() {
        if (!this._spatialSound) {
          return;
        }
        if (this._soundPanner) {
          if (this.useCustomAttenuation) {
            this._soundPanner.distanceModel = "linear";
            this._soundPanner.maxDistance = Number.MAX_VALUE;
            this._soundPanner.refDistance = 1;
            this._soundPanner.rolloffFactor = 1;
            this._soundPanner.panningModel = this._panningModel;
          } else {
            this._soundPanner.distanceModel = this.distanceModel;
            this._soundPanner.maxDistance = this.maxDistance;
            this._soundPanner.refDistance = this.refDistance;
            this._soundPanner.rolloffFactor = this.rolloffFactor;
            this._soundPanner.panningModel = this._panningModel;
          }
        } else {
          this._createSpatialParameters();
        }
      }
      /**
       * Switch the panning model to HRTF:
       * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      switchPanningModelToHRTF() {
        this._panningModel = "HRTF";
        this._switchPanningModel();
      }
      /**
       * Switch the panning model to Equal Power:
       * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      switchPanningModelToEqualPower() {
        this._panningModel = "equalpower";
        this._switchPanningModel();
      }
      _switchPanningModel() {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
          this._soundPanner.panningModel = this._panningModel;
        }
      }
      /**
       * Connect this sound to a sound track audio node like gain...
       * @param soundTrackAudioNode the sound track audio node to connect to
       */
      connectToSoundTrackAudioNode(soundTrackAudioNode) {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          if (this._isOutputConnected) {
            this._outputAudioNode.disconnect();
          }
          this._outputAudioNode.connect(soundTrackAudioNode);
          this._isOutputConnected = true;
        }
      }
      /**
       * Transform this sound into a directional source
       * @param coneInnerAngle Size of the inner cone in degree
       * @param coneOuterAngle Size of the outer cone in degree
       * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
       */
      setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        if (coneOuterAngle < coneInnerAngle) {
          Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneInnerAngle = coneInnerAngle;
        this._coneOuterAngle = coneOuterAngle;
        this._coneOuterGain = coneOuterGain;
        this._isDirectional = true;
        if (this.isPlaying && this.loop) {
          this.stop();
          this.play(0, this._offset, this._length);
        }
      }
      /**
       * Gets or sets the inner angle for the directional cone.
       */
      get directionalConeInnerAngle() {
        return this._coneInnerAngle;
      }
      /**
       * Gets or sets the inner angle for the directional cone.
       */
      set directionalConeInnerAngle(value) {
        var _a;
        if (value != this._coneInnerAngle) {
          if (this._coneOuterAngle < value) {
            Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneInnerAngle = value;
          if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
            this._soundPanner.coneInnerAngle = this._coneInnerAngle;
          }
        }
      }
      /**
       * Gets or sets the outer angle for the directional cone.
       */
      get directionalConeOuterAngle() {
        return this._coneOuterAngle;
      }
      /**
       * Gets or sets the outer angle for the directional cone.
       */
      set directionalConeOuterAngle(value) {
        var _a;
        if (value != this._coneOuterAngle) {
          if (value < this._coneInnerAngle) {
            Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneOuterAngle = value;
          if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
            this._soundPanner.coneOuterAngle = this._coneOuterAngle;
          }
        }
      }
      /**
       * Sets the position of the emitter if spatial sound is enabled
       * @param newPosition Defines the new position
       */
      setPosition(newPosition) {
        var _a;
        if (newPosition.equals(this._position)) {
          return;
        }
        this._position.copyFrom(newPosition);
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
          this._soundPanner.positionX.value = this._position.x;
          this._soundPanner.positionY.value = this._position.y;
          this._soundPanner.positionZ.value = this._position.z;
        }
      }
      /**
       * Sets the local direction of the emitter if spatial sound is enabled
       * @param newLocalDirection Defines the new local direction
       */
      setLocalDirectionToMesh(newLocalDirection) {
        var _a;
        this._localDirection = newLocalDirection;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {
          this._updateDirection();
        }
      }
      _updateDirection() {
        if (!this._connectedTransformNode || !this._soundPanner) {
          return;
        }
        const mat = this._connectedTransformNode.getWorldMatrix();
        const direction = Vector3.TransformNormal(this._localDirection, mat);
        direction.normalize();
        this._soundPanner.orientationX.value = direction.x;
        this._soundPanner.orientationY.value = direction.y;
        this._soundPanner.orientationZ.value = direction.z;
      }
      /** @internal */
      updateDistanceFromListener() {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
          const distance = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
          this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
        }
      }
      /**
       * Sets a new custom attenuation function for the sound.
       * @param callback Defines the function used for the attenuation
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function
       */
      setAttenuationFunction(callback) {
        this._customAttenuationFunction = callback;
      }
      /**
       * Play the sound
       * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
       * @param offset (optional) Start the sound at a specific time in seconds
       * @param length (optional) Sound duration (in seconds)
       */
      play(time, offset, length) {
        var _a, _b, _c, _d;
        if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.audioContext)) {
          try {
            this._clearTimeoutsAndObservers();
            let startTime = time ? ((_b = AbstractEngine.audioEngine) == null ? void 0 : _b.audioContext.currentTime) + time : (_c = AbstractEngine.audioEngine) == null ? void 0 : _c.audioContext.currentTime;
            if (!this._soundSource || !this._streamingSource) {
              if (this._spatialSound && this._soundPanner) {
                if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
                  this._soundPanner.positionX.value = this._position.x;
                  this._soundPanner.positionY.value = this._position.y;
                  this._soundPanner.positionZ.value = this._position.z;
                }
                if (this._isDirectional) {
                  this._soundPanner.coneInnerAngle = this._coneInnerAngle;
                  this._soundPanner.coneOuterAngle = this._coneOuterAngle;
                  this._soundPanner.coneOuterGain = this._coneOuterGain;
                  if (this._connectedTransformNode) {
                    this._updateDirection();
                  } else {
                    this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);
                  }
                }
              }
            }
            if (this._streaming) {
              if (!this._streamingSource && this._htmlAudioElement) {
                this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);
                this._htmlAudioElement.onended = () => {
                  this._onended();
                };
                this._htmlAudioElement.playbackRate = this._playbackRate;
              }
              if (this._streamingSource) {
                this._streamingSource.disconnect();
                if (this._inputAudioNode) {
                  this._streamingSource.connect(this._inputAudioNode);
                }
              }
              if (this._htmlAudioElement) {
                const tryToPlay = () => {
                  var _a2, _b2;
                  if ((_a2 = AbstractEngine.audioEngine) == null ? void 0 : _a2.unlocked) {
                    if (!this._htmlAudioElement) {
                      return;
                    }
                    this._htmlAudioElement.currentTime = offset ?? 0;
                    const playPromise = this._htmlAudioElement.play();
                    if (playPromise !== void 0) {
                      playPromise.catch(() => {
                        var _a3, _b3;
                        (_a3 = AbstractEngine.audioEngine) == null ? void 0 : _a3.lock();
                        if (this.loop || this.autoplay) {
                          this._audioUnlockedObserver = (_b3 = AbstractEngine.audioEngine) == null ? void 0 : _b3.onAudioUnlockedObservable.addOnce(() => {
                            tryToPlay();
                          });
                        }
                      });
                    }
                  } else {
                    if (this.loop || this.autoplay) {
                      this._audioUnlockedObserver = (_b2 = AbstractEngine.audioEngine) == null ? void 0 : _b2.onAudioUnlockedObservable.addOnce(() => {
                        tryToPlay();
                      });
                    }
                  }
                };
                tryToPlay();
              }
            } else {
              const tryToPlay = () => {
                var _a2, _b2, _c2;
                if ((_a2 = AbstractEngine.audioEngine) == null ? void 0 : _a2.audioContext) {
                  length = length || this._length;
                  if (offset !== void 0) {
                    this._setOffset(offset);
                  }
                  if (this._soundSource) {
                    const oldSource = this._soundSource;
                    oldSource.onended = () => {
                      oldSource.disconnect();
                    };
                  }
                  this._soundSource = (_b2 = AbstractEngine.audioEngine) == null ? void 0 : _b2.audioContext.createBufferSource();
                  if (this._soundSource && this._inputAudioNode) {
                    this._soundSource.buffer = this._audioBuffer;
                    this._soundSource.connect(this._inputAudioNode);
                    this._soundSource.loop = this.loop;
                    if (offset !== void 0) {
                      this._soundSource.loopStart = offset;
                    }
                    if (length !== void 0) {
                      this._soundSource.loopEnd = (offset | 0) + length;
                    }
                    this._soundSource.playbackRate.value = this._playbackRate;
                    this._soundSource.onended = () => {
                      this._onended();
                    };
                    startTime = time ? ((_c2 = AbstractEngine.audioEngine) == null ? void 0 : _c2.audioContext.currentTime) + time : AbstractEngine.audioEngine.audioContext.currentTime;
                    const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer.duration;
                    this._soundSource.start(startTime, actualOffset, this.loop ? void 0 : length);
                  }
                }
              };
              if (((_d = AbstractEngine.audioEngine) == null ? void 0 : _d.audioContext.state) === "suspended") {
                this._tryToPlayTimeout = setTimeout(() => {
                  var _a2;
                  if (((_a2 = AbstractEngine.audioEngine) == null ? void 0 : _a2.audioContext.state) === "suspended") {
                    AbstractEngine.audioEngine.lock();
                    if (this.loop || this.autoplay) {
                      this._audioUnlockedObserver = AbstractEngine.audioEngine.onAudioUnlockedObservable.addOnce(() => {
                        tryToPlay();
                      });
                    }
                  } else {
                    tryToPlay();
                  }
                }, 500);
              } else {
                tryToPlay();
              }
            }
            this._startTime = startTime;
            this.isPlaying = true;
            this.isPaused = false;
          } catch (ex) {
            Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
          }
        }
      }
      _onended() {
        this.isPlaying = false;
        this._startTime = 0;
        this._currentTime = 0;
        if (this.onended) {
          this.onended();
        }
        this.onEndedObservable.notifyObservers(this);
      }
      /**
       * Stop the sound
       * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
       */
      stop(time) {
        var _a, _b;
        if (this.isPlaying) {
          this._clearTimeoutsAndObservers();
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
              if (this._htmlAudioElement.currentTime > 0) {
                this._htmlAudioElement.currentTime = 0;
              }
            } else {
              (_a = this._streamingSource) == null ? void 0 : _a.disconnect();
            }
            this.isPlaying = false;
          } else if (((_b = AbstractEngine.audioEngine) == null ? void 0 : _b.audioContext) && this._soundSource) {
            const stopTime = time ? AbstractEngine.audioEngine.audioContext.currentTime + time : void 0;
            this._soundSource.onended = () => {
              this.isPlaying = false;
              this.isPaused = false;
              this._startTime = 0;
              this._currentTime = 0;
              if (this._soundSource) {
                this._soundSource.onended = () => void 0;
              }
              this._onended();
            };
            this._soundSource.stop(stopTime);
          } else {
            this.isPlaying = false;
          }
        } else if (this.isPaused) {
          this.isPaused = false;
          this._startTime = 0;
          this._currentTime = 0;
        }
      }
      /**
       * Put the sound in pause
       */
      pause() {
        var _a, _b;
        if (this.isPlaying) {
          this._clearTimeoutsAndObservers();
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
            } else {
              (_a = this._streamingSource) == null ? void 0 : _a.disconnect();
            }
            this.isPlaying = false;
            this.isPaused = true;
          } else if (((_b = AbstractEngine.audioEngine) == null ? void 0 : _b.audioContext) && this._soundSource) {
            this._soundSource.onended = () => void 0;
            this._soundSource.stop();
            this.isPlaying = false;
            this.isPaused = true;
            this._currentTime += AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;
          }
        }
      }
      /**
       * Sets a dedicated volume for this sounds
       * @param newVolume Define the new volume of the sound
       * @param time Define time for gradual change to new volume
       */
      setVolume(newVolume, time) {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._soundGain) {
          if (time && AbstractEngine.audioEngine.audioContext) {
            this._soundGain.gain.cancelScheduledValues(AbstractEngine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, AbstractEngine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.linearRampToValueAtTime(newVolume, AbstractEngine.audioEngine.audioContext.currentTime + time);
          } else {
            this._soundGain.gain.value = newVolume;
          }
        }
        this._volume = newVolume;
      }
      /**
       * Set the sound play back rate
       * @param newPlaybackRate Define the playback rate the sound should be played at
       */
      setPlaybackRate(newPlaybackRate) {
        this._playbackRate = newPlaybackRate;
        if (this.isPlaying) {
          if (this._streaming && this._htmlAudioElement) {
            this._htmlAudioElement.playbackRate = this._playbackRate;
          } else if (this._soundSource) {
            this._soundSource.playbackRate.value = this._playbackRate;
          }
        }
      }
      /**
       * Gets the sound play back rate.
       * @returns the  play back rate of the sound
       */
      getPlaybackRate() {
        return this._playbackRate;
      }
      /**
       * Gets the volume of the sound.
       * @returns the volume of the sound
       */
      getVolume() {
        return this._volume;
      }
      /**
       * Attach the sound to a dedicated mesh
       * @param transformNode The transform node to connect the sound with
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh
       */
      attachToMesh(transformNode) {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
        }
        this._connectedTransformNode = transformNode;
        if (!this._spatialSound) {
          this._spatialSound = true;
          this._createSpatialParameters();
          if (this.isPlaying && this.loop) {
            this.stop();
            this.play(0, this._offset, this._length);
          }
        }
        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
        this._registerFunc = (transformNode2) => this._onRegisterAfterWorldMatrixUpdate(transformNode2);
        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
      }
      /**
       * Detach the sound from the previously attached mesh
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh
       */
      detachFromMesh() {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
          this._connectedTransformNode = null;
        }
      }
      _onRegisterAfterWorldMatrixUpdate(node) {
        var _a;
        if (!node.getBoundingInfo) {
          this.setPosition(node.absolutePosition);
        } else {
          const mesh = node;
          const boundingInfo = mesh.getBoundingInfo();
          this.setPosition(boundingInfo.boundingSphere.centerWorld);
        }
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {
          this._updateDirection();
        }
      }
      /**
       * Clone the current sound in the scene.
       * @returns the new sound clone
       */
      clone() {
        if (!this._streaming) {
          const setBufferAndRun = () => {
            _retryWithInterval(() => this._isReadyToPlay, () => {
              clonedSound._audioBuffer = this.getAudioBuffer();
              clonedSound._isReadyToPlay = true;
              if (clonedSound.autoplay) {
                clonedSound.play(0, this._offset, this._length);
              }
            }, void 0, 300);
          };
          const currentOptions = {
            autoplay: this.autoplay,
            loop: this.loop,
            volume: this._volume,
            spatialSound: this._spatialSound,
            maxDistance: this.maxDistance,
            useCustomAttenuation: this.useCustomAttenuation,
            rolloffFactor: this.rolloffFactor,
            refDistance: this.refDistance,
            distanceModel: this.distanceModel
          };
          const clonedSound = new _Sound(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, currentOptions);
          if (this.useCustomAttenuation) {
            clonedSound.setAttenuationFunction(this._customAttenuationFunction);
          }
          clonedSound.setPosition(this._position);
          clonedSound.setPlaybackRate(this._playbackRate);
          setBufferAndRun();
          return clonedSound;
        } else {
          return null;
        }
      }
      /**
       * Gets the current underlying audio buffer containing the data
       * @returns the audio buffer
       */
      getAudioBuffer() {
        return this._audioBuffer;
      }
      /**
       * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.
       * @returns the source node
       */
      getSoundSource() {
        return this._soundSource;
      }
      /**
       * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.
       * @returns the gain node
       */
      getSoundGain() {
        return this._soundGain;
      }
      /**
       * Serializes the Sound in a JSON representation
       * @returns the JSON representation of the sound
       */
      serialize() {
        const serializationObject = {
          name: this.name,
          url: this._url,
          autoplay: this.autoplay,
          loop: this.loop,
          volume: this._volume,
          spatialSound: this._spatialSound,
          maxDistance: this.maxDistance,
          rolloffFactor: this.rolloffFactor,
          refDistance: this.refDistance,
          distanceModel: this.distanceModel,
          playbackRate: this._playbackRate,
          panningModel: this._panningModel,
          soundTrackId: this.soundTrackId,
          metadata: this.metadata
        };
        if (this._spatialSound) {
          if (this._connectedTransformNode) {
            serializationObject.connectedMeshId = this._connectedTransformNode.id;
          }
          serializationObject.position = this._position.asArray();
          serializationObject.refDistance = this.refDistance;
          serializationObject.distanceModel = this.distanceModel;
          serializationObject.isDirectional = this._isDirectional;
          serializationObject.localDirectionToMesh = this._localDirection.asArray();
          serializationObject.coneInnerAngle = this._coneInnerAngle;
          serializationObject.coneOuterAngle = this._coneOuterAngle;
          serializationObject.coneOuterGain = this._coneOuterGain;
        }
        return serializationObject;
      }
      /**
       * Parse a JSON representation of a sound to instantiate in a given scene
       * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)
       * @param scene Define the scene the new parsed sound should be created in
       * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies
       * @param sourceSound Define a sound place holder if do not need to instantiate a new one
       * @returns the newly parsed sound
       */
      static Parse(parsedSound, scene, rootUrl, sourceSound) {
        const soundName = parsedSound.name;
        let soundUrl;
        if (parsedSound.url) {
          soundUrl = rootUrl + parsedSound.url;
        } else {
          soundUrl = rootUrl + soundName;
        }
        const options = {
          autoplay: parsedSound.autoplay,
          loop: parsedSound.loop,
          volume: parsedSound.volume,
          spatialSound: parsedSound.spatialSound,
          maxDistance: parsedSound.maxDistance,
          rolloffFactor: parsedSound.rolloffFactor,
          refDistance: parsedSound.refDistance,
          distanceModel: parsedSound.distanceModel,
          playbackRate: parsedSound.playbackRate
        };
        let newSound;
        if (!sourceSound) {
          newSound = new _Sound(soundName, soundUrl, scene, () => {
            scene.removePendingData(newSound);
          }, options);
          scene.addPendingData(newSound);
        } else {
          const setBufferAndRun = () => {
            _retryWithInterval(() => sourceSound._isReadyToPlay, () => {
              newSound._audioBuffer = sourceSound.getAudioBuffer();
              newSound._isReadyToPlay = true;
              if (newSound.autoplay) {
                newSound.play(0, newSound._offset, newSound._length);
              }
            }, void 0, 300);
          };
          newSound = new _Sound(soundName, new ArrayBuffer(0), scene, null, options);
          setBufferAndRun();
        }
        if (parsedSound.position) {
          const soundPosition = Vector3.FromArray(parsedSound.position);
          newSound.setPosition(soundPosition);
        }
        if (parsedSound.isDirectional) {
          newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
          if (parsedSound.localDirectionToMesh) {
            const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
            newSound.setLocalDirectionToMesh(localDirectionToMesh);
          }
        }
        if (parsedSound.connectedMeshId) {
          const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);
          if (connectedMesh) {
            newSound.attachToMesh(connectedMesh);
          }
        }
        if (parsedSound.metadata) {
          newSound.metadata = parsedSound.metadata;
        }
        return newSound;
      }
      _setOffset(value) {
        if (this._offset === value) {
          return;
        }
        if (this.isPaused) {
          this.stop();
          this.isPaused = false;
        }
        this._offset = value;
      }
      _clearTimeoutsAndObservers() {
        var _a;
        if (this._tryToPlayTimeout) {
          clearTimeout(this._tryToPlayTimeout);
          this._tryToPlayTimeout = null;
        }
        if (this._audioUnlockedObserver) {
          (_a = AbstractEngine.audioEngine) == null ? void 0 : _a.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);
          this._audioUnlockedObserver = null;
        }
      }
    };
    Sound._SceneComponentInitialization = (_) => {
      throw _WarnImport("AudioSceneComponent");
    };
    RegisterClass("BABYLON.Sound", Sound);
  }
});

// node_modules/@babylonjs/core/Audio/soundTrack.js
var SoundTrack;
var init_soundTrack = __esm({
  "node_modules/@babylonjs/core/Audio/soundTrack.js"() {
    init_engineStore();
    init_abstractEngine();
    SoundTrack = class {
      /**
       * Creates a new sound track.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks
       * @param scene Define the scene the sound track belongs to
       * @param options
       */
      constructor(scene, options = {}) {
        this.id = -1;
        this._isInitialized = false;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this._scene = scene;
        this.soundCollection = [];
        this._options = options;
        if (!this._options.mainTrack && this._scene.soundTracks) {
          this._scene.soundTracks.push(this);
          this.id = this._scene.soundTracks.length - 1;
        }
      }
      _initializeSoundTrackAudioGraph() {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && AbstractEngine.audioEngine.audioContext) {
          this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();
          this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);
          if (this._options) {
            if (this._options.volume) {
              this._outputAudioNode.gain.value = this._options.volume;
            }
          }
          this._isInitialized = true;
        }
      }
      /**
       * Release the sound track and its associated resources
       */
      dispose() {
        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {
          if (this._connectedAnalyser) {
            this._connectedAnalyser.stopDebugCanvas();
          }
          while (this.soundCollection.length) {
            this.soundCollection[0].dispose();
          }
          if (this._outputAudioNode) {
            this._outputAudioNode.disconnect();
          }
          this._outputAudioNode = null;
        }
      }
      /**
       * Adds a sound to this sound track
       * @param sound define the sound to add
       * @ignoreNaming
       */
      addSound(sound) {
        var _a;
        if (!this._isInitialized) {
          this._initializeSoundTrackAudioGraph();
        }
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          sound.connectToSoundTrackAudioNode(this._outputAudioNode);
        }
        if (sound.soundTrackId !== void 0) {
          if (sound.soundTrackId === -1) {
            this._scene.mainSoundTrack.removeSound(sound);
          } else if (this._scene.soundTracks) {
            this._scene.soundTracks[sound.soundTrackId].removeSound(sound);
          }
        }
        this.soundCollection.push(sound);
        sound.soundTrackId = this.id;
      }
      /**
       * Removes a sound to this sound track
       * @param sound define the sound to remove
       * @ignoreNaming
       */
      removeSound(sound) {
        const index = this.soundCollection.indexOf(sound);
        if (index !== -1) {
          this.soundCollection.splice(index, 1);
        }
      }
      /**
       * Set a global volume for the full sound track.
       * @param newVolume Define the new volume of the sound track
       */
      setVolume(newVolume) {
        var _a;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          this._outputAudioNode.gain.value = newVolume;
        }
      }
      /**
       * Switch the panning model to HRTF:
       * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      switchPanningModelToHRTF() {
        var _a;
        if ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
          for (let i = 0; i < this.soundCollection.length; i++) {
            this.soundCollection[i].switchPanningModelToHRTF();
          }
        }
      }
      /**
       * Switch the panning model to Equal Power:
       * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
       */
      switchPanningModelToEqualPower() {
        var _a;
        if ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
          for (let i = 0; i < this.soundCollection.length; i++) {
            this.soundCollection[i].switchPanningModelToEqualPower();
          }
        }
      }
      /**
       * Connect the sound track to an audio analyser allowing some amazing
       * synchronization between the sounds/music and your visualization (VuMeter for instance).
       * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser
       * @param analyser The analyser to connect to the engine
       */
      connectToAnalyser(analyser) {
        var _a;
        if (this._connectedAnalyser) {
          this._connectedAnalyser.stopDebugCanvas();
        }
        this._connectedAnalyser = analyser;
        if (((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          this._outputAudioNode.disconnect();
          this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Loading/Plugins/babylonFileParser.function.js
function AddParser(name, parser) {
  _BabylonFileParsers[name] = parser;
}
function GetParser(name) {
  if (_BabylonFileParsers[name]) {
    return _BabylonFileParsers[name];
  }
  return null;
}
function AddIndividualParser(name, parser) {
  _IndividualBabylonFileParsers[name] = parser;
}
function GetIndividualParser(name) {
  if (_IndividualBabylonFileParsers[name]) {
    return _IndividualBabylonFileParsers[name];
  }
  return null;
}
function Parse(jsonData, scene, container, rootUrl) {
  for (const parserName in _BabylonFileParsers) {
    if (Object.prototype.hasOwnProperty.call(_BabylonFileParsers, parserName)) {
      _BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
    }
  }
}
var _BabylonFileParsers, _IndividualBabylonFileParsers;
var init_babylonFileParser_function = __esm({
  "node_modules/@babylonjs/core/Loading/Plugins/babylonFileParser.function.js"() {
    _BabylonFileParsers = {};
    _IndividualBabylonFileParsers = {};
  }
});

// node_modules/@babylonjs/core/Audio/audioSceneComponent.js
var AudioSceneComponent;
var init_audioSceneComponent = __esm({
  "node_modules/@babylonjs/core/Audio/audioSceneComponent.js"() {
    init_sound();
    init_soundTrack();
    init_math_vector();
    init_sceneComponent();
    init_scene();
    init_audioEngine();
    init_precisionDate();
    init_engineStore();
    init_abstractEngine();
    init_babylonFileParser_function();
    AddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {
      var _a;
      let loadedSounds = [];
      let loadedSound;
      container.sounds = container.sounds || [];
      if (parsedData.sounds !== void 0 && parsedData.sounds !== null) {
        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {
          const parsedSound = parsedData.sounds[index];
          if ((_a = AbstractEngine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
            if (!parsedSound.url) {
              parsedSound.url = parsedSound.name;
            }
            if (!loadedSounds[parsedSound.url]) {
              loadedSound = Sound.Parse(parsedSound, scene, rootUrl);
              loadedSounds[parsedSound.url] = loadedSound;
              container.sounds.push(loadedSound);
            } else {
              container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));
            }
          } else {
            container.sounds.push(new Sound(parsedSound.name, null, scene));
          }
        }
      }
      loadedSounds = [];
    });
    Object.defineProperty(Scene.prototype, "mainSoundTrack", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        if (!this._mainSoundTrack) {
          this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });
        }
        return this._mainSoundTrack;
      },
      enumerable: true,
      configurable: true
    });
    Scene.prototype.getSoundByName = function(name) {
      let index;
      for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {
        if (this.mainSoundTrack.soundCollection[index].name === name) {
          return this.mainSoundTrack.soundCollection[index];
        }
      }
      if (this.soundTracks) {
        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {
          for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {
            if (this.soundTracks[sdIndex].soundCollection[index].name === name) {
              return this.soundTracks[sdIndex].soundCollection[index];
            }
          }
        }
      }
      return null;
    };
    Object.defineProperty(Scene.prototype, "audioEnabled", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        return compo.audioEnabled;
      },
      set: function(value) {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        if (value) {
          compo.enableAudio();
        } else {
          compo.disableAudio();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scene.prototype, "headphone", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        return compo.headphone;
      },
      set: function(value) {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        if (value) {
          compo.switchAudioModeForHeadphones();
        } else {
          compo.switchAudioModeForNormalSpeakers();
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scene.prototype, "audioListenerPositionProvider", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        return compo.audioListenerPositionProvider;
      },
      set: function(value) {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        if (value && typeof value !== "function") {
          throw new Error("The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3");
        } else {
          compo.audioListenerPositionProvider = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scene.prototype, "audioListenerRotationProvider", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        return compo.audioListenerRotationProvider;
      },
      set: function(value) {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        if (value && typeof value !== "function") {
          throw new Error("The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3");
        } else {
          compo.audioListenerRotationProvider = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scene.prototype, "audioPositioningRefreshRate", {
      get: function() {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        return compo.audioPositioningRefreshRate;
      },
      set: function(value) {
        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);
        if (!compo) {
          compo = new AudioSceneComponent(this);
          this._addComponent(compo);
        }
        compo.audioPositioningRefreshRate = value;
      },
      enumerable: true,
      configurable: true
    });
    AudioSceneComponent = class _AudioSceneComponent {
      /**
       * Gets whether audio is enabled or not.
       * Please use related enable/disable method to switch state.
       */
      get audioEnabled() {
        return this._audioEnabled;
      }
      /**
       * Gets whether audio is outputting to headphone or not.
       * Please use the according Switch methods to change output.
       */
      get headphone() {
        return this._headphone;
      }
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_AUDIO;
        this._audioEnabled = true;
        this._headphone = false;
        this.audioPositioningRefreshRate = 500;
        this.audioListenerPositionProvider = null;
        this.audioListenerRotationProvider = null;
        this._cachedCameraDirection = new Vector3();
        this._cachedCameraPosition = new Vector3();
        this._lastCheck = 0;
        this._invertMatrixTemp = new Matrix();
        this._cameraDirectionTemp = new Vector3();
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this.scene = scene;
        scene.soundTracks = [];
        scene.sounds = [];
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Serializes the component data to the specified json object
       * @param serializationObject The object to serialize to
       */
      serialize(serializationObject) {
        serializationObject.sounds = [];
        if (this.scene.soundTracks) {
          for (let index = 0; index < this.scene.soundTracks.length; index++) {
            const soundtrack = this.scene.soundTracks[index];
            for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {
              serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());
            }
          }
        }
      }
      /**
       * Adds all the elements from the container to the scene
       * @param container the container holding the elements
       */
      addFromContainer(container) {
        if (!container.sounds) {
          return;
        }
        container.sounds.forEach((sound) => {
          sound.play();
          sound.autoplay = true;
          this.scene.mainSoundTrack.addSound(sound);
        });
      }
      /**
       * Removes all the elements in the container from the scene
       * @param container contains the elements to remove
       * @param dispose if the removed element should be disposed (default: false)
       */
      removeFromContainer(container, dispose = false) {
        if (!container.sounds) {
          return;
        }
        container.sounds.forEach((sound) => {
          sound.stop();
          sound.autoplay = false;
          this.scene.mainSoundTrack.removeSound(sound);
          if (dispose) {
            sound.dispose();
          }
        });
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        const scene = this.scene;
        if (scene._mainSoundTrack) {
          scene.mainSoundTrack.dispose();
        }
        if (scene.soundTracks) {
          for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {
            scene.soundTracks[scIndex].dispose();
          }
        }
      }
      /**
       * Disables audio in the associated scene.
       */
      disableAudio() {
        const scene = this.scene;
        this._audioEnabled = false;
        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {
          AbstractEngine.audioEngine.audioContext.suspend();
        }
        let i;
        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
          scene.mainSoundTrack.soundCollection[i].pause();
        }
        if (scene.soundTracks) {
          for (i = 0; i < scene.soundTracks.length; i++) {
            for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
              scene.soundTracks[i].soundCollection[j].pause();
            }
          }
        }
      }
      /**
       * Enables audio in the associated scene.
       */
      enableAudio() {
        const scene = this.scene;
        this._audioEnabled = true;
        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {
          AbstractEngine.audioEngine.audioContext.resume();
        }
        let i;
        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
          if (scene.mainSoundTrack.soundCollection[i].isPaused) {
            scene.mainSoundTrack.soundCollection[i].play();
          }
        }
        if (scene.soundTracks) {
          for (i = 0; i < scene.soundTracks.length; i++) {
            for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
              if (scene.soundTracks[i].soundCollection[j].isPaused) {
                scene.soundTracks[i].soundCollection[j].play();
              }
            }
          }
        }
      }
      /**
       * Switch audio to headphone output.
       */
      switchAudioModeForHeadphones() {
        const scene = this.scene;
        this._headphone = true;
        scene.mainSoundTrack.switchPanningModelToHRTF();
        if (scene.soundTracks) {
          for (let i = 0; i < scene.soundTracks.length; i++) {
            scene.soundTracks[i].switchPanningModelToHRTF();
          }
        }
      }
      /**
       * Switch audio to normal speakers.
       */
      switchAudioModeForNormalSpeakers() {
        const scene = this.scene;
        this._headphone = false;
        scene.mainSoundTrack.switchPanningModelToEqualPower();
        if (scene.soundTracks) {
          for (let i = 0; i < scene.soundTracks.length; i++) {
            scene.soundTracks[i].switchPanningModelToEqualPower();
          }
        }
      }
      _afterRender() {
        const now = PrecisionDate.Now;
        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {
          return;
        }
        this._lastCheck = now;
        const scene = this.scene;
        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1) {
          return;
        }
        const audioEngine = AbstractEngine.audioEngine;
        if (!audioEngine) {
          return;
        }
        if (audioEngine.audioContext) {
          let listeningCamera = scene.activeCamera;
          if (scene.activeCameras && scene.activeCameras.length > 0) {
            listeningCamera = scene.activeCameras[0];
          }
          if (this.audioListenerPositionProvider) {
            const position = this.audioListenerPositionProvider();
            audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);
          } else if (listeningCamera) {
            if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {
              this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);
              audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);
            }
          } else {
            audioEngine.audioContext.listener.setPosition(0, 0, 0);
          }
          if (this.audioListenerRotationProvider) {
            const rotation = this.audioListenerRotationProvider();
            audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);
          } else if (listeningCamera) {
            if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {
              listeningCamera = listeningCamera.rigCameras[0];
            }
            listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);
            Vector3.TransformNormalToRef(_AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);
            this._cameraDirectionTemp.normalize();
            if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {
              if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {
                this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);
                audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);
              }
            }
          } else {
            audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);
          }
          let i;
          for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {
            const sound = scene.mainSoundTrack.soundCollection[i];
            if (sound.useCustomAttenuation) {
              sound.updateDistanceFromListener();
            }
          }
          if (scene.soundTracks) {
            for (i = 0; i < scene.soundTracks.length; i++) {
              for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {
                const sound = scene.soundTracks[i].soundCollection[j];
                if (sound.useCustomAttenuation) {
                  sound.updateDistanceFromListener();
                }
              }
            }
          }
        }
      }
    };
    AudioSceneComponent._CameraDirection = new Vector3(0, 0, -1);
    Sound._SceneComponentInitialization = (scene) => {
      let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);
      if (!compo) {
        compo = new AudioSceneComponent(scene);
        scene._addComponent(compo);
      }
    };
  }
});

// node_modules/@babylonjs/core/Audio/weightedsound.js
var WeightedSound;
var init_weightedsound = __esm({
  "node_modules/@babylonjs/core/Audio/weightedsound.js"() {
    init_logger();
    WeightedSound = class {
      /**
       * Creates a new WeightedSound from the list of sounds given.
       * @param loop When true a Sound will be selected and played when the current playing Sound completes.
       * @param sounds Array of Sounds that will be selected from.
       * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1
       */
      constructor(loop, sounds, weights) {
        this.loop = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._volume = 1;
        this.isPlaying = false;
        this.isPaused = false;
        this._sounds = [];
        this._weights = [];
        if (sounds.length !== weights.length) {
          throw new Error("Sounds length does not equal weights length");
        }
        this.loop = loop;
        this._weights = weights;
        let weightSum = 0;
        for (const weight of weights) {
          weightSum += weight;
        }
        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;
        for (let i = 0; i < this._weights.length; i++) {
          this._weights[i] *= invWeightSum;
        }
        this._sounds = sounds;
        for (const sound of this._sounds) {
          sound.onEndedObservable.add(() => {
            this._onended();
          });
        }
      }
      /**
       * The size of cone in degrees for a directional sound in which there will be no attenuation.
       */
      get directionalConeInnerAngle() {
        return this._coneInnerAngle;
      }
      /**
       * The size of cone in degrees for a directional sound in which there will be no attenuation.
       */
      set directionalConeInnerAngle(value) {
        if (value !== this._coneInnerAngle) {
          if (this._coneOuterAngle < value) {
            Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneInnerAngle = value;
          for (const sound of this._sounds) {
            sound.directionalConeInnerAngle = value;
          }
        }
      }
      /**
       * Size of cone in degrees for a directional sound outside of which there will be no sound.
       * Listener angles between innerAngle and outerAngle will falloff linearly.
       */
      get directionalConeOuterAngle() {
        return this._coneOuterAngle;
      }
      /**
       * Size of cone in degrees for a directional sound outside of which there will be no sound.
       * Listener angles between innerAngle and outerAngle will falloff linearly.
       */
      set directionalConeOuterAngle(value) {
        if (value !== this._coneOuterAngle) {
          if (value < this._coneInnerAngle) {
            Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneOuterAngle = value;
          for (const sound of this._sounds) {
            sound.directionalConeOuterAngle = value;
          }
        }
      }
      /**
       * Playback volume.
       */
      get volume() {
        return this._volume;
      }
      /**
       * Playback volume.
       */
      set volume(value) {
        if (value !== this._volume) {
          for (const sound of this._sounds) {
            sound.setVolume(value);
          }
        }
      }
      _onended() {
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].autoplay = false;
        }
        if (this.loop && this.isPlaying) {
          this.play();
        } else {
          this.isPlaying = false;
        }
      }
      /**
       * Suspend playback
       */
      pause() {
        if (this.isPlaying) {
          this.isPaused = true;
          if (this._currentIndex !== void 0) {
            this._sounds[this._currentIndex].pause();
          }
        }
      }
      /**
       * Stop playback
       */
      stop() {
        this.isPlaying = false;
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].stop();
        }
      }
      /**
       * Start playback.
       * @param startOffset Position the clip head at a specific time in seconds.
       */
      play(startOffset) {
        if (!this.isPaused) {
          this.stop();
          const randomValue = Math.random();
          let total = 0;
          for (let i = 0; i < this._weights.length; i++) {
            total += this._weights[i];
            if (randomValue <= total) {
              this._currentIndex = i;
              break;
            }
          }
        }
        const sound = this._sounds[this._currentIndex ?? 0];
        if (sound.isReady()) {
          sound.play(0, this.isPaused ? void 0 : startOffset);
        } else {
          sound.autoplay = true;
        }
        this.isPlaying = true;
        this.isPaused = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "node_modules/@babylonjs/core/Bones/skeleton.js"() {
    init_bone();
    init_observable();
    init_math_vector();
    init_rawTexture();
    init_animation();
    init_animationRange();
    init_engineStore();
    init_logger();
    init_deepCopier();
    Skeleton = class _Skeleton {
      /**
       * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).
       * Please note that this option is not available if the hardware does not support it
       */
      get useTextureToStoreBoneMatrices() {
        return this._useTextureToStoreBoneMatrices;
      }
      set useTextureToStoreBoneMatrices(value) {
        this._useTextureToStoreBoneMatrices = value;
        this._markAsDirty();
      }
      /**
       * Gets or sets the animation properties override
       */
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      /**
       * Gets a boolean indicating that the skeleton effectively stores matrices into a texture
       */
      get isUsingTextureForMatrices() {
        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
      }
      /**
       * Gets the unique ID of this skeleton
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Creates a new skeleton
       * @param name defines the skeleton name
       * @param id defines the skeleton Id
       * @param scene defines the hosting scene
       */
      constructor(name, id, scene) {
        this.name = name;
        this.id = id;
        this.bones = [];
        this.needInitialSkinMatrix = false;
        this._isDirty = true;
        this._meshesWithPoseMatrix = new Array();
        this._identity = Matrix.Identity();
        this._currentRenderId = -1;
        this._ranges = {};
        this._absoluteTransformIsDirty = true;
        this._canUseTextureForBones = false;
        this._uniqueId = 0;
        this._numBonesWithLinkedTransformNode = 0;
        this._hasWaitingData = null;
        this._parentContainer = null;
        this.doNotSerialize = false;
        this._useTextureToStoreBoneMatrices = true;
        this._animationPropertiesOverride = null;
        this.onBeforeComputeObservable = new Observable();
        this.bones = [];
        this._scene = scene || EngineStore.LastCreatedScene;
        this._uniqueId = this._scene.getUniqueId();
        this._scene.addSkeleton(this);
        this._isDirty = true;
        const engineCaps = this._scene.getEngine().getCaps();
        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "Skeleton";
      }
      /**
       * Returns an array containing the root bones
       * @returns an array containing the root bones
       */
      getChildren() {
        return this.bones.filter((b) => !b.getParent());
      }
      // Members
      /**
       * Gets the list of transform matrices to send to shaders (one matrix per bone)
       * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
       * @returns a Float32Array containing matrices data
       */
      getTransformMatrices(mesh) {
        if (this.needInitialSkinMatrix) {
          if (!mesh) {
            throw new Error("getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided");
          }
          if (!mesh._bonesTransformMatrices) {
            this.prepare(true);
          }
          return mesh._bonesTransformMatrices;
        }
        if (!this._transformMatrices || this._isDirty) {
          this.prepare(!this._transformMatrices);
        }
        return this._transformMatrices;
      }
      /**
       * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)
       * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
       * @returns a raw texture containing the data
       */
      getTransformMatrixTexture(mesh) {
        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
          return mesh._transformMatrixTexture;
        }
        return this._transformMatrixTexture;
      }
      /**
       * Gets the current hosting scene
       * @returns a scene object
       */
      getScene() {
        return this._scene;
      }
      // Methods
      /**
       * Gets a string representing the current skeleton data
       * @param fullDetails defines a boolean indicating if we want a verbose version
       * @returns a string representing the current skeleton data
       */
      toString(fullDetails) {
        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;
        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : "none"}`;
        if (fullDetails) {
          ret += ", Ranges: {";
          let first = true;
          for (const name in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name;
          }
          ret += "}";
        }
        return ret;
      }
      /**
       * Get bone's index searching by name
       * @param name defines bone's name to search for
       * @returns the indice of the bone. Returns -1 if not found
       */
      getBoneIndexByName(name) {
        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
          if (this.bones[boneIndex].name === name) {
            return boneIndex;
          }
        }
        return -1;
      }
      /**
       * Create a new animation range
       * @param name defines the name of the range
       * @param from defines the start key
       * @param to defines the end key
       */
      createAnimationRange(name, from, to) {
        if (!this._ranges[name]) {
          this._ranges[name] = new AnimationRange(name, from, to);
          for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
            if (this.bones[i].animations[0]) {
              this.bones[i].animations[0].createRange(name, from, to);
            }
          }
        }
      }
      /**
       * Delete a specific animation range
       * @param name defines the name of the range
       * @param deleteFrames defines if frames must be removed as well
       */
      deleteAnimationRange(name, deleteFrames = true) {
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            this.bones[i].animations[0].deleteRange(name, deleteFrames);
          }
        }
        this._ranges[name] = null;
      }
      /**
       * Gets a specific animation range
       * @param name defines the name of the range to look for
       * @returns the requested animation range or null if not found
       */
      getAnimationRange(name) {
        return this._ranges[name] || null;
      }
      /**
       * Gets the list of all animation ranges defined on this skeleton
       * @returns an array
       */
      getAnimationRanges() {
        const animationRanges = [];
        let name;
        for (name in this._ranges) {
          animationRanges.push(this._ranges[name]);
        }
        return animationRanges;
      }
      /**
       * Copy animation range from a source skeleton.
       * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
       * @param source defines the source skeleton
       * @param name defines the name of the range to copy
       * @param rescaleAsRequired defines if rescaling must be applied if required
       * @returns true if operation was successful
       */
      copyAnimationRange(source, name, rescaleAsRequired = false) {
        if (this._ranges[name] || !source.getAnimationRange(name)) {
          return false;
        }
        let ret = true;
        const frameOffset = this._getHighestAnimationFrame() + 1;
        const boneDict = {};
        const sourceBones = source.bones;
        let nBones;
        let i;
        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
          boneDict[sourceBones[i].name] = sourceBones[i];
        }
        if (this.bones.length !== sourceBones.length) {
          Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);
          ret = false;
        }
        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
        for (i = 0, nBones = this.bones.length; i < nBones; i++) {
          const boneName = this.bones[i].name;
          const sourceBone = boneDict[boneName];
          if (sourceBone) {
            ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);
          } else {
            Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
            ret = false;
          }
        }
        const range = source.getAnimationRange(name);
        if (range) {
          this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);
        }
        return ret;
      }
      /**
       * Forces the skeleton to go to rest pose
       */
      returnToRest() {
        for (const bone of this.bones) {
          if (bone._index !== -1) {
            bone.returnToRest();
          }
        }
      }
      _getHighestAnimationFrame() {
        let ret = 0;
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            const highest = this.bones[i].animations[0].getHighestFrame();
            if (ret < highest) {
              ret = highest;
            }
          }
        }
        return ret;
      }
      /**
       * Begin a specific animation range
       * @param name defines the name of the range to start
       * @param loop defines if looping must be turned on (false by default)
       * @param speedRatio defines the speed ratio to apply (1 by default)
       * @param onAnimationEnd defines a callback which will be called when animation will end
       * @returns a new animatable
       */
      beginAnimation(name, loop, speedRatio, onAnimationEnd) {
        const range = this.getAnimationRange(name);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      }
      /**
       * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.
       * @param skeleton defines the Skeleton containing the animation range to convert
       * @param referenceFrame defines the frame that keyframes in the range will be relative to
       * @param range defines the name of the AnimationRange belonging to the Skeleton to convert
       * @returns the original skeleton
       */
      static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {
        const rangeValue = skeleton.getAnimationRange(range);
        if (!rangeValue) {
          return null;
        }
        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
        let rangeAnimatable = null;
        for (let index = 0; index < sceneAnimatables.length; index++) {
          const sceneAnimatable = sceneAnimatables[index];
          if (sceneAnimatable.fromFrame === (rangeValue == null ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue == null ? void 0 : rangeValue.to)) {
            rangeAnimatable = sceneAnimatable;
            break;
          }
        }
        const animatables = skeleton.getAnimatables();
        for (let index = 0; index < animatables.length; index++) {
          const animatable = animatables[index];
          const animations = animatable.animations;
          if (!animations) {
            continue;
          }
          for (let animIndex = 0; animIndex < animations.length; animIndex++) {
            Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
          }
        }
        if (rangeAnimatable) {
          rangeAnimatable.isAdditive = true;
        }
        return skeleton;
      }
      /** @internal */
      _markAsDirty() {
        this._isDirty = true;
        this._absoluteTransformIsDirty = true;
      }
      /**
       * @internal
       */
      _registerMeshWithPoseMatrix(mesh) {
        this._meshesWithPoseMatrix.push(mesh);
      }
      /**
       * @internal
       */
      _unregisterMeshWithPoseMatrix(mesh) {
        const index = this._meshesWithPoseMatrix.indexOf(mesh);
        if (index > -1) {
          this._meshesWithPoseMatrix.splice(index, 1);
        }
      }
      _computeTransformMatrices(targetMatrix, initialSkinMatrix) {
        this.onBeforeComputeObservable.notifyObservers(this);
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          bone._childUpdateId++;
          const parentBone = bone.getParent();
          if (parentBone) {
            bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());
          } else {
            if (initialSkinMatrix) {
              bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());
            } else {
              bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());
            }
          }
          if (bone._index !== -1) {
            const mappedIndex = bone._index === null ? index : bone._index;
            bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);
          }
        }
        this._identity.copyToArray(targetMatrix, this.bones.length * 16);
      }
      /**
       * Build all resources required to render a skeleton
       * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)
       */
      prepare(dontCheckFrameId = false) {
        if (!dontCheckFrameId) {
          const currentRenderId = this.getScene().getRenderId();
          if (this._currentRenderId === currentRenderId) {
            return;
          }
          this._currentRenderId = currentRenderId;
        }
        if (this._numBonesWithLinkedTransformNode > 0) {
          for (const bone of this.bones) {
            if (bone._linkedTransformNode) {
              const node = bone._linkedTransformNode;
              bone.position = node.position;
              if (node.rotationQuaternion) {
                bone.rotationQuaternion = node.rotationQuaternion;
              } else {
                bone.rotation = node.rotation;
              }
              bone.scaling = node.scaling;
            }
          }
        }
        if (this.needInitialSkinMatrix) {
          for (const mesh of this._meshesWithPoseMatrix) {
            const poseMatrix = mesh.getPoseMatrix();
            let needsUpdate = this._isDirty;
            if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
              mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
              needsUpdate = true;
            }
            if (!needsUpdate) {
              continue;
            }
            if (this._synchronizedWithMesh !== mesh) {
              this._synchronizedWithMesh = mesh;
              for (const bone of this.bones) {
                if (!bone.getParent()) {
                  const matrix = bone.getBindMatrix();
                  matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
                  bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);
                }
              }
              if (this.isUsingTextureForMatrices) {
                const textureWidth = (this.bones.length + 1) * 4;
                if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
                  if (mesh._transformMatrixTexture) {
                    mesh._transformMatrixTexture.dispose();
                  }
                  mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
                }
              }
            }
            this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
            if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
              mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
            }
          }
        } else {
          if (!this._isDirty) {
            return;
          }
          if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
            this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
            if (this.isUsingTextureForMatrices) {
              if (this._transformMatrixTexture) {
                this._transformMatrixTexture.dispose();
              }
              this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
          this._computeTransformMatrices(this._transformMatrices, null);
          if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
            this._transformMatrixTexture.update(this._transformMatrices);
          }
        }
        this._isDirty = false;
      }
      /**
       * Gets the list of animatables currently running for this skeleton
       * @returns an array of animatables
       */
      getAnimatables() {
        if (!this._animatables || this._animatables.length !== this.bones.length) {
          this._animatables = [];
          for (let index = 0; index < this.bones.length; index++) {
            this._animatables.push(this.bones[index]);
          }
        }
        return this._animatables;
      }
      /**
       * Clone the current skeleton
       * @param name defines the name of the new skeleton
       * @param id defines the id of the new skeleton
       * @returns the new skeleton
       */
      clone(name, id) {
        const result = new _Skeleton(name, id || name, this._scene);
        result.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (let index = 0; index < this.bones.length; index++) {
          const source = this.bones[index];
          let parentBone = null;
          const parent = source.getParent();
          if (parent) {
            const parentIndex = this.bones.indexOf(parent);
            parentBone = result.bones[parentIndex];
          }
          const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());
          bone._index = source._index;
          if (source._linkedTransformNode) {
            bone.linkTransformNode(source._linkedTransformNode);
          }
          DeepCopier.DeepCopy(source.animations, bone.animations);
        }
        if (this._ranges) {
          result._ranges = {};
          for (const rangeName in this._ranges) {
            const range = this._ranges[rangeName];
            if (range) {
              result._ranges[rangeName] = range.clone();
            }
          }
        }
        this._isDirty = true;
        result.prepare(true);
        return result;
      }
      /**
       * Enable animation blending for this skeleton
       * @param blendingSpeed defines the blending speed to apply
       * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending
       */
      enableBlending(blendingSpeed = 0.01) {
        this.bones.forEach((bone) => {
          bone.animations.forEach((animation) => {
            animation.enableBlending = true;
            animation.blendingSpeed = blendingSpeed;
          });
        });
      }
      /**
       * Releases all resources associated with the current skeleton
       */
      dispose() {
        this._meshesWithPoseMatrix.length = 0;
        this.getScene().stopAnimation(this);
        this.getScene().removeSkeleton(this);
        if (this._parentContainer) {
          const index = this._parentContainer.skeletons.indexOf(this);
          if (index > -1) {
            this._parentContainer.skeletons.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
      }
      /**
       * Serialize the skeleton in a JSON object
       * @returns a JSON object
       */
      serialize() {
        var _a;
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        if (this.dimensionsAtRest) {
          serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
        }
        serializationObject.bones = [];
        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          const parent = bone.getParent();
          const serializedBone = {
            parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,
            index: bone.getIndex(),
            name: bone.name,
            id: bone.id,
            matrix: bone.getBindMatrix().asArray(),
            rest: bone.getRestMatrix().asArray(),
            linkedTransformNodeId: (_a = bone.getTransformNode()) == null ? void 0 : _a.id
          };
          serializationObject.bones.push(serializedBone);
          if (bone.length) {
            serializedBone.length = bone.length;
          }
          if (bone.metadata) {
            serializedBone.metadata = bone.metadata;
          }
          if (bone.animations && bone.animations.length > 0) {
            serializedBone.animation = bone.animations[0].serialize();
          }
          serializationObject.ranges = [];
          for (const name in this._ranges) {
            const source = this._ranges[name];
            if (!source) {
              continue;
            }
            const range = {};
            range.name = name;
            range.from = source.from;
            range.to = source.to;
            serializationObject.ranges.push(range);
          }
        }
        return serializationObject;
      }
      /**
       * Creates a new skeleton from serialized data
       * @param parsedSkeleton defines the serialized data
       * @param scene defines the hosting scene
       * @returns a new skeleton
       */
      static Parse(parsedSkeleton, scene) {
        const skeleton = new _Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);
        if (parsedSkeleton.dimensionsAtRest) {
          skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
        }
        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
        let index;
        for (index = 0; index < parsedSkeleton.bones.length; index++) {
          const parsedBone = parsedSkeleton.bones[index];
          const parsedBoneIndex = parsedSkeleton.bones[index].index;
          let parentBone = null;
          if (parsedBone.parentBoneIndex > -1) {
            parentBone = skeleton.bones[parsedBone.parentBoneIndex];
          }
          const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
          const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
          if (parsedBone.id !== void 0 && parsedBone.id !== null) {
            bone.id = parsedBone.id;
          }
          if (parsedBone.length) {
            bone.length = parsedBone.length;
          }
          if (parsedBone.metadata) {
            bone.metadata = parsedBone.metadata;
          }
          if (parsedBone.animation) {
            bone.animations.push(Animation.Parse(parsedBone.animation));
          }
          if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
            skeleton._hasWaitingData = true;
            bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
          }
        }
        if (parsedSkeleton.ranges) {
          for (index = 0; index < parsedSkeleton.ranges.length; index++) {
            const data = parsedSkeleton.ranges[index];
            skeleton.createAnimationRange(data.name, data.from, data.to);
          }
        }
        return skeleton;
      }
      /**
       * Compute all node absolute matrices
       * @param forceUpdate defines if computation must be done even if cache is up to date
       */
      computeAbsoluteMatrices(forceUpdate = false) {
        if (this._absoluteTransformIsDirty || forceUpdate) {
          this.bones[0].computeAbsoluteMatrices();
          this._absoluteTransformIsDirty = false;
        }
      }
      /**
       * Compute all node absolute matrices
       * @param forceUpdate defines if computation must be done even if cache is up to date
       * @deprecated Please use computeAbsoluteMatrices instead
       */
      computeAbsoluteTransforms(forceUpdate = false) {
        this.computeAbsoluteMatrices(forceUpdate);
      }
      /**
       * Gets the root pose matrix
       * @returns a matrix
       */
      getPoseMatrix() {
        let poseMatrix = null;
        if (this._meshesWithPoseMatrix.length > 0) {
          poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
        }
        return poseMatrix;
      }
      /**
       * Sorts bones per internal index
       */
      sortBones() {
        const bones = [];
        const visited = new Array(this.bones.length);
        for (let index = 0; index < this.bones.length; index++) {
          this._sortBones(index, bones, visited);
        }
        this.bones = bones;
      }
      _sortBones(index, bones, visited) {
        if (visited[index]) {
          return;
        }
        visited[index] = true;
        const bone = this.bones[index];
        if (!bone)
          return;
        if (bone._index === void 0) {
          bone._index = index;
        }
        const parentBone = bone.getParent();
        if (parentBone) {
          this._sortBones(this.bones.indexOf(parentBone), bones, visited);
        }
        bones.push(bone);
      }
      /**
       * Set the current local matrix as the restPose for all bones in the skeleton.
       */
      setCurrentPoseAsRest() {
        this.bones.forEach((b) => {
          b.setCurrentPoseAsRest();
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/FlowGraph/Blocks/flowGraphBlockFactory.js
function addToBlockFactory(module, blockName, factory) {
  customBlocks[`${module}/${blockName}`] = factory;
}
function blockFactory(blockName) {
  switch (blockName) {
    case "FlowGraphPlayAnimationBlock":
      return async () => (await import("./flowGraphPlayAnimationBlock-NKS7EPJT.js")).FlowGraphPlayAnimationBlock;
    case "FlowGraphStopAnimationBlock":
      return async () => (await import("./flowGraphStopAnimationBlock-T4TF7CMO.js")).FlowGraphStopAnimationBlock;
    case "FlowGraphPauseAnimationBlock":
      return async () => (await import("./flowGraphPauseAnimationBlock-PRLIKIIK.js")).FlowGraphPauseAnimationBlock;
    case "FlowGraphInterpolationBlock":
      return async () => (await import("./flowGraphInterpolationBlock-LJ6S7VPN.js")).FlowGraphInterpolationBlock;
    case "FlowGraphSceneReadyEventBlock":
      return async () => (await import("./flowGraphSceneReadyEventBlock-S7ALMTPK.js")).FlowGraphSceneReadyEventBlock;
    case "FlowGraphSceneTickEventBlock":
      return async () => (await import("./flowGraphSceneTickEventBlock-CET54BGD.js")).FlowGraphSceneTickEventBlock;
    case "FlowGraphSendCustomEventBlock":
      return async () => (await import("./flowGraphSendCustomEventBlock-U3SXZNBW.js")).FlowGraphSendCustomEventBlock;
    case "FlowGraphReceiveCustomEventBlock":
      return async () => (await import("./flowGraphReceiveCustomEventBlock-7FI67TH2.js")).FlowGraphReceiveCustomEventBlock;
    case "FlowGraphMeshPickEventBlock":
      return async () => (await import("./flowGraphMeshPickEventBlock-AZAM7AV5.js")).FlowGraphMeshPickEventBlock;
    case "FlowGraphEBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphEBlock;
    case "FlowGraphPIBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphPiBlock;
    case "FlowGraphInfBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphInfBlock;
    case "FlowGraphNaNBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphNaNBlock;
    case "FlowGraphRandomBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphRandomBlock;
    case "FlowGraphAddBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAddBlock;
    case "FlowGraphSubtractBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSubtractBlock;
    case "FlowGraphMultiplyBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphMultiplyBlock;
    case "FlowGraphDivideBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphDivideBlock;
    case "FlowGraphAbsBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAbsBlock;
    case "FlowGraphSignBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSignBlock;
    case "FlowGraphTruncBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphTruncBlock;
    case "FlowGraphFloorBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphFloorBlock;
    case "FlowGraphCeilBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphCeilBlock;
    case "FlowGraphRoundBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphRoundBlock;
    case "FlowGraphFractBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphFractionBlock;
    case "FlowGraphNegationBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphNegationBlock;
    case "FlowGraphModuloBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphModuloBlock;
    case "FlowGraphMinBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphMinBlock;
    case "FlowGraphMaxBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphMaxBlock;
    case "FlowGraphClampBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphClampBlock;
    case "FlowGraphSaturateBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSaturateBlock;
    case "FlowGraphMathInterpolationBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphMathInterpolationBlock;
    case "FlowGraphEqualityBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphEqualityBlock;
    case "FlowGraphLessThanBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLessThanBlock;
    case "FlowGraphLessThanOrEqualBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLessThanOrEqualBlock;
    case "FlowGraphGreaterThanBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphGreaterThanBlock;
    case "FlowGraphGreaterThanOrEqualBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphGreaterThanOrEqualBlock;
    case "FlowGraphIsNaNBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphIsNanBlock;
    case "FlowGraphIsInfBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphIsInfinityBlock;
    case "FlowGraphDegToRadBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphDegToRadBlock;
    case "FlowGraphRadToDegBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphRadToDegBlock;
    case "FlowGraphSinBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSinBlock;
    case "FlowGraphCosBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphCosBlock;
    case "FlowGraphTanBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphTanBlock;
    case "FlowGraphASinBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAsinBlock;
    case "FlowGraphACosBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAcosBlock;
    case "FlowGraphATanBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAtanBlock;
    case "FlowGraphATan2Block":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAtan2Block;
    case "FlowGraphSinhBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSinhBlock;
    case "FlowGraphCoshBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphCoshBlock;
    case "FlowGraphTanhBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphTanhBlock;
    case "FlowGraphASinhBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAsinhBlock;
    case "FlowGraphACoshBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAcoshBlock;
    case "FlowGraphATanhBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphAtanhBlock;
    case "FlowGraphExponentialBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphExpBlock;
    case "FlowGraphLogBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLogBlock;
    case "FlowGraphLog2Block":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLog2Block;
    case "FlowGraphLog10Block":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLog10Block;
    case "FlowGraphSquareRootBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphSquareRootBlock;
    case "FlowGraphPowerBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphPowerBlock;
    case "FlowGraphCubeRootBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphCubeRootBlock;
    case "FlowGraphBitwiseAndBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseAndBlock;
    case "FlowGraphBitwiseOrBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseOrBlock;
    case "FlowGraphBitwiseNotBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseNotBlock;
    case "FlowGraphBitwiseXorBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseXorBlock;
    case "FlowGraphBitwiseLeftShiftBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseLeftShiftBlock;
    case "FlowGraphBitwiseRightShiftBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphBitwiseRightShiftBlock;
    case "FlowGraphLengthBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphLengthBlock;
    case "FlowGraphNormalizeBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphNormalizeBlock;
    case "FlowGraphDotBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphDotBlock;
    case "FlowGraphCrossBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphCrossBlock;
    case "FlowGraphRotate2DBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphRotate2DBlock;
    case "FlowGraphRotate3DBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphRotate3DBlock;
    case "FlowGraphTransposeBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphTransposeBlock;
    case "FlowGraphDeterminantBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphDeterminantBlock;
    case "FlowGraphInvertMatrixBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphInvertMatrixBlock;
    case "FlowGraphMatrixMultiplicationBlock":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphMatrixMultiplicationBlock;
    case "FlowGraphBranchBlock":
      return async () => (await import("./flowGraphBranchBlock-CV7IXIAP.js")).FlowGraphBranchBlock;
    case "FlowGraphSetDelayBlock":
      return async () => (await import("./flowGraphSetDelayBlock-6CEKBUO2.js")).FlowGraphSetDelayBlock;
    case "FlowGraphCancelDelayBlock":
      return async () => (await import("./flowGraphCancelDelayBlock-3K5JLNBV.js")).FlowGraphCancelDelayBlock;
    case "FlowGraphCallCounterBlock":
      return async () => (await import("./flowGraphCounterBlock-FUTEYGFX.js")).FlowGraphCallCounterBlock;
    case "FlowGraphDebounceBlock":
      return async () => (await import("./flowGraphDebounceBlock-FBVKQ6Y5.js")).FlowGraphDebounceBlock;
    case "FlowGraphThrottleBlock":
      return async () => (await import("./flowGraphThrottleBlock-KBIEHHRW.js")).FlowGraphThrottleBlock;
    case "FlowGraphDoNBlock":
      return async () => (await import("./flowGraphDoNBlock-XVXWE3R5.js")).FlowGraphDoNBlock;
    case "FlowGraphFlipFlopBlock":
      return async () => (await import("./flowGraphFlipFlopBlock-QHHAGBFD.js")).FlowGraphFlipFlopBlock;
    case "FlowGraphForLoopBlock":
      return async () => (await import("./flowGraphForLoopBlock-BWJIMFLP.js")).FlowGraphForLoopBlock;
    case "FlowGraphMultiGateBlock":
      return async () => (await import("./flowGraphMultiGateBlock-FNHOWOUO.js")).FlowGraphMultiGateBlock;
    case "FlowGraphSequenceBlock":
      return async () => (await import("./flowGraphSequenceBlock-N7FQX6OD.js")).FlowGraphSequenceBlock;
    case "FlowGraphSwitchBlock":
      return async () => (await import("./flowGraphSwitchBlock-GPTEOKK5.js")).FlowGraphSwitchBlock;
    case "FlowGraphWaitAllBlock":
      return async () => (await import("./flowGraphWaitAllBlock-342NO3FA.js")).FlowGraphWaitAllBlock;
    case "FlowGraphWhileLoopBlock":
      return async () => (await import("./flowGraphWhileLoopBlock-EEUKLTSM.js")).FlowGraphWhileLoopBlock;
    case "FlowGraphConsoleLogBlock":
      return async () => (await import("./flowGraphConsoleLogBlock-OKUL3IMK.js")).FlowGraphConsoleLogBlock;
    case "FlowGraphConditionalBlock":
      return async () => (await import("./flowGraphConditionalDataBlock-HM4ZLGGR.js")).FlowGraphConditionalDataBlock;
    case "FlowGraphConstantBlock":
      return async () => (await import("./flowGraphConstantBlock-L4CRU7ME.js")).FlowGraphConstantBlock;
    case "FlowGraphTransformCoordinatesSystemBlock":
      return async () => (await import("./flowGraphTransformCoordinatesSystemBlock-SCCQAH2B.js")).FlowGraphTransformCoordinatesSystemBlock;
    case "FlowGraphGetAssetBlock":
      return async () => (await import("./flowGraphGetAssetBlock-3HTWEHFG.js")).FlowGraphGetAssetBlock;
    case "FlowGraphGetPropertyBlock":
      return async () => (await import("./flowGraphGetPropertyBlock-LK2RB4ZM.js")).FlowGraphGetPropertyBlock;
    case "FlowGraphSetPropertyBlock":
      return async () => (await import("./flowGraphSetPropertyBlock-4EKAW34N.js")).FlowGraphSetPropertyBlock;
    case "FlowGraphGetVariableBlock":
      return async () => (await import("./flowGraphGetVariableBlock-QDGVKTMT.js")).FlowGraphGetVariableBlock;
    case "FlowGraphSetVariableBlock":
      return async () => (await import("./flowGraphSetVariableBlock-XRNTPWAB.js")).FlowGraphSetVariableBlock;
    case "FlowGraphJsonPointerParserBlock":
      return async () => (await import("./flowGraphJsonPointerParserBlock-75BEBBSM.js")).FlowGraphJsonPointerParserBlock;
    case "FlowGraphLeadingZerosBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphLeadingZerosBlock;
    case "FlowGraphTrailingZerosBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphTrailingZerosBlock;
    case "FlowGraphOneBitsCounterBlock":
      return async () => (await import("./flowGraphMathBlocks-2M33YL4F.js")).FlowGraphOneBitsCounterBlock;
    case "FlowGraphCombineVector2Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphCombineVector2Block;
    case "FlowGraphCombineVector3Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphCombineVector3Block;
    case "FlowGraphCombineVector4Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphCombineVector4Block;
    case "FlowGraphCombineMatrixBlock":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphCombineMatrixBlock;
    case "FlowGraphExtractVector2Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphExtractVector2Block;
    case "FlowGraphExtractVector3Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphExtractVector3Block;
    case "FlowGraphExtractVector4Block":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphExtractVector4Block;
    case "FlowGraphExtractMatrixBlock":
      return async () => (await import("./flowGraphMathCombineExtractBlocks-UZGLBEXX.js")).FlowGraphExtractMatrixBlock;
    case "FlowGraphTransformVectorBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphTransformBlock;
    case "FlowGraphTransformCoordinatesBlock":
      return async () => (await import("./flowGraphVectorMathBlocks-OF2LLVOG.js")).FlowGraphTransformCoordinatesBlock;
    case "FlowGraphMatrixDecompose":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphMatrixDecomposeBlock;
    case "FlowGraphMatrixCompose":
      return async () => (await import("./flowGraphMatrixMathBlocks-EX3HS56C.js")).FlowGraphMatrixComposeBlock;
    case "FlowGraphBooleanToFloat":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphBooleanToFloat;
    case "FlowGraphBooleanToInt":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphBooleanToInt;
    case "FlowGraphFloatToBoolean":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphFloatToBoolean;
    case "FlowGraphIntToBoolean":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphIntToBoolean;
    case "FlowGraphIntToFloat":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphIntToFloat;
    case "FlowGraphFloatToInt":
      return async () => (await import("./flowGraphTypeToTypeBlocks-ZV7ZGKCM.js")).FlowGraphFloatToInt;
    case "FlowGraphEasingBlock":
      return async () => (await import("./flowGraphEasingBlock-XLYLIE6K.js")).FlowGraphEasingBlock;
    case "FlowGraphBezierCurveEasing":
      return async () => (await import("./flowGraphBezierCurveEasingBlock-XHIMAYIT.js")).FlowGraphBezierCurveEasingBlock;
    case "FlowGraphPointerOverEventBlock":
      return async () => (await import("./flowGraphPointerOverEventBlock-GRPTHGC6.js")).FlowGraphPointerOverEventBlock;
    case "FlowGraphPointerOutEventBlock":
      return async () => (await import("./flowGraphPointerOutEventBlock-CXORGE65.js")).FlowGraphPointerOutEventBlock;
    case "FlowGraphContextBlock":
      return async () => (await import("./flowGraphContextBlock-YIJ2VMBV.js")).FlowGraphContextBlock;
    case "FlowGraphArrayIndexBlock":
      return async () => (await import("./flowGraphArrayIndexBlock-C6RQEX3I.js")).FlowGraphArrayIndexBlock;
    case "FlowGraphCodeExecutionBlock":
      return async () => (await import("./flowGraphCodeExecutionBlock-5PGAKUSZ.js")).FlowGraphCodeExecutionBlock;
    case "FlowGraphIndexOfBlock":
      return async () => (await import("./flowGraphIndexOfBlock-UEKSNNAV.js")).FlowGraphIndexOfBlock;
    case "FlowGraphFunctionReference":
      return async () => (await import("./flowGraphFunctionReferenceBlock-6TYTDEHD.js")).FlowGraphFunctionReferenceBlock;
    case "FlowGraphDataSwitchBlock":
      return async () => (await import("./flowGraphDataSwitchBlock-ZWBWOQQI.js")).FlowGraphDataSwitchBlock;
    default:
      if (customBlocks[blockName]) {
        return customBlocks[blockName];
      }
      throw new Error(`Unknown block name ${blockName}`);
  }
}
var customBlocks;
var init_flowGraphBlockFactory = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/flowGraphBlockFactory.js"() {
    customBlocks = {};
  }
});

// node_modules/@babylonjs/core/FlowGraph/flowGraphParser.js
function GetDataOutConnectionByUniqueId(blocks, uniqueId) {
  for (const block of blocks) {
    for (const dataOut of block.dataOutputs) {
      if (dataOut.uniqueId === uniqueId) {
        return dataOut;
      }
    }
  }
  throw new Error("Could not find data out connection with unique id " + uniqueId);
}
function GetSignalInConnectionByUniqueId(blocks, uniqueId) {
  for (const block of blocks) {
    if (block instanceof FlowGraphExecutionBlock) {
      for (const signalIn of block.signalInputs) {
        if (signalIn.uniqueId === uniqueId) {
          return signalIn;
        }
      }
    }
  }
  throw new Error("Could not find signal in connection with unique id " + uniqueId);
}
async function ParseCoordinatorAsync(serializedObject, options) {
  var _a;
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  const coordinator = new FlowGraphCoordinator({ scene: options.scene });
  if (serializedObject.dispatchEventsSynchronously) {
    coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;
  }
  await options.scene.whenReadyAsync();
  if (serializedObject._defaultValues) {
    for (const key in serializedObject._defaultValues) {
      const value = serializedObject._defaultValues[key];
      getRichTypeByFlowGraphType(key).defaultValue = value;
    }
  }
  await Promise.all((_a = serializedObject._flowGraphs) == null ? void 0 : _a.map((serializedGraph) => ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })));
  return coordinator;
}
async function ParseFlowGraphAsync(serializationObject, options) {
  const resolvedClasses = await Promise.all(serializationObject.allBlocks.map(async (serializedBlock) => {
    const classFactory = blockFactory(serializedBlock.className);
    return classFactory();
  }));
  return ParseFlowGraph(serializationObject, options, resolvedClasses);
}
function ParseFlowGraph(serializationObject, options, resolvedClasses) {
  const graph = options.coordinator.createGraph();
  const blocks = [];
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  for (let i = 0; i < serializationObject.allBlocks.length; i++) {
    const serializedBlock = serializationObject.allBlocks[i];
    const block = ParseFlowGraphBlockWithClassType(serializedBlock, { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction }, resolvedClasses[i]);
    blocks.push(block);
    if (block instanceof FlowGraphEventBlock) {
      graph.addEventBlock(block);
    }
  }
  for (const block of blocks) {
    for (const dataIn of block.dataInputs) {
      for (const serializedConnection of dataIn.connectedPointIds) {
        const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);
        dataIn.connectTo(connection);
      }
    }
    if (block instanceof FlowGraphExecutionBlock) {
      for (const signalOut of block.signalOutputs) {
        for (const serializedConnection of signalOut.connectedPointIds) {
          const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);
          signalOut.connectTo(connection);
        }
      }
    }
  }
  for (const serializedContext of serializationObject.executionContexts) {
    ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);
  }
  return graph;
}
function ParseFlowGraphContext(serializationObject, options, rightHanded) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const result = options.graph.createContext();
  if (serializationObject.enableLogging) {
    result.enableLogging = true;
  }
  result.treatDataAsRightHanded = rightHanded || false;
  const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
  result.uniqueId = serializationObject.uniqueId;
  const scene = result.getScene();
  if (serializationObject._assetsContext) {
    const ac = serializationObject._assetsContext;
    const assetsContext = {
      meshes: (_a = ac.meshes) == null ? void 0 : _a.map((m) => scene.getMeshById(m)),
      lights: (_b = ac.lights) == null ? void 0 : _b.map((l) => scene.getLightByName(l)),
      cameras: (_c = ac.cameras) == null ? void 0 : _c.map((c) => scene.getCameraByName(c)),
      materials: (_d = ac.materials) == null ? void 0 : _d.map((m) => scene.getMaterialById(m)),
      textures: (_e = ac.textures) == null ? void 0 : _e.map((t) => scene.getTextureByName(t)),
      animations: (_f = ac.animations) == null ? void 0 : _f.map((a) => scene.animations.find((anim) => anim.name === a)),
      skeletons: (_g = ac.skeletons) == null ? void 0 : _g.map((s) => scene.getSkeletonByName(s)),
      particleSystems: (_h = ac.particleSystems) == null ? void 0 : _h.map((ps) => scene.getParticleSystemById(ps)),
      animationGroups: (_i = ac.animationGroups) == null ? void 0 : _i.map((ag) => scene.getAnimationGroupByName(ag)),
      transformNodes: (_j = ac.transformNodes) == null ? void 0 : _j.map((tn) => scene.getTransformNodeById(tn)),
      rootNodes: [],
      multiMaterials: [],
      morphTargetManagers: [],
      geometries: [],
      actionManagers: [],
      environmentTexture: null,
      postProcesses: [],
      sounds: null,
      effectLayers: [],
      layers: [],
      reflectionProbes: [],
      lensFlareSystems: [],
      proceduralTextures: [],
      getNodes: function() {
        throw new Error("Function not implemented.");
      }
    };
    result.assetsContext = assetsContext;
  }
  for (const key in serializationObject._userVariables) {
    const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);
    result.userVariables[key] = value;
  }
  for (const key in serializationObject._connectionValues) {
    const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);
    result._setConnectionValueByKey(key, value);
  }
  return result;
}
async function ParseBlockAsync(serializationObject, parseOptions) {
  const classFactory = blockFactory(serializationObject.className);
  const classType = await classFactory();
  return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);
}
function ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType) {
  const parsedConfig = {};
  const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;
  if (serializationObject.config) {
    for (const key in serializationObject.config) {
      parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);
    }
  }
  if (needsPathConverter(serializationObject.className)) {
    if (!parseOptions.pathConverter) {
      throw new Error("Path converter is required for this block");
    }
    parsedConfig.pathConverter = parseOptions.pathConverter;
  }
  const obj = new classType(parsedConfig);
  obj.uniqueId = serializationObject.uniqueId;
  for (let i = 0; i < serializationObject.dataInputs.length; i++) {
    const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);
    if (dataInput) {
      dataInput.deserialize(serializationObject.dataInputs[i]);
    } else {
      throw new Error("Could not find data input with name " + serializationObject.dataInputs[i].name + " in block " + serializationObject.className);
    }
  }
  for (let i = 0; i < serializationObject.dataOutputs.length; i++) {
    const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);
    if (dataOutput) {
      dataOutput.deserialize(serializationObject.dataOutputs[i]);
    } else {
      throw new Error("Could not find data output with name " + serializationObject.dataOutputs[i].name + " in block " + serializationObject.className);
    }
  }
  obj.metadata = serializationObject.metadata;
  obj.deserialize && obj.deserialize(serializationObject);
  return obj;
}
function ParseGraphConnectionWithClassType(serializationObject = {}, ownerBlock, classType) {
  const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);
  connection.deserialize(serializationObject);
  return connection;
}
function ParseGraphDataConnection(serializationObject, ownerBlock, classType) {
  const richType = ParseRichType(serializationObject.richType);
  const defaultValue = serializationObject.defaultValue;
  const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);
  connection.deserialize(serializationObject);
  return connection;
}
function ParseRichType(serializationObject) {
  return new RichType(serializationObject.typeName, serializationObject.defaultValue);
}
var init_flowGraphParser = __esm({
  "node_modules/@babylonjs/core/FlowGraph/flowGraphParser.js"() {
    init_flowGraphBlockFactory();
    init_flowGraphCoordinator();
    init_flowGraphEventBlock();
    init_flowGraphExecutionBlock();
    init_serialization();
    init_flowGraphRichTypes();
  }
});

// node_modules/@babylonjs/core/Lights/directionalLight.js
var DirectionalLight;
var init_directionalLight = __esm({
  "node_modules/@babylonjs/core/Lights/directionalLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_typeStore();
    Node.AddNodeConstructor("Light_Type_1", (name, scene) => {
      return () => new DirectionalLight(name, Vector3.Zero(), scene);
    });
    DirectionalLight = class extends ShadowLight {
      /**
       * Fix frustum size for the shadow generation. This is disabled if the value is 0.
       */
      get shadowFrustumSize() {
        return this._shadowFrustumSize;
      }
      /**
       * Specifies a fix frustum size for the shadow generation.
       */
      set shadowFrustumSize(value) {
        this._shadowFrustumSize = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Gets the shadow projection scale against the optimal computed one.
       * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
       * This does not impact in fixed frustum size (shadowFrustumSize being set)
       */
      get shadowOrthoScale() {
        return this._shadowOrthoScale;
      }
      /**
       * Sets the shadow projection scale against the optimal computed one.
       * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
       * This does not impact in fixed frustum size (shadowFrustumSize being set)
       */
      set shadowOrthoScale(value) {
        this._shadowOrthoScale = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Gets or sets the orthoLeft property used to build the light frustum
       */
      get orthoLeft() {
        return this._orthoLeft;
      }
      set orthoLeft(left) {
        this._orthoLeft = left;
      }
      /**
       * Gets or sets the orthoRight property used to build the light frustum
       */
      get orthoRight() {
        return this._orthoRight;
      }
      set orthoRight(right) {
        this._orthoRight = right;
      }
      /**
       * Gets or sets the orthoTop property used to build the light frustum
       */
      get orthoTop() {
        return this._orthoTop;
      }
      set orthoTop(top) {
        this._orthoTop = top;
      }
      /**
       * Gets or sets the orthoBottom property used to build the light frustum
       */
      get orthoBottom() {
        return this._orthoBottom;
      }
      set orthoBottom(bottom) {
        this._orthoBottom = bottom;
      }
      /**
       * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
       * The directional light is emitted from everywhere in the given direction.
       * It can cast shadows.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param direction The direction of the light
       * @param scene The scene the light belongs to
       */
      constructor(name, direction, scene) {
        super(name, scene);
        this._shadowFrustumSize = 0;
        this._shadowOrthoScale = 0.1;
        this.autoUpdateExtends = true;
        this.autoCalcShadowZBounds = false;
        this._orthoLeft = Number.MAX_VALUE;
        this._orthoRight = Number.MIN_VALUE;
        this._orthoTop = Number.MIN_VALUE;
        this._orthoBottom = Number.MAX_VALUE;
        this.position = direction.scale(-1);
        this.direction = direction;
      }
      /**
       * Returns the string "DirectionalLight".
       * @returns The class name
       */
      getClassName() {
        return "DirectionalLight";
      }
      /**
       * Returns the integer 1.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      getTypeID() {
        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
      }
      /**
       * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        if (this.shadowFrustumSize > 0) {
          this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
        } else {
          this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
      }
      /**
       * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       */
      _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      /**
       * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
          const tempVector3 = Vector3.Zero();
          this._orthoLeft = Number.MAX_VALUE;
          this._orthoRight = -Number.MAX_VALUE;
          this._orthoTop = -Number.MAX_VALUE;
          this._orthoBottom = Number.MAX_VALUE;
          let shadowMinZ = Number.MAX_VALUE;
          let shadowMaxZ = -Number.MAX_VALUE;
          for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            const mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            const boundingInfo = mesh.getBoundingInfo();
            const boundingBox = boundingInfo.boundingBox;
            for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
              Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
              if (tempVector3.x < this._orthoLeft) {
                this._orthoLeft = tempVector3.x;
              }
              if (tempVector3.y < this._orthoBottom) {
                this._orthoBottom = tempVector3.y;
              }
              if (tempVector3.x > this._orthoRight) {
                this._orthoRight = tempVector3.x;
              }
              if (tempVector3.y > this._orthoTop) {
                this._orthoTop = tempVector3.y;
              }
              if (this.autoCalcShadowZBounds) {
                if (tempVector3.z < shadowMinZ) {
                  shadowMinZ = tempVector3.z;
                }
                if (tempVector3.z > shadowMaxZ) {
                  shadowMaxZ = tempVector3.z;
                }
              }
            }
          }
          if (this.autoCalcShadowZBounds) {
            this._shadowMinZ = shadowMinZ;
            this._shadowMaxZ = shadowMaxZ;
          }
        }
        const xOffset = this._orthoRight - this._orthoLeft;
        const yOffset = this._orthoTop - this._orthoBottom;
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : (activeCamera == null ? void 0 : activeCamera.minZ) || 0;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : (activeCamera == null ? void 0 : activeCamera.maxZ) || 1e4;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      /**
       * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The directional light
       */
      transferToEffect(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
          return this;
        }
        this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
          return this;
        }
        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
        return this;
      }
      /**
       * Gets the minZ used for shadow according to both the scene and the light.
       *
       * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
       * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
       * (when not using reverse depth buffer / NDC half Z range)
       * @param _activeCamera The camera we are returning the min for (not used)
       * @returns the depth min z
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getDepthMinZ(_activeCamera) {
        const engine = this._scene.getEngine();
        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      /**
       * Gets the maxZ used for shadow according to both the scene and the light.
       *
       * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
       * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
       * (when not using reverse depth buffer / NDC half Z range)
       * @param _activeCamera The camera we are returning the max for
       * @returns the depth max z
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getDepthMaxZ(_activeCamera) {
        const engine = this._scene.getEngine();
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["DIRLIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowFrustumSize", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowOrthoScale", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoUpdateExtends", void 0);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
    __decorate([
      serialize("orthoLeft")
    ], DirectionalLight.prototype, "_orthoLeft", void 0);
    __decorate([
      serialize("orthoRight")
    ], DirectionalLight.prototype, "_orthoRight", void 0);
    __decorate([
      serialize("orthoTop")
    ], DirectionalLight.prototype, "_orthoTop", void 0);
    __decorate([
      serialize("orthoBottom")
    ], DirectionalLight.prototype, "_orthoBottom", void 0);
    RegisterClass("BABYLON.DirectionalLight", DirectionalLight);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var defaultLodScale, CubeTexture;
var init_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_math_vector();
    init_baseTexture();
    init_texture();
    init_typeStore();
    init_observable();
    init_decorators_serialization();
    init_abstractEngine_cubeTexture();
    defaultLodScale = 0.8;
    CubeTexture = class _CubeTexture extends BaseTexture {
      /**
       * Gets or sets the size of the bounding box associated with the cube texture
       * When defined, the cubemap will switch to local mode
       * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
       * @example https://www.babylonjs-playground.com/#RNASML
       */
      set boundingBoxSize(value) {
        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
          return;
        }
        this._boundingBoxSize = value;
        const scene = this.getScene();
        if (scene) {
          scene.markAllMaterialsAsDirty(1);
        }
      }
      /**
       * Returns the bounding box size
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode
       */
      get boundingBoxSize() {
        return this._boundingBoxSize;
      }
      /**
       * Sets texture matrix rotation angle around Y axis in radians.
       */
      set rotationY(value) {
        this._rotationY = value;
        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
      }
      /**
       * Gets texture matrix rotation angle around Y axis radians.
       */
      get rotationY() {
        return this._rotationY;
      }
      /**
       * Are mip maps generated for this texture or not.
       */
      get noMipmap() {
        return this._noMipmap;
      }
      /**
       * Gets the forced extension (if any)
       */
      get forcedExtension() {
        return this._forcedExtension;
      }
      /**
       * Creates a cube texture from an array of image urls
       * @param files defines an array of image urls
       * @param scene defines the hosting scene
       * @param noMipmap specifies if mip maps are not used
       * @returns a cube texture
       */
      static CreateFromImages(files, scene, noMipmap) {
        let rootUrlKey = "";
        files.forEach((url) => rootUrlKey += url);
        return new _CubeTexture(rootUrlKey, scene, null, noMipmap, files);
      }
      /**
       * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
       * @param url defines the url of the prefiltered texture
       * @param scene defines the scene the texture is attached to
       * @param forcedExtension defines the extension of the file if different from the url
       * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
       * @returns the prefiltered texture
       */
      static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {
        const oldValue = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const result = new _CubeTexture(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
        scene.useDelayedTextureLoading = oldValue;
        return result;
      }
      /**
       * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
       * as prefiltered data.
       * @param rootUrl defines the url of the texture or the root name of the six images
       * @param sceneOrEngine defines the scene or engine the texture is attached to
       * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture
       * @param noMipmap defines if mipmaps should be created or not
       * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
       * @param onLoad defines a callback triggered at the end of the file load if no errors occurred
       * @param onError defines a callback triggered in case of error during load
       * @param format defines the internal format to use for the texture once loaded
       * @param prefiltered defines whether or not the texture is created from prefiltered data
       * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
       * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
       * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
       * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
       * @param loaderOptions options to be passed to the loader
       * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)
       * @returns the cube texture
       */
      constructor(rootUrl, sceneOrEngine, extensionsOrOptions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = defaultLodScale, lodOffset = 0, loaderOptions, useSRGBBuffer) {
        var _a;
        super(sceneOrEngine);
        this.onLoadObservable = new Observable();
        this.boundingBoxPosition = Vector3.Zero();
        this._rotationY = 0;
        this._files = null;
        this._forcedExtension = null;
        this._extensions = null;
        this._textureMatrixRefraction = new Matrix();
        this._buffer = null;
        this.name = rootUrl;
        this.url = rootUrl;
        this._noMipmap = noMipmap;
        this.hasAlpha = false;
        this.isCube = true;
        this._textureMatrix = Matrix.Identity();
        this.coordinatesMode = Texture.CUBIC_MODE;
        let extensions = null;
        let buffer = null;
        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {
          extensions = extensionsOrOptions.extensions ?? null;
          this._noMipmap = extensionsOrOptions.noMipmap ?? false;
          files = extensionsOrOptions.files ?? null;
          buffer = extensionsOrOptions.buffer ?? null;
          this._format = extensionsOrOptions.format ?? 5;
          prefiltered = extensionsOrOptions.prefiltered ?? false;
          forcedExtension = extensionsOrOptions.forcedExtension ?? null;
          this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;
          this._lodScale = extensionsOrOptions.lodScale ?? defaultLodScale;
          this._lodOffset = extensionsOrOptions.lodOffset ?? 0;
          this._loaderOptions = extensionsOrOptions.loaderOptions;
          this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;
          onLoad = extensionsOrOptions.onLoad ?? null;
          onError = extensionsOrOptions.onError ?? null;
        } else {
          this._noMipmap = noMipmap;
          this._format = format;
          this._createPolynomials = createPolynomials;
          extensions = extensionsOrOptions;
          this._loaderOptions = loaderOptions;
          this._useSRGBBuffer = useSRGBBuffer;
          this._lodScale = lodScale;
          this._lodOffset = lodOffset;
        }
        if (!rootUrl && !files) {
          return;
        }
        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = this.getScene()) == null ? void 0 : _a.useDelayedTextureLoading, files, buffer);
      }
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "CubeTexture"
       */
      getClassName() {
        return "CubeTexture";
      }
      /**
       * Update the url (and optional buffer) of this texture if url was null during construction.
       * @param url the url of the texture
       * @param forcedExtension defines the extension to use
       * @param onLoad callback called when the texture is loaded  (defaults to null)
       * @param prefiltered Defines whether the updated texture is prefiltered or not
       * @param onError callback called if there was an error during the loading process (defaults to null)
       * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
       * @param delayLoad defines if the texture should be loaded now (false by default)
       * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
       * @param buffer the buffer to use instead of loading from the url
       */
      updateURL(url, forcedExtension = null, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null, buffer = null) {
        if (!this.name || this.name.startsWith("data:")) {
          this.name = url;
        }
        this.url = url;
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        const lastDot = url.lastIndexOf(".");
        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        const isDDS = extension.indexOf(".dds") === 0;
        const isEnv = extension.indexOf(".env") === 0;
        const isBasis = extension.indexOf(".basis") === 0;
        if (isEnv) {
          this.gammaSpace = false;
          this._prefiltered = false;
          this.anisotropicFilteringLevel = 1;
        } else {
          this._prefiltered = prefiltered;
          if (prefiltered) {
            this.gammaSpace = false;
            this.anisotropicFilteringLevel = 1;
          }
        }
        if (files) {
          this._files = files;
        } else {
          if (!isBasis && !isEnv && !isDDS && !extensions) {
            extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
          }
          this._files = this._files || [];
          this._files.length = 0;
          if (extensions) {
            for (let index = 0; index < extensions.length; index++) {
              this._files.push(url + extensions[index]);
            }
            this._extensions = extensions;
          }
        }
        this._buffer = buffer;
        if (delayLoad) {
          this.delayLoadState = 4;
          this._delayedOnLoad = onLoad;
          this._delayedOnError = onError;
        } else {
          this._loadTexture(onLoad, onError);
        }
      }
      /**
       * Delays loading of the cube texture
       * @param forcedExtension defines the extension to use
       */
      delayLoad(forcedExtension) {
        if (this.delayLoadState !== 4) {
          return;
        }
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        this.delayLoadState = 1;
        this._loadTexture(this._delayedOnLoad, this._delayedOnError);
      }
      /**
       * Returns the reflection texture matrix
       * @returns the reflection texture matrix
       */
      getReflectionTextureMatrix() {
        return this._textureMatrix;
      }
      /**
       * Sets the reflection texture matrix
       * @param value Reflection texture matrix
       */
      setReflectionTextureMatrix(value) {
        var _a, _b;
        if (value.updateFlag === this._textureMatrix.updateFlag) {
          return;
        }
        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
          (_a = this.getScene()) == null ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
        }
        this._textureMatrix = value;
        if (!((_b = this.getScene()) == null ? void 0 : _b.useRightHandedSystem)) {
          return;
        }
        const scale = TmpVectors.Vector3[0];
        const quat = TmpVectors.Quaternion[0];
        const trans = TmpVectors.Vector3[1];
        this._textureMatrix.decompose(scale, quat, trans);
        quat.z *= -1;
        quat.w *= -1;
        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);
      }
      /**
       * Gets a suitable rotate/transform matrix when the texture is used for refraction.
       * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
       * @returns The refraction matrix
       */
      getRefractionTextureMatrix() {
        var _a;
        return ((_a = this.getScene()) == null ? void 0 : _a.useRightHandedSystem) ? this._textureMatrixRefraction : this._textureMatrix;
      }
      _loadTexture(onLoad = null, onError = null) {
        var _a;
        const scene = this.getScene();
        const oldTexture = this._texture;
        this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
        const onLoadProcessing = () => {
          var _a2;
          this.onLoadObservable.notifyObservers(this);
          if (oldTexture) {
            oldTexture.dispose();
            (_a2 = this.getScene()) == null ? void 0 : _a2.markAllMaterialsAsDirty(1);
          }
          if (onLoad) {
            onLoad();
          }
        };
        const errorHandler = (message, exception) => {
          this._loadingError = true;
          this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture.OnTextureLoadErrorObservable.notifyObservers(this);
        };
        if (!this._texture) {
          if (this._prefiltered) {
            this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
          } else {
            this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer);
          }
          (_a = this._texture) == null ? void 0 : _a.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));
        } else {
          if (this._texture.isReady) {
            Tools.SetImmediate(() => onLoadProcessing());
          } else {
            this._texture.onLoadedObservable.add(() => onLoadProcessing());
          }
        }
      }
      /**
       * Parses text to create a cube texture
       * @param parsedTexture define the serialized text to read from
       * @param scene defines the hosting scene
       * @param rootUrl defines the root url of the cube texture
       * @returns a cube texture
       */
      static Parse(parsedTexture, scene, rootUrl) {
        const texture = SerializationHelper.Parse(() => {
          let prefiltered = false;
          if (parsedTexture.prefiltered) {
            prefiltered = parsedTexture.prefiltered;
          }
          return new _CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
        }, parsedTexture, scene);
        if (parsedTexture.boundingBoxPosition) {
          texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
        }
        if (parsedTexture.boundingBoxSize) {
          texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
        }
        if (parsedTexture.animations) {
          for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
            const parsedAnimation = parsedTexture.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              texture.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
        }
        return texture;
      }
      /**
       * Makes a clone, or deep copy, of the cube texture
       * @returns a new cube texture
       */
      clone() {
        let uniqueId = 0;
        const newCubeTexture = SerializationHelper.Clone(() => {
          const cubeTexture = new _CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
          uniqueId = cubeTexture.uniqueId;
          return cubeTexture;
        }, this);
        newCubeTexture.uniqueId = uniqueId;
        return newCubeTexture;
      }
    };
    __decorate([
      serialize()
    ], CubeTexture.prototype, "url", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxPosition", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxSize", null);
    __decorate([
      serialize("rotationY")
    ], CubeTexture.prototype, "rotationY", null);
    __decorate([
      serialize("files")
    ], CubeTexture.prototype, "_files", void 0);
    __decorate([
      serialize("forcedExtension")
    ], CubeTexture.prototype, "_forcedExtension", void 0);
    __decorate([
      serialize("extensions")
    ], CubeTexture.prototype, "_extensions", void 0);
    __decorate([
      serializeAsMatrix("textureMatrix")
    ], CubeTexture.prototype, "_textureMatrix", void 0);
    __decorate([
      serializeAsMatrix("textureMatrixRefraction")
    ], CubeTexture.prototype, "_textureMatrixRefraction", void 0);
    Texture._CubeTextureParser = CubeTexture.Parse;
    RegisterClass("BABYLON.CubeTexture", CubeTexture);
  }
});

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture, _instanceNumber, GetEnvironmentBRDFTexture, BRDFTextureTools;
var init_brdfTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/brdfTextureTools.js"() {
    init_texture();
    init_rgbdTextureTools();
    _environmentBRDFBase64Texture = "data:image/png;base64,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";
    _instanceNumber = 0;
    GetEnvironmentBRDFTexture = (scene) => {
      if (!scene.environmentBRDFTexture) {
        const useDelayedTextureLoading = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const previousState = scene._blockEntityCollection;
        scene._blockEntityCollection = false;
        const texture = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
        scene._blockEntityCollection = previousState;
        const texturesCache = scene.getEngine().getLoadedTexturesCache();
        const index = texturesCache.indexOf(texture.getInternalTexture());
        if (index !== -1) {
          texturesCache.splice(index, 1);
        }
        texture.isRGBD = true;
        texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        scene.environmentBRDFTexture = texture;
        scene.useDelayedTextureLoading = useDelayedTextureLoading;
        RGBDTextureTools.ExpandRGBDTexture(texture);
        const observer = scene.getEngine().onContextRestoredObservable.add(() => {
          texture.isRGBD = true;
          const oo = scene.onBeforeRenderObservable.add(() => {
            if (texture.isReady()) {
              scene.onBeforeRenderObservable.remove(oo);
              RGBDTextureTools.ExpandRGBDTexture(texture);
            }
          });
        });
        scene.onDisposeObservable.add(() => {
          scene.getEngine().onContextRestoredObservable.remove(observer);
        });
      }
      return scene.environmentBRDFTexture;
    };
    BRDFTextureTools = {
      /**
       * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
       * @param scene defines the hosting scene
       * @returns the environment BRDF texture
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      GetEnvironmentBRDFTexture
    };
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines, PBRBRDFConfiguration;
var init_pbrBRDFConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialDefines();
    init_materialPluginBase();
    MaterialBRDFDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.BRDF_V_HEIGHT_CORRELATED = false;
        this.MS_BRDF_ENERGY_CONSERVATION = false;
        this.SPHERICAL_HARMONICS = false;
        this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
        this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
      }
    };
    PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsMiscDirty() {
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
        this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this._mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
        this.mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
        this._enable(true);
      }
      prepareDefines(defines) {
        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
        defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;
      }
      getClassName() {
        return "PBRBRDFConfiguration";
      }
    };
    PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "mixIblRadianceWithIrradiance", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines, PBRClearCoatConfiguration;
var init_pbrClearCoatConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialClearCoatDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.CLEARCOAT = false;
        this.CLEARCOAT_DEFAULTIOR = false;
        this.CLEARCOAT_TEXTURE = false;
        this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
        this.CLEARCOAT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.CLEARCOAT_BUMP = false;
        this.CLEARCOAT_BUMPDIRECTUV = 0;
        this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        this.CLEARCOAT_REMAP_F0 = false;
        this.CLEARCOAT_TINT = false;
        this.CLEARCOAT_TINT_TEXTURE = false;
        this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TINT_GAMMATEXTURE = false;
      }
    };
    PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.roughness = 0;
        this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._remapF0OnInterfaceChange = true;
        this.remapF0OnInterfaceChange = true;
        this._bumpTexture = null;
        this.bumpTexture = null;
        this._isTintEnabled = false;
        this.isTintEnabled = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.tintThickness = 1;
        this._tintTexture = null;
        this.tintTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        const disableBumpMap = this._material._disableBumpMap;
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              if (!this._tintTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.CLEARCOAT = true;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
              } else {
                defines.CLEARCOAT_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
                PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
              } else {
                defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
              }
              if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
                PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
              } else {
                defines.CLEARCOAT_BUMP = false;
              }
              defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
              if (this._isTintEnabled) {
                defines.CLEARCOAT_TINT = true;
                if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
                  PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
                  defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
                } else {
                  defines.CLEARCOAT_TINT_TEXTURE = false;
                }
              } else {
                defines.CLEARCOAT_TINT = false;
                defines.CLEARCOAT_TINT_TEXTURE = false;
              }
            }
          }
        } else {
          defines.CLEARCOAT = false;
          defines.CLEARCOAT_TEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          defines.CLEARCOAT_BUMP = false;
          defines.CLEARCOAT_TINT = false;
          defines.CLEARCOAT_TINT_TEXTURE = false;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.CLEARCOAT_DEFAULTIOR = false;
          defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
          defines.CLEARCOAT_BUMPDIRECTUV = 0;
          defines.CLEARCOAT_REMAP_F0 = false;
          defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d;
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const disableBumpMap = this._material._disableBumpMap;
        const invertNormalMapX = this._material._invertNormalMapX;
        const invertNormalMapY = this._material._invertNormalMapY;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._textureRoughness) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._textureRoughness) == null ? void 0 : _d.level) ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
            }
            if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
            uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
            BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
            if (scene._mirroredCameraPosition) {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
            } else {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
            }
          }
          if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
            BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
          }
          uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
          const a = 1 - this._indexOfRefraction;
          const b = 1 + this._indexOfRefraction;
          const f0 = Math.pow(-a / b, 2);
          const eta = 1 / this._indexOfRefraction;
          uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
          if (this._isTintEnabled) {
            uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
            uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatSampler", this._texture);
          }
          if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
            uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
          }
          if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._tintTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._tintTexture) {
          activeTextures.push(this._tintTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          animatables.push(this._bumpTexture);
        }
        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
          animatables.push(this._tintTexture);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b, _c, _d;
        if (forceDisposeTextures) {
          (_a = this._texture) == null ? void 0 : _a.dispose();
          (_b = this._textureRoughness) == null ? void 0 : _b.dispose();
          (_c = this._bumpTexture) == null ? void 0 : _c.dispose();
          (_d = this._tintTexture) == null ? void 0 : _d.dispose();
        }
      }
      getClassName() {
        return "PBRClearCoatConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.CLEARCOAT_BUMP) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
        }
        if (defines.CLEARCOAT_TINT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
        }
        if (defines.CLEARCOAT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vClearCoatParams", size: 2, type: "vec2" },
            { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
            { name: "vClearCoatInfos", size: 4, type: "vec4" },
            { name: "clearCoatMatrix", size: 16, type: "mat4" },
            { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
            { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
            { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatTintParams", size: 4, type: "vec4" },
            { name: "clearCoatColorAtDistance", size: 1, type: "float" },
            { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
            { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines, PBRIridescenceConfiguration;
var init_pbrIridescenceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialIridescenceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.IRIDESCENCE = false;
        this.IRIDESCENCE_TEXTURE = false;
        this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
        this.IRIDESCENCE_THICKNESS_TEXTURE = false;
        this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
      }
    };
    PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
        this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
        this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.IRIDESCENCE = true;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
              } else {
                defines.IRIDESCENCE_TEXTURE = false;
              }
              if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
                PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
              } else {
                defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
              }
            }
          }
        } else {
          defines.IRIDESCENCE = false;
          defines.IRIDESCENCE_TEXTURE = false;
          defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
          defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        var _a, _b, _c, _d;
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._thicknessTexture) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._thicknessTexture) == null ? void 0 : _d.level) ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
            }
            if (this._thicknessTexture) {
              BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
            }
          }
          uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceSampler", this._texture);
          }
          if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._thicknessTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) == null ? void 0 : _a.dispose();
          (_b = this._thicknessTexture) == null ? void 0 : _b.dispose();
        }
      }
      getClassName() {
        return "PBRIridescenceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.IRIDESCENCE) {
          fallbacks.addFallback(currentRank++, "IRIDESCENCE");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vIridescenceParams", size: 4, type: "vec4" },
            { name: "vIridescenceInfos", size: 4, type: "vec4" },
            { name: "iridescenceMatrix", size: 16, type: "mat4" },
            { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
    PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
    PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "texture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines, PBRAnisotropicConfiguration;
var init_pbrAnisotropicConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_buffer();
    init_math_vector();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialAnisotropicDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.ANISOTROPIC = false;
        this.ANISOTROPIC_TEXTURE = false;
        this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
        this.ANISOTROPIC_LEGACY = false;
        this.MAINUV1 = false;
      }
    };
    PBRAnisotropicConfiguration = class extends MaterialPluginBase {
      /**
       * Sets the anisotropy direction as an angle.
       */
      set angle(value) {
        this.direction.x = Math.cos(value);
        this.direction.y = Math.sin(value);
      }
      /**
       * Gets the anisotropy angle value in radians.
       * @returns the anisotropy angle value in radians.
       */
      get angle() {
        return Math.atan2(this.direction.y, this.direction.x);
      }
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /** @internal */
      _markAllSubMeshesAsMiscDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.direction = new Vector2(1, 0);
        this._texture = null;
        this.texture = null;
        this._legacy = false;
        this.legacy = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene, mesh) {
        if (this._isEnabled) {
          defines.ANISOTROPIC = this._isEnabled;
          if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
              } else {
                defines.ANISOTROPIC_TEXTURE = false;
              }
            }
          }
          if (defines._areMiscDirty) {
            defines.ANISOTROPIC_LEGACY = this._legacy;
          }
        } else {
          defines.ANISOTROPIC = false;
          defines.ANISOTROPIC_TEXTURE = false;
          defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
          defines.ANISOTROPIC_LEGACY = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
            BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
          }
          uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.setTexture("anisotropySampler", this._texture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._texture) {
            this._texture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRAnisotropicConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.ANISOTROPIC) {
          fallbacks.addFallback(currentRank++, "ANISOTROPIC");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("anisotropySampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vAnisotropy", size: 3, type: "vec3" },
            { name: "vAnisotropyInfos", size: 2, type: "vec2" },
            { name: "anisotropyMatrix", size: 16, type: "mat4" }
          ]
        };
      }
      /**
       * Parses a anisotropy Configuration from a serialized object.
       * @param source - Serialized object.
       * @param scene Defines the scene we are parsing for
       * @param rootUrl Defines the rootUrl to load from
       */
      parse(source, scene, rootUrl) {
        super.parse(source, scene, rootUrl);
        if (source.legacy === void 0) {
          this.legacy = true;
        }
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsVector2()
    ], PBRAnisotropicConfiguration.prototype, "direction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRAnisotropicConfiguration.prototype, "legacy", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines, PBRSheenConfiguration;
var init_pbrSheenConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialSheenDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SHEEN = false;
        this.SHEEN_TEXTURE = false;
        this.SHEEN_GAMMATEXTURE = false;
        this.SHEEN_TEXTURE_ROUGHNESS = false;
        this.SHEEN_TEXTUREDIRECTUV = 0;
        this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.SHEEN_LINKWITHALBEDO = false;
        this.SHEEN_ROUGHNESS = false;
        this.SHEEN_ALBEDOSCALING = false;
        this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      }
    };
    PBRSheenConfiguration = class extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this._linkSheenWithAlbedo = false;
        this.linkSheenWithAlbedo = false;
        this.intensity = 1;
        this.color = Color3.White();
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._roughness = null;
        this.roughness = null;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._albedoScaling = false;
        this.albedoScaling = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.SheenTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.SHEEN = true;
          defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
          defines.SHEEN_ROUGHNESS = this._roughness !== null;
          defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.SheenTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
                defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
              } else {
                defines.SHEEN_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
                PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
              } else {
                defines.SHEEN_TEXTURE_ROUGHNESS = false;
              }
            }
          }
        } else {
          defines.SHEEN = false;
          defines.SHEEN_TEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS = false;
          defines.SHEEN_LINKWITHALBEDO = false;
          defines.SHEEN_ROUGHNESS = false;
          defines.SHEEN_ALBEDOSCALING = false;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.SHEEN_GAMMATEXTURE = false;
          defines.SHEEN_TEXTUREDIRECTUV = 0;
          defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d;
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._textureRoughness) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._textureRoughness) == null ? void 0 : _d.level) ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "sheen");
            }
            if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
            }
          }
          uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
          if (this._roughness !== null) {
            uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenSampler", this._texture);
          }
          if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) == null ? void 0 : _a.dispose();
          (_b = this._textureRoughness) == null ? void 0 : _b.dispose();
        }
      }
      getClassName() {
        return "PBRSheenConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SHEEN) {
          fallbacks.addFallback(currentRank++, "SHEEN");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("sheenSampler", "sheenRoughnessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vSheenColor", size: 4, type: "vec4" },
            { name: "vSheenRoughness", size: 1, type: "float" },
            { name: "vSheenInfos", size: 4, type: "vec4" },
            { name: "sheenMatrix", size: 16, type: "mat4" },
            { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
    __decorate([
      serialize()
    ], PBRSheenConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSheenConfiguration.prototype, "color", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "roughness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "albedoScaling", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines, PBRSubSurfaceConfiguration;
var init_pbrSubSurfaceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_math_vector();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialSubSurfaceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SUBSURFACE = false;
        this.SS_REFRACTION = false;
        this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
        this.SS_TRANSLUCENCY = false;
        this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
        this.SS_SCATTERING = false;
        this.SS_DISPERSION = false;
        this.SS_THICKNESSANDMASK_TEXTURE = false;
        this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
        this.SS_HAS_THICKNESS = false;
        this.SS_REFRACTIONINTENSITY_TEXTURE = false;
        this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
        this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
        this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
        this.SS_REFRACTIONMAP_3D = false;
        this.SS_REFRACTIONMAP_OPPOSITEZ = false;
        this.SS_LODINREFRACTIONALPHA = false;
        this.SS_GAMMAREFRACTION = false;
        this.SS_RGBDREFRACTION = false;
        this.SS_LINEARSPECULARREFRACTION = false;
        this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
        this.SS_ALBEDOFORREFRACTIONTINT = false;
        this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
        this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        this.SS_USE_THICKNESS_AS_DEPTH = false;
        this.SS_USE_GLTF_TEXTURES = false;
      }
    };
    PBRSubSurfaceConfiguration = class extends MaterialPluginBase {
      /**
       * Diffusion profile for subsurface scattering.
       * Useful for better scattering in the skins or foliages.
       */
      get scatteringDiffusionProfile() {
        if (!this._scene.subSurfaceConfiguration) {
          return null;
        }
        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
      }
      set scatteringDiffusionProfile(c) {
        if (!this._scene.enableSubSurfaceForPrePass()) {
          return;
        }
        if (c) {
          this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
        }
      }
      /**
       * Index of refraction of the material's volume.
       * https://en.wikipedia.org/wiki/List_of_refractive_indices
       *
       * This ONLY impacts refraction. If not provided or given a non-valid value,
       * the volume will use the same IOR as the surface.
       */
      get volumeIndexOfRefraction() {
        if (this._volumeIndexOfRefraction >= 1) {
          return this._volumeIndexOfRefraction;
        }
        return this._indexOfRefraction;
      }
      set volumeIndexOfRefraction(value) {
        if (value >= 1) {
          this._volumeIndexOfRefraction = value;
        } else {
          this._volumeIndexOfRefraction = -1;
        }
      }
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /** @internal */
      _markScenePrePassDirty() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
        this._internalMarkScenePrePassDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
        this._isRefractionEnabled = false;
        this.isRefractionEnabled = false;
        this._isTranslucencyEnabled = false;
        this.isTranslucencyEnabled = false;
        this._isDispersionEnabled = false;
        this.isDispersionEnabled = false;
        this._isScatteringEnabled = false;
        this.isScatteringEnabled = false;
        this._scatteringDiffusionProfileIndex = 0;
        this.refractionIntensity = 1;
        this.translucencyIntensity = 1;
        this.useAlbedoToTintRefraction = false;
        this.useAlbedoToTintTranslucency = false;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._refractionTexture = null;
        this.refractionTexture = null;
        this._indexOfRefraction = 1.5;
        this.indexOfRefraction = 1.5;
        this._volumeIndexOfRefraction = -1;
        this._invertRefractionY = false;
        this.invertRefractionY = false;
        this._linkRefractionWithTransparency = false;
        this.linkRefractionWithTransparency = false;
        this.minimumThickness = 0;
        this.maximumThickness = 1;
        this.useThicknessAsDepth = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.dispersion = 0;
        this.diffusionDistance = Color3.White();
        this._useMaskFromThicknessTexture = false;
        this.useMaskFromThicknessTexture = false;
        this._refractionIntensityTexture = null;
        this.refractionIntensityTexture = null;
        this._translucencyIntensityTexture = null;
        this.translucencyIntensityTexture = null;
        this.translucencyColor = null;
        this._translucencyColorTexture = null;
        this.translucencyColorTexture = null;
        this._useGltfStyleTextures = true;
        this.useGltfStyleTextures = true;
        this._scene = material.getScene();
        this.registerForExtraEvents = true;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
              if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
              if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const refractionTexture = this._getRefractionTexture(scene);
            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
              if (!refractionTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          defines.SUBSURFACE = false;
          defines.SS_DISPERSION = false;
          defines.SS_TRANSLUCENCY = false;
          defines.SS_SCATTERING = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
          return;
        }
        if (defines._areTexturesDirty) {
          defines.SUBSURFACE = true;
          defines.SS_DISPERSION = this._isDispersionEnabled;
          defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_SCATTERING = this._isScatteringEnabled;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
                PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
              }
              if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
                PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
              }
              if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
                PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
              }
              if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
                PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, "SS_TRANSLUCENCYCOLOR_TEXTURE");
                defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;
              }
            }
          }
          defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
          defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;
          if (this._isRefractionEnabled) {
            if (scene.texturesEnabled) {
              const refractionTexture = this._getRefractionTexture(scene);
              if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
                defines.SS_REFRACTION = true;
                defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
                defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
                defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
                defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
                defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
                defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
                defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
                defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
                defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
                defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
              }
            }
          }
          if (this._isTranslucencyEnabled) {
            defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
          }
        }
      }
      /**
       * Binds the material data (this function is called even if mustRebind() returns false)
       * @param uniformBuffer defines the Uniform buffer to fill in.
       * @param scene defines the scene the material belongs to.
       * @param engine defines the engine the material belongs to.
       * @param subMesh the submesh to bind data for
       */
      hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        if (this.maximumThickness === 0 && this.minimumThickness === 0) {
          uniformBuffer.updateFloat2("vThicknessParam", 0, 0);
        } else {
          subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
          const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
          uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const realTimeFiltering = this._material.realTimeFiltering;
        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
        const refractionTexture = this._getRefractionTexture(scene);
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
            BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
            BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);
            BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, "translucencyColor");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
            BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
            let depth = 1;
            if (!refractionTexture.isCube) {
              if (refractionTexture.depth) {
                depth = refractionTexture.depth;
              }
            }
            const width = refractionTexture.getSize().width;
            const refractionIor = this.volumeIndexOfRefraction;
            uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
            uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
            if (realTimeFiltering) {
              uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Math.log2(width));
            }
            if (refractionTexture.boundingBoxSize) {
              const cubeTexture = refractionTexture;
              uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._isScatteringEnabled) {
            uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
          }
          uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
          uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
          uniformBuffer.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0);
          uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
          uniformBuffer.updateFloat("dispersion", this.dispersion);
        }
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
            uniformBuffer.setTexture("translucencyColorSampler", this._translucencyColorTexture);
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            if (lodBasedMicrosurface) {
              uniformBuffer.setTexture("refractionSampler", refractionTexture);
            } else {
              uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
            }
          }
        }
      }
      /**
       * Returns the texture used for refraction or null if none is used.
       * @param scene defines the scene the material belongs to.
       * @returns - Refraction texture if present.  If no refraction texture and refraction
       * is linked with transparency, returns environment texture.  Otherwise, returns null.
       */
      _getRefractionTexture(scene) {
        if (this._refractionTexture) {
          return this._refractionTexture;
        }
        if (this._isRefractionEnabled) {
          return scene.environmentTexture;
        }
        return null;
      }
      /**
       * Returns true if alpha blending should be disabled.
       */
      get disableAlphaBlending() {
        return this._isRefractionEnabled && this._linkRefractionWithTransparency;
      }
      /**
       * Fills the list of render target textures.
       * @param renderTargets the list of render targets to update
       */
      fillRenderTargetTextures(renderTargets) {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          renderTargets.push(this._refractionTexture);
        }
      }
      hasTexture(texture) {
        if (this._thicknessTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        if (this._refractionIntensityTexture === texture) {
          return true;
        }
        if (this._translucencyIntensityTexture === texture) {
          return true;
        }
        if (this._translucencyColorTexture === texture) {
          return true;
        }
        return false;
      }
      hasRenderTargetTextures() {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
        if (this._translucencyColorTexture) {
          activeTextures.push(this._translucencyColorTexture);
        }
        if (this._translucencyIntensityTexture) {
          activeTextures.push(this._translucencyIntensityTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          animatables.push(this._refractionTexture);
        }
        if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {
          animatables.push(this._translucencyColorTexture);
        }
        if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {
          animatables.push(this._translucencyIntensityTexture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._thicknessTexture) {
            this._thicknessTexture.dispose();
          }
          if (this._refractionTexture) {
            this._refractionTexture.dispose();
          }
          if (this._translucencyColorTexture) {
            this._translucencyColorTexture.dispose();
          }
          if (this._translucencyIntensityTexture) {
            this._translucencyIntensityTexture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRSubSurfaceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SS_SCATTERING) {
          fallbacks.addFallback(currentRank++, "SS_SCATTERING");
        }
        if (defines.SS_TRANSLUCENCY) {
          fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
            { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
            { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
            { name: "vRefractionInfos", size: 4, type: "vec4" },
            { name: "refractionMatrix", size: 16, type: "mat4" },
            { name: "vThicknessInfos", size: 2, type: "vec2" },
            { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
            { name: "thicknessMatrix", size: 16, type: "mat4" },
            { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
            { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
            { name: "vThicknessParam", size: 2, type: "vec2" },
            { name: "vDiffusionDistance", size: 3, type: "vec3" },
            { name: "vTintColor", size: 4, type: "vec4" },
            { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
            { name: "vRefractionPosition", size: 3, type: "vec3" },
            { name: "vRefractionSize", size: 3, type: "vec3" },
            { name: "scatteringDiffusionProfile", size: 1, type: "float" },
            { name: "dispersion", size: 1, type: "float" },
            { name: "vTranslucencyColor", size: 4, type: "vec4" },
            { name: "vTranslucencyColorInfos", size: 2, type: "vec2" },
            { name: "translucencyColorMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markScenePrePassDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "translucencyColor", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "translucencyColorTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters, PBRMaterialDefines, PBRBaseMaterial;
var init_pbrBaseMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_logger();
    init_smartArray();
    init_brdfTextureTools();
    init_scene();
    init_math_vector();
    init_buffer();
    init_pbrBRDFConfiguration();
    init_prePassConfiguration();
    init_math_color();
    init_imageProcessingConfiguration();
    init_material();
    init_materialDefines();
    init_pushMaterial();
    init_texture();
    init_materialFlags();
    init_baseTexture_polynomial();
    init_effectFallbacks();
    init_pbrClearCoatConfiguration();
    init_pbrIridescenceConfiguration();
    init_pbrAnisotropicConfiguration();
    init_pbrSheenConfiguration();
    init_pbrSubSurfaceConfiguration();
    init_material_detailMapConfiguration();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_materialHelper_geometryrendering();
    onCreatedEffectParameters = { effect: null, subMesh: null };
    PBRMaterialDefines = class extends MaterialDefines {
      /**
       * Initializes the PBR Material defines.
       * @param externalProperties The external properties
       */
      constructor(externalProperties) {
        super(externalProperties);
        this.PBR = true;
        this.NUM_SAMPLES = "0";
        this.REALTIME_FILTERING = false;
        this.IBL_CDF_FILTERING = false;
        this.MAINUV1 = false;
        this.MAINUV2 = false;
        this.MAINUV3 = false;
        this.MAINUV4 = false;
        this.MAINUV5 = false;
        this.MAINUV6 = false;
        this.UV1 = false;
        this.UV2 = false;
        this.UV3 = false;
        this.UV4 = false;
        this.UV5 = false;
        this.UV6 = false;
        this.ALBEDO = false;
        this.GAMMAALBEDO = false;
        this.ALBEDODIRECTUV = 0;
        this.VERTEXCOLOR = false;
        this.BASEWEIGHT = false;
        this.BASEWEIGHTDIRECTUV = 0;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.AMBIENT = false;
        this.AMBIENTDIRECTUV = 0;
        this.AMBIENTINGRAYSCALE = false;
        this.OPACITY = false;
        this.VERTEXALPHA = false;
        this.OPACITYDIRECTUV = 0;
        this.OPACITYRGB = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHABLEND = false;
        this.ALPHAFROMALBEDO = false;
        this.ALPHATESTVALUE = "0.5";
        this.SPECULAROVERALPHA = false;
        this.RADIANCEOVERALPHA = false;
        this.ALPHAFRESNEL = false;
        this.LINEARALPHAFRESNEL = false;
        this.PREMULTIPLYALPHA = false;
        this.EMISSIVE = false;
        this.EMISSIVEDIRECTUV = 0;
        this.GAMMAEMISSIVE = false;
        this.REFLECTIVITY = false;
        this.REFLECTIVITY_GAMMA = false;
        this.REFLECTIVITYDIRECTUV = 0;
        this.SPECULARTERM = false;
        this.MICROSURFACEFROMREFLECTIVITYMAP = false;
        this.MICROSURFACEAUTOMATIC = false;
        this.LODBASEDMICROSFURACE = false;
        this.MICROSURFACEMAP = false;
        this.MICROSURFACEMAPDIRECTUV = 0;
        this.METALLICWORKFLOW = false;
        this.ROUGHNESSSTOREINMETALMAPALPHA = false;
        this.ROUGHNESSSTOREINMETALMAPGREEN = false;
        this.METALLNESSSTOREINMETALMAPBLUE = false;
        this.AOSTOREINMETALMAPRED = false;
        this.METALLIC_REFLECTANCE = false;
        this.METALLIC_REFLECTANCE_GAMMA = false;
        this.METALLIC_REFLECTANCEDIRECTUV = 0;
        this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
        this.REFLECTANCE = false;
        this.REFLECTANCE_GAMMA = false;
        this.REFLECTANCEDIRECTUV = 0;
        this.ENVIRONMENTBRDF = false;
        this.ENVIRONMENTBRDF_RGBD = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.BUMP = false;
        this.BUMPDIRECTUV = 0;
        this.OBJECTSPACE_NORMALMAP = false;
        this.PARALLAX = false;
        this.PARALLAX_RHS = false;
        this.PARALLAXOCCLUSION = false;
        this.NORMALXYSCALE = true;
        this.LIGHTMAP = false;
        this.LIGHTMAPDIRECTUV = 0;
        this.USELIGHTMAPASSHADOWMAP = false;
        this.GAMMALIGHTMAP = false;
        this.RGBDLIGHTMAP = false;
        this.REFLECTION = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.INVERTCUBICMAP = false;
        this.USESPHERICALFROMREFLECTIONMAP = false;
        this.USEIRRADIANCEMAP = false;
        this.USESPHERICALINVERTEX = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.LODINREFLECTIONALPHA = false;
        this.GAMMAREFLECTION = false;
        this.RGBDREFLECTION = false;
        this.LINEARSPECULARREFLECTION = false;
        this.RADIANCEOCCLUSION = false;
        this.HORIZONOCCLUSION = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.PREPASS = false;
        this.PREPASS_COLOR = false;
        this.PREPASS_COLOR_INDEX = -1;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO = false;
        this.PREPASS_ALBEDO_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_SCREENSPACE_DEPTH = false;
        this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_WORLD_NORMAL = false;
        this.PREPASS_WORLD_NORMAL_INDEX = -1;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_LOCAL_POSITION = false;
        this.PREPASS_LOCAL_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_VELOCITY_LINEAR = false;
        this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.NONUNIFORMSCALING = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_POSITION = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.MORPHTARGETS_UV2 = false;
        this.MORPHTARGETS_COLOR = false;
        this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
        this.MORPHTARGETTEXTURE_HASNORMALS = false;
        this.MORPHTARGETTEXTURE_HASTANGENTS = false;
        this.MORPHTARGETTEXTURE_HASUVS = false;
        this.MORPHTARGETTEXTURE_HASUV2S = false;
        this.MORPHTARGETTEXTURE_HASCOLORS = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = 0;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.EXPOSURE = false;
        this.MULTIVIEW = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        this.USEPHYSICALLIGHTFALLOFF = false;
        this.USEGLTFLIGHTFALLOFF = false;
        this.TWOSIDEDLIGHTING = false;
        this.SHADOWFLOAT = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.LOGARITHMICDEPTH = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.AREALIGHTSUPPORTED = true;
        this.FORCENORMALFORWARD = false;
        this.SPECULARAA = false;
        this.UNLIT = false;
        this.DECAL_AFTER_DETAIL = false;
        this.DEBUGMODE = 0;
        this.rebuild();
      }
      /**
       * Resets the PBR Material defines.
       */
      reset() {
        super.reset();
        this.ALPHATESTVALUE = "0.5";
        this.PBR = true;
        this.NORMALXYSCALE = true;
      }
    };
    PBRBaseMaterial = class _PBRBaseMaterial extends PushMaterial {
      /**
       * Enables realtime filtering on the texture.
       */
      get realTimeFiltering() {
        return this._realTimeFiltering;
      }
      set realTimeFiltering(b) {
        this._realTimeFiltering = b;
        this.markAsDirty(1);
      }
      /**
       * Quality switch for realtime filtering
       */
      get realTimeFilteringQuality() {
        return this._realTimeFilteringQuality;
      }
      set realTimeFilteringQuality(n) {
        this._realTimeFilteringQuality = n;
        this.markAsDirty(1);
      }
      /**
       * Can this material render to several textures at once
       */
      get canRenderToMRT() {
        return true;
      }
      /**
       * Attaches a new image processing configuration to the PBR Material.
       * @param configuration
       */
      _attachImageProcessingConfiguration(configuration) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
            this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      }
      /**
       * Instantiates a new PBRMaterial instance.
       *
       * @param name The material name
       * @param scene The scene the material will be use in.
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, void 0, forceGLSL || _PBRBaseMaterial.ForceGLSL);
        this._directIntensity = 1;
        this._emissiveIntensity = 1;
        this._environmentIntensity = 1;
        this._specularIntensity = 1;
        this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
        this._disableBumpMap = false;
        this._albedoTexture = null;
        this._baseWeightTexture = null;
        this._ambientTexture = null;
        this._ambientTextureStrength = 1;
        this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this._opacityTexture = null;
        this._reflectionTexture = null;
        this._emissiveTexture = null;
        this._reflectivityTexture = null;
        this._metallicTexture = null;
        this._metallic = null;
        this._roughness = null;
        this._metallicF0Factor = 1;
        this._metallicReflectanceColor = Color3.White();
        this._useOnlyMetallicFromMetallicReflectanceTexture = false;
        this._metallicReflectanceTexture = null;
        this._reflectanceTexture = null;
        this._microSurfaceTexture = null;
        this._bumpTexture = null;
        this._lightmapTexture = null;
        this._ambientColor = new Color3(0, 0, 0);
        this._albedoColor = new Color3(1, 1, 1);
        this._baseWeight = 1;
        this._reflectivityColor = new Color3(1, 1, 1);
        this._reflectionColor = new Color3(1, 1, 1);
        this._emissiveColor = new Color3(0, 0, 0);
        this._microSurface = 0.9;
        this._useLightmapAsShadowmap = false;
        this._useHorizonOcclusion = true;
        this._useRadianceOcclusion = true;
        this._useAlphaFromAlbedoTexture = false;
        this._useSpecularOverAlpha = true;
        this._useMicroSurfaceFromReflectivityMapAlpha = false;
        this._useRoughnessFromMetallicTextureAlpha = true;
        this._useRoughnessFromMetallicTextureGreen = false;
        this._useMetallnessFromMetallicTextureBlue = false;
        this._useAmbientOcclusionFromMetallicTextureRed = false;
        this._useAmbientInGrayScale = false;
        this._useAutoMicroSurfaceFromReflectivityMap = false;
        this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
        this._useRadianceOverAlpha = true;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this._parallaxScaleBias = 0.05;
        this._disableLighting = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._alphaCutOff = 0.4;
        this._useAlphaFresnel = false;
        this._useLinearAlphaFresnel = false;
        this._environmentBRDFTexture = null;
        this._forceIrradianceInFragment = false;
        this._realTimeFiltering = false;
        this._realTimeFilteringQuality = 8;
        this._forceNormalForward = false;
        this._enableSpecularAntiAliasing = false;
        this._imageProcessingObserver = null;
        this._renderTargets = new SmartArray(16);
        this._globalAmbientColor = new Color3(0, 0, 0);
        this._unlit = false;
        this._applyDecalMapAfterDetailMap = false;
        this._debugMode = 0;
        this._shadersLoaded = false;
        this._breakShaderLoadedCheck = false;
        this.debugMode = 0;
        this.debugLimit = -1;
        this.debugFactor = 1;
        this._cacheHasRenderTargetTextures = false;
        this.brdf = new PBRBRDFConfiguration(this);
        this.clearCoat = new PBRClearCoatConfiguration(this);
        this.iridescence = new PBRIridescenceConfiguration(this);
        this.anisotropy = new PBRAnisotropicConfiguration(this);
        this.sheen = new PBRSheenConfiguration(this);
        this.subSurface = new PBRSubSurfaceConfiguration(this);
        this.detailMap = new DetailMapConfiguration(this);
        this._attachImageProcessingConfiguration(null);
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
        this.prePassConfiguration = new PrePassConfiguration();
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      /**
       * Can this material render to prepass
       */
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      /**
       * @returns the name of the material class.
       */
      getClassName() {
        return "PBRBaseMaterial";
      }
      /**
       * Returns true if alpha blending should be disabled.
       */
      get _disableAlphaBlending() {
        var _a;
        return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || ((_a = this.subSurface) == null ? void 0 : _a.disableAlphaBlending);
      }
      /**
       * @returns whether or not this material should be rendered in alpha blend mode.
       */
      needAlphaBlending() {
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsBlend;
        }
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
      }
      /**
       * @returns whether or not this material should be rendered in alpha test mode.
       */
      needAlphaTesting() {
        var _a;
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsTest;
        }
        if ((_a = this.subSurface) == null ? void 0 : _a.disableAlphaBlending) {
          return false;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
      }
      /**
       * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
       */
      _shouldUseAlphaFromAlbedoTexture() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
      }
      /**
       * @returns whether or not there is a usable alpha channel for transparency.
       */
      _hasAlphaChannel() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
      }
      /**
       * @returns the texture used for the alpha test.
       */
      getAlphaTestTexture() {
        return this._albedoTexture;
      }
      /**
       * Specifies that the submesh is ready to be used.
       * @param mesh - BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
       * @param useInstances - Specifies that instances should be used.
       * @returns - boolean indicating that the submesh is ready or not.
       */
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        var _a;
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(4, this._eventInfo);
          subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
        }
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              if (!this._albedoTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              if (!this._baseWeightTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              }
              if (reflectionTexture.irradianceTexture) {
                if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else {
                if (!reflectionTexture.sphericalPolynomial && ((_a = reflectionTexture.getInternalTexture()) == null ? void 0 : _a._sphericalPolynomialPromise)) {
                  return false;
                }
              }
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                if (!this._metallicTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else if (this._reflectivityTexture) {
                if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._metallicReflectanceTexture) {
                if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._reflectanceTexture) {
                if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._microSurfaceTexture) {
                if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentBRDFTexture.isReady()) {
                return false;
              }
            }
          }
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
        }
        if (defines["AREALIGHTUSED"]) {
          for (let index = 0; index < mesh.lightSources.length; index++) {
            if (!mesh.lightSources[index]._isReady()) {
              return false;
            }
          }
        }
        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
        }
        const previousEffect = subMesh.effect;
        const lightDisposed = defines._areLightsDisposed;
        let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        let forceWasNotReadyPreviously = false;
        if (effect) {
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters.effect = effect;
            onCreatedEffectParameters.subMesh = subMesh;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
          }
          if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
            effect = previousEffect;
            defines.markAsUnprocessed();
            forceWasNotReadyPreviously = this.isFrozen;
            if (lightDisposed) {
              defines._areLightsDisposed = true;
              return false;
            }
          } else {
            scene.resetCachedMaterial();
            subMesh.setEffect(effect, defines, this._materialContext);
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Specifies if the material uses metallic roughness workflow.
       * @returns boolean specifying if the material uses metallic roughness workflow.
       */
      isMetallicWorkflow() {
        if (this._metallic != null || this._roughness != null || this._metallicTexture) {
          return true;
        }
        return false;
      }
      _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {
        this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
        if (!defines.isDirty) {
          return null;
        }
        defines.markAsProcessed();
        const scene = this.getScene();
        const engine = scene.getEngine();
        const fallbacks = new EffectFallbacks();
        let fallbackRank = 0;
        if (defines.USESPHERICALINVERTEX) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
        }
        if (defines.FOG) {
          fallbacks.addFallback(fallbackRank, "FOG");
        }
        if (defines.SPECULARAA) {
          fallbacks.addFallback(fallbackRank, "SPECULARAA");
        }
        if (defines.POINTSIZE) {
          fallbacks.addFallback(fallbackRank, "POINTSIZE");
        }
        if (defines.LOGARITHMICDEPTH) {
          fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
        }
        if (defines.PARALLAX) {
          fallbacks.addFallback(fallbackRank, "PARALLAX");
        }
        if (defines.PARALLAX_RHS) {
          fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
        }
        if (defines.PARALLAXOCCLUSION) {
          fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
        }
        if (defines.ENVIRONMENTBRDF) {
          fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
        }
        if (defines.TANGENT) {
          fallbacks.addFallback(fallbackRank++, "TANGENT");
        }
        if (defines.BUMP) {
          fallbacks.addFallback(fallbackRank++, "BUMP");
        }
        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
        if (defines.SPECULARTERM) {
          fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
        }
        if (defines.USESPHERICALFROMREFLECTIONMAP) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
        }
        if (defines.USEIRRADIANCEMAP) {
          fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
        }
        if (defines.LIGHTMAP) {
          fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
        }
        if (defines.NORMAL) {
          fallbacks.addFallback(fallbackRank++, "NORMAL");
        }
        if (defines.AMBIENT) {
          fallbacks.addFallback(fallbackRank++, "AMBIENT");
        }
        if (defines.EMISSIVE) {
          fallbacks.addFallback(fallbackRank++, "EMISSIVE");
        }
        if (defines.VERTEXCOLOR) {
          fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
        }
        if (defines.MORPHTARGETS) {
          fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
        }
        if (defines.MULTIVIEW) {
          fallbacks.addFallback(0, "MULTIVIEW");
        }
        const attribs = [VertexBuffer.PositionKind];
        if (defines.NORMAL) {
          attribs.push(VertexBuffer.NormalKind);
        }
        if (defines.TANGENT) {
          attribs.push(VertexBuffer.TangentKind);
        }
        for (let i = 1; i <= 6; ++i) {
          if (defines["UV" + i]) {
            attribs.push(`uv${i === 1 ? "" : i}`);
          }
        }
        if (defines.VERTEXCOLOR) {
          attribs.push(VertexBuffer.ColorKind);
        }
        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
        PrepareAttributesForInstances(attribs, defines);
        PrepareAttributesForMorphTargets(attribs, mesh, defines);
        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        let shaderName = "pbr";
        const uniforms = [
          "world",
          "view",
          "viewProjection",
          "vEyePosition",
          "vLightsType",
          "vAmbientColor",
          "vAlbedoColor",
          "baseWeight",
          "vReflectivityColor",
          "vMetallicReflectanceFactors",
          "vEmissiveColor",
          "visibility",
          "vReflectionColor",
          "vFogInfos",
          "vFogColor",
          "pointSize",
          "vAlbedoInfos",
          "vBaseWeightInfos",
          "vAmbientInfos",
          "vOpacityInfos",
          "vReflectionInfos",
          "vReflectionPosition",
          "vReflectionSize",
          "vEmissiveInfos",
          "vReflectivityInfos",
          "vReflectionFilteringInfo",
          "vMetallicReflectanceInfos",
          "vReflectanceInfos",
          "vMicroSurfaceSamplerInfos",
          "vBumpInfos",
          "vLightmapInfos",
          "mBones",
          "albedoMatrix",
          "baseWeightMatrix",
          "ambientMatrix",
          "opacityMatrix",
          "reflectionMatrix",
          "emissiveMatrix",
          "reflectivityMatrix",
          "normalMatrix",
          "microSurfaceSamplerMatrix",
          "bumpMatrix",
          "lightmapMatrix",
          "metallicReflectanceMatrix",
          "reflectanceMatrix",
          "vLightingIntensity",
          "logarithmicDepthConstant",
          "vSphericalX",
          "vSphericalY",
          "vSphericalZ",
          "vSphericalXX_ZZ",
          "vSphericalYY_ZZ",
          "vSphericalZZ",
          "vSphericalXY",
          "vSphericalYZ",
          "vSphericalZX",
          "vSphericalL00",
          "vSphericalL1_1",
          "vSphericalL10",
          "vSphericalL11",
          "vSphericalL2_2",
          "vSphericalL2_1",
          "vSphericalL20",
          "vSphericalL21",
          "vSphericalL22",
          "vReflectionMicrosurfaceInfos",
          "vTangentSpaceParams",
          "boneTextureWidth",
          "vDebugMode",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ];
        const samplers = [
          "albedoSampler",
          "baseWeightSampler",
          "reflectivitySampler",
          "ambientSampler",
          "emissiveSampler",
          "bumpSampler",
          "lightmapSampler",
          "opacitySampler",
          "reflectionSampler",
          "reflectionSamplerLow",
          "reflectionSamplerHigh",
          "irradianceSampler",
          "microSurfaceSampler",
          "environmentBrdfSampler",
          "boneSampler",
          "metallicReflectanceSampler",
          "reflectanceSampler",
          "morphTargets",
          "oitDepthSampler",
          "oitFrontColorSampler",
          "icdfSampler",
          "areaLightsLTC1Sampler",
          "areaLightsLTC2Sampler"
        ];
        const uniformBuffers = ["Material", "Scene", "Mesh"];
        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
        this._eventInfo.fallbacks = fallbacks;
        this._eventInfo.fallbackRank = fallbackRank;
        this._eventInfo.defines = defines;
        this._eventInfo.uniforms = uniforms;
        this._eventInfo.attributes = attribs;
        this._eventInfo.samplers = samplers;
        this._eventInfo.uniformBuffersNames = uniformBuffers;
        this._eventInfo.customCode = void 0;
        this._eventInfo.mesh = mesh;
        this._eventInfo.indexParameters = indexParameters;
        this._callbackPluginEventGeneric(128, this._eventInfo);
        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
        PrePassConfiguration.AddUniforms(uniforms);
        PrePassConfiguration.AddSamplers(samplers);
        addClipPlaneUniforms(uniforms);
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
        }
        PrepareUniformsAndSamplersList({
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines,
          maxSimultaneousLights: this._maxSimultaneousLights
        });
        const csnrOptions = {};
        if (this.customShaderNameResolve) {
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
        }
        const join = defines.toString();
        const effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled,
          onError,
          indexParameters,
          processFinalCode: csnrOptions.processFinalCode,
          processCodeAfterIncludes: this._eventInfo.customCode,
          multiTarget: defines.PREPASS,
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
            if (this.shaderLanguage === 1) {
              await Promise.all([import("./pbr.vertex-WUO6NJF3.js"), import("./pbr.fragment-XMOQU225.js")]);
            } else {
              await Promise.all([import("./pbr.vertex-XJBLWJNV.js"), import("./pbr.fragment-F6QK4WXI.js")]);
            }
            this._shadersLoaded = true;
          }
        }, engine);
        this._eventInfo.customCode = void 0;
        return effect;
      }
      _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {
        const scene = this.getScene();
        const engine = scene.getEngine();
        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        defines._needNormals = true;
        PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        PrepareDefinesForOIT(scene, defines, oit);
        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
        defines.METALLICWORKFLOW = this.isMetallicWorkflow();
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            defines.ALBEDODIRECTUV = 0;
            defines.BASEWEIGHTDIRECTUV = 0;
            defines.AMBIENTDIRECTUV = 0;
            defines.OPACITYDIRECTUV = 0;
            defines.EMISSIVEDIRECTUV = 0;
            defines.REFLECTIVITYDIRECTUV = 0;
            defines.MICROSURFACEMAPDIRECTUV = 0;
            defines.METALLIC_REFLECTANCEDIRECTUV = 0;
            defines.REFLECTANCEDIRECTUV = 0;
            defines.BUMPDIRECTUV = 0;
            defines.LIGHTMAPDIRECTUV = 0;
            if (engine.getCaps().textureLOD) {
              defines.LODBASEDMICROSFURACE = true;
            }
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
              defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
            } else {
              defines.ALBEDO = false;
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              PrepareDefinesForMergedUV(this._baseWeightTexture, defines, "BASEWEIGHT");
            } else {
              defines.BASEWEIGHT = false;
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
              defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
            } else {
              defines.OPACITY = false;
            }
            const reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.REFLECTION = true;
              defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
              defines.RGBDREFLECTION = reflectionTexture.isRGBD;
              defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
              defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
              if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
                defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
                if (engine._features.needTypeSuffixInShaderConstants) {
                  defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
                }
                defines.REALTIME_FILTERING = true;
                if (this.getScene().iblCdfGenerator) {
                  defines.IBL_CDF_FILTERING = true;
                }
              } else {
                defines.REALTIME_FILTERING = false;
              }
              defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
              defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
              defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              switch (reflectionTexture.coordinatesMode) {
                case Texture.EXPLICIT_MODE:
                  defines.REFLECTIONMAP_EXPLICIT = true;
                  break;
                case Texture.PLANAR_MODE:
                  defines.REFLECTIONMAP_PLANAR = true;
                  break;
                case Texture.PROJECTION_MODE:
                  defines.REFLECTIONMAP_PROJECTION = true;
                  break;
                case Texture.SKYBOX_MODE:
                  defines.REFLECTIONMAP_SKYBOX = true;
                  break;
                case Texture.SPHERICAL_MODE:
                  defines.REFLECTIONMAP_SPHERICAL = true;
                  break;
                case Texture.EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                  defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.CUBIC_MODE:
                case Texture.INVCUBIC_MODE:
                default:
                  defines.REFLECTIONMAP_CUBIC = true;
                  defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
                  break;
              }
              if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
                if (reflectionTexture.irradianceTexture) {
                  defines.USEIRRADIANCEMAP = true;
                  defines.USESPHERICALFROMREFLECTIONMAP = false;
                  defines.USESPHERICALINVERTEX = false;
                } else if (reflectionTexture.isCube) {
                  defines.USESPHERICALFROMREFLECTIONMAP = true;
                  defines.USEIRRADIANCEMAP = false;
                  if (this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8) {
                    defines.USESPHERICALINVERTEX = false;
                  } else {
                    defines.USESPHERICALINVERTEX = true;
                  }
                }
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONMAP_3D = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              defines.INVERTCUBICMAP = false;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
              defines.USEIRRADIANCEMAP = false;
              defines.USESPHERICALINVERTEX = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
              defines.LODINREFLECTIONALPHA = false;
              defines.GAMMAREFLECTION = false;
              defines.RGBDREFLECTION = false;
              defines.LINEARSPECULARREFLECTION = false;
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
              defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
              defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
              defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
            } else {
              defines.EMISSIVE = false;
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
                defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
                defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
                defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
                defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
                defines.REFLECTIVITY_GAMMA = false;
              } else if (this._reflectivityTexture) {
                PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
                defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
                defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
                defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
              } else {
                defines.REFLECTIVITY = false;
              }
              if (this._metallicReflectanceTexture || this._reflectanceTexture) {
                defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;
                if (this._metallicReflectanceTexture) {
                  PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
                  defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
                } else {
                  defines.METALLIC_REFLECTANCE = false;
                }
                if (this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
                  PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
                  defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
                } else {
                  defines.REFLECTANCE = false;
                }
              } else {
                defines.METALLIC_REFLECTANCE = false;
                defines.REFLECTANCE = false;
              }
              if (this._microSurfaceTexture) {
                PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
              } else {
                defines.MICROSURFACEMAP = false;
              }
            } else {
              defines.REFLECTIVITY = false;
              defines.MICROSURFACEMAP = false;
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
              if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                defines.PARALLAX = true;
                defines.PARALLAX_RHS = scene.useRightHandedSystem;
                defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
              } else {
                defines.PARALLAX = false;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
              defines.PARALLAX = false;
              defines.PARALLAX_RHS = false;
              defines.PARALLAXOCCLUSION = false;
              defines.OBJECTSPACE_NORMALMAP = false;
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.ENVIRONMENTBRDF = true;
              defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
            } else {
              defines.ENVIRONMENTBRDF = false;
              defines.ENVIRONMENTBRDF_RGBD = false;
            }
            if (this._shouldUseAlphaFromAlbedoTexture()) {
              defines.ALPHAFROMALBEDO = true;
            } else {
              defines.ALPHAFROMALBEDO = false;
            }
          }
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = false;
          } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = true;
          } else {
            defines.USEPHYSICALLIGHTFALLOFF = true;
            defines.USEGLTFLIGHTFALLOFF = false;
          }
          defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
          if (!this.backFaceCulling && this._twoSidedLighting) {
            defines.TWOSIDEDLIGHTING = true;
          } else {
            defines.TWOSIDEDLIGHTING = false;
          }
          defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
        }
        if (defines._areTexturesDirty || defines._areMiscDirty) {
          defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
          defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
          defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        defines.FORCENORMALFORWARD = this._forceNormalForward;
        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
        if (defines._areMiscDirty) {
          PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap);
          defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
          defines.DEBUGMODE = this._debugMode;
        }
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
      }
      /**
       * Force shader compilation
       * @param mesh - Define the mesh we want to force the compilation for
       * @param onCompiled - Define a callback triggered when the compilation completes
       * @param options - Define the options used to create the compilation
       */
      forceCompilation(mesh, onCompiled, options) {
        const localOptions = {
          clipPlane: false,
          useInstances: false,
          ...options
        };
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        this._callbackPluginEventGeneric(4, this._eventInfo);
        const checkReady = () => {
          if (this._breakShaderLoadedCheck) {
            return;
          }
          const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
          const effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters.effect = effect;
            onCreatedEffectParameters.subMesh = null;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
          }
          if (effect.isReady()) {
            if (onCompiled) {
              onCompiled(this);
            }
          } else {
            effect.onCompileObservable.add(() => {
              if (onCompiled) {
                onCompiled(this);
              }
            });
          }
        };
        checkReady();
      }
      /**
       * Initializes the uniform buffer layout for the shader.
       */
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("vAlbedoInfos", 2);
        ubo.addUniform("vBaseWeightInfos", 2);
        ubo.addUniform("vAmbientInfos", 4);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vReflectivityInfos", 3);
        ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
        ubo.addUniform("vReflectionInfos", 2);
        ubo.addUniform("vReflectionFilteringInfo", 2);
        ubo.addUniform("vReflectionPosition", 3);
        ubo.addUniform("vReflectionSize", 3);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("albedoMatrix", 16);
        ubo.addUniform("baseWeightMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("reflectivityMatrix", 16);
        ubo.addUniform("microSurfaceSamplerMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("reflectionMatrix", 16);
        ubo.addUniform("vReflectionColor", 3);
        ubo.addUniform("vAlbedoColor", 4);
        ubo.addUniform("baseWeight", 1);
        ubo.addUniform("vLightingIntensity", 4);
        ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("vReflectivityColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vAmbientColor", 3);
        ubo.addUniform("vDebugMode", 2);
        ubo.addUniform("vMetallicReflectanceFactors", 4);
        ubo.addUniform("vMetallicReflectanceInfos", 2);
        ubo.addUniform("metallicReflectanceMatrix", 16);
        ubo.addUniform("vReflectanceInfos", 2);
        ubo.addUniform("reflectanceMatrix", 16);
        ubo.addUniform("vSphericalL00", 3);
        ubo.addUniform("vSphericalL1_1", 3);
        ubo.addUniform("vSphericalL10", 3);
        ubo.addUniform("vSphericalL11", 3);
        ubo.addUniform("vSphericalL2_2", 3);
        ubo.addUniform("vSphericalL2_1", 3);
        ubo.addUniform("vSphericalL20", 3);
        ubo.addUniform("vSphericalL21", 3);
        ubo.addUniform("vSphericalL22", 3);
        ubo.addUniform("vSphericalX", 3);
        ubo.addUniform("vSphericalY", 3);
        ubo.addUniform("vSphericalZ", 3);
        ubo.addUniform("vSphericalXX_ZZ", 3);
        ubo.addUniform("vSphericalYY_ZZ", 3);
        ubo.addUniform("vSphericalZZ", 3);
        ubo.addUniform("vSphericalXY", 3);
        ubo.addUniform("vSphericalYZ", 3);
        ubo.addUniform("vSphericalZX", 3);
        super.buildUniformLayout();
      }
      /**
       * Binds the submesh data.
       * @param world - The world matrix.
       * @param mesh - The BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.
       */
      bindForSubMesh(world, mesh, subMesh) {
        var _a, _b, _c;
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        const engine = scene.getEngine();
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
        let reflectionTexture = null;
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          reflectionTexture = this._getReflectionTexture();
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
            if (scene.texturesEnabled) {
              if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
                BindTextureMatrix(this._albedoTexture, ubo, "albedo");
              }
              if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
                ubo.updateFloat2("vBaseWeightInfos", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);
                BindTextureMatrix(this._baseWeightTexture, ubo, "baseWeight");
              }
              if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
                ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
                BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
                ubo.updateFloat2("vReflectionInfos", reflectionTexture.level * scene.iblIntensity, 0);
                if (reflectionTexture.boundingBoxSize) {
                  const cubeTexture = reflectionTexture;
                  ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
                }
                if (this.realTimeFiltering) {
                  const width = reflectionTexture.getSize().width;
                  ubo.updateFloat2("vReflectionFilteringInfo", width, Math.log2(width));
                }
                if (!defines.USEIRRADIANCEMAP) {
                  const polynomials = reflectionTexture.sphericalPolynomial;
                  if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                    if (defines.SPHERICAL_HARMONICS) {
                      const preScaledHarmonics = polynomials.preScaledHarmonics;
                      ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
                      ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                      ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
                      ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
                      ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                      ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                      ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
                      ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
                      ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
                    } else {
                      ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                      ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                      ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                      ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                      ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                      ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                      ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                    }
                  }
                }
                ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
              }
              if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (MaterialFlags.SpecularTextureEnabled) {
                if (this._metallicTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
                  BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
                } else if (this._reflectivityTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
                  BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
                }
                if (this._metallicReflectanceTexture) {
                  ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
                  BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
                }
                if (this._reflectanceTexture && defines.REFLECTANCE) {
                  ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
                  BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
                }
                if (this._microSurfaceTexture) {
                  ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
                  BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
                }
              }
              if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
                BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.METALLICWORKFLOW) {
              TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
              TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
              ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
              const ior = ((_a = this.subSurface) == null ? void 0 : _a._indexOfRefraction) ?? 1.5;
              const outsideIOR = 1;
              const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
              this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
              const metallicF90 = this._metallicF0Factor;
              ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
            } else {
              ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
            }
            ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor3("vReflectionColor", this._reflectionColor);
            if (!defines.SS_REFRACTION && ((_b = this.subSurface) == null ? void 0 : _b._linkRefractionWithTransparency)) {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
            } else {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
            }
            ubo.updateFloat("baseWeight", this._baseWeight);
            this._lightingInfos.x = this._directIntensity;
            this._lightingInfos.y = this._emissiveIntensity;
            this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
            this._lightingInfos.w = this._specularIntensity;
            ubo.updateVector4("vLightingIntensity", this._lightingInfos);
            scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
            ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
          }
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              ubo.setTexture("albedoSampler", this._albedoTexture);
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              ubo.setTexture("baseWeightSampler", this._baseWeightTexture);
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              ubo.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              ubo.setTexture("opacitySampler", this._opacityTexture);
            }
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (defines.LODBASEDMICROSFURACE) {
                ubo.setTexture("reflectionSampler", reflectionTexture);
              } else {
                ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
                ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
                ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
              }
              if (defines.USEIRRADIANCEMAP) {
                ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
              }
              const cdfGenerator = this.getScene().iblCdfGenerator;
              if (this.realTimeFiltering && cdfGenerator) {
                ubo.setTexture("icdfSampler", cdfGenerator.getIcdfTexture());
              }
            }
            if (defines.ENVIRONMENTBRDF) {
              ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              ubo.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              ubo.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                ubo.setTexture("reflectivitySampler", this._metallicTexture);
              } else if (this._reflectivityTexture) {
                ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
              }
              if (this._metallicReflectanceTexture) {
                ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
              }
              if (this._reflectanceTexture && defines.REFLECTANCE) {
                ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
              }
              if (this._microSurfaceTexture) {
                ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
              }
            }
            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              ubo.setTexture("bumpSampler", this._bumpTexture);
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          bindClipPlane(this._activeEffect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS) {
            this.bindView(effect);
          }
          BindFogParameters(scene, mesh, this._activeEffect, true);
          if (defines.NUM_MORPH_INFLUENCERS) {
            BindMorphTargetParameters(mesh, this._activeEffect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            (_c = mesh.bakedVertexAnimationManager) == null ? void 0 : _c.bind(effect, defines.INSTANCES);
          }
          this._imageProcessingConfiguration.bind(this._activeEffect);
          BindLogDepth(defines, this._activeEffect, scene);
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
        ubo.update();
      }
      /**
       * Returns the animatable textures.
       * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
       * @returns - Array of animatable textures.
       */
      getAnimatables() {
        const results = super.getAnimatables();
        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
          results.push(this._albedoTexture);
        }
        if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {
          results.push(this._baseWeightTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
          results.push(this._metallicTexture);
        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
          results.push(this._reflectivityTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
          results.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
          results.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
          results.push(this._microSurfaceTexture);
        }
        return results;
      }
      /**
       * Returns the texture used for reflections.
       * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
       */
      _getReflectionTexture() {
        if (this._reflectionTexture) {
          return this._reflectionTexture;
        }
        return this.getScene().environmentTexture;
      }
      /**
       * Returns an array of the actively used textures.
       * @returns - Array of BaseTextures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._albedoTexture) {
          activeTextures.push(this._albedoTexture);
        }
        if (this._baseWeightTexture) {
          activeTextures.push(this._baseWeightTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._reflectivityTexture) {
          activeTextures.push(this._reflectivityTexture);
        }
        if (this._metallicTexture) {
          activeTextures.push(this._metallicTexture);
        }
        if (this._metallicReflectanceTexture) {
          activeTextures.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture) {
          activeTextures.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture) {
          activeTextures.push(this._microSurfaceTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        return activeTextures;
      }
      /**
       * Checks to see if a texture is used in the material.
       * @param texture - Base texture to use.
       * @returns - Boolean specifying if a texture is used in the material.
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._albedoTexture === texture) {
          return true;
        }
        if (this._baseWeightTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._reflectivityTexture === texture) {
          return true;
        }
        if (this._metallicTexture === texture) {
          return true;
        }
        if (this._metallicReflectanceTexture === texture) {
          return true;
        }
        if (this._reflectanceTexture === texture) {
          return true;
        }
        if (this._microSurfaceTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        return false;
      }
      /**
       * Sets the required values to the prepass renderer.
       * It can't be sets when subsurface scattering of this material is disabled.
       * When scene have ability to enable subsurface prepass effect, it will enable.
       * @returns - If prepass is enabled or not.
       */
      setPrePassRenderer() {
        var _a;
        if (!((_a = this.subSurface) == null ? void 0 : _a.isScatteringEnabled)) {
          return false;
        }
        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
        if (subSurfaceConfiguration) {
          subSurfaceConfiguration.enabled = true;
        }
        return true;
      }
      /**
       * Disposes the resources of the material.
       * @param forceDisposeEffect - Forces the disposal of effects.
       * @param forceDisposeTextures - Forces the disposal of all textures.
       */
      dispose(forceDisposeEffect, forceDisposeTextures) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        this._breakShaderLoadedCheck = true;
        if (forceDisposeTextures) {
          if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
            this._environmentBRDFTexture.dispose();
          }
          (_a = this._albedoTexture) == null ? void 0 : _a.dispose();
          (_b = this._baseWeightTexture) == null ? void 0 : _b.dispose();
          (_c = this._ambientTexture) == null ? void 0 : _c.dispose();
          (_d = this._opacityTexture) == null ? void 0 : _d.dispose();
          (_e = this._reflectionTexture) == null ? void 0 : _e.dispose();
          (_f = this._emissiveTexture) == null ? void 0 : _f.dispose();
          (_g = this._metallicTexture) == null ? void 0 : _g.dispose();
          (_h = this._reflectivityTexture) == null ? void 0 : _h.dispose();
          (_i = this._bumpTexture) == null ? void 0 : _i.dispose();
          (_j = this._lightmapTexture) == null ? void 0 : _j.dispose();
          (_k = this._metallicReflectanceTexture) == null ? void 0 : _k.dispose();
          (_l = this._reflectanceTexture) == null ? void 0 : _l.dispose();
          (_m = this._microSurfaceTexture) == null ? void 0 : _m.dispose();
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
    };
    PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
    PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
    PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
    PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
    PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
    PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
    PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
    PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
    PBRBaseMaterial.ForceGLSL = false;
    __decorate([
      serializeAsImageProcessingConfiguration()
    ], PBRBaseMaterial.prototype, "_imageProcessingConfiguration", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBaseMaterial.prototype, "debugMode", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial;
var init_pbrMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_brdfTextureTools();
    init_math_color();
    init_pbrBaseMaterial();
    init_typeStore();
    init_material();
    init_decorators_serialization();
    PBRMaterial = class _PBRMaterial extends PBRBaseMaterial {
      /**
       * Stores the refracted light information in a texture.
       */
      get refractionTexture() {
        return this.subSurface.refractionTexture;
      }
      set refractionTexture(value) {
        this.subSurface.refractionTexture = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        } else if (!this.subSurface.linkRefractionWithTransparency) {
          this.subSurface.isRefractionEnabled = false;
        }
      }
      /**
       * Index of refraction of the material base layer.
       * https://en.wikipedia.org/wiki/List_of_refractive_indices
       *
       * This does not only impact refraction but also the Base F0 of Dielectric Materials.
       *
       * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
       */
      get indexOfRefraction() {
        return this.subSurface.indexOfRefraction;
      }
      set indexOfRefraction(value) {
        this.subSurface.indexOfRefraction = value;
      }
      /**
       * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
       */
      get invertRefractionY() {
        return this.subSurface.invertRefractionY;
      }
      set invertRefractionY(value) {
        this.subSurface.invertRefractionY = value;
      }
      /**
       * This parameters will make the material used its opacity to control how much it is refracting against not.
       * Materials half opaque for instance using refraction could benefit from this control.
       */
      get linkRefractionWithTransparency() {
        return this.subSurface.linkRefractionWithTransparency;
      }
      set linkRefractionWithTransparency(value) {
        this.subSurface.linkRefractionWithTransparency = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        }
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      get usePhysicalLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      set usePhysicalLightFalloff(value) {
        if (value !== this.usePhysicalLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      get useGLTFLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      set useGLTFLightFalloff(value) {
        if (value !== this.useGLTFLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * Gets the image processing configuration used either in this material.
       */
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      /**
       * Sets the Default image processing configuration used either in the this material.
       *
       * If sets to null, the scene one is in use.
       */
      set imageProcessingConfiguration(value) {
        this._attachImageProcessingConfiguration(value);
        this._markAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets whether the color curves effect is enabled.
       */
      get cameraColorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      /**
       * Sets whether the color curves effect is enabled.
       */
      set cameraColorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      get cameraColorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      set cameraColorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      /**
       * Gets whether tonemapping is enabled or not.
       */
      get cameraToneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      /**
       * Sets whether tonemapping is enabled or not
       */
      set cameraToneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      /**
       * The camera exposure used on this material.
       * This property is here and not in the camera to allow controlling exposure without full screen post process.
       * This corresponds to a photographic exposure.
       */
      get cameraExposure() {
        return this._imageProcessingConfiguration.exposure;
      }
      /**
       * The camera exposure used on this material.
       * This property is here and not in the camera to allow controlling exposure without full screen post process.
       * This corresponds to a photographic exposure.
       */
      set cameraExposure(value) {
        this._imageProcessingConfiguration.exposure = value;
      }
      /**
       * Gets The camera contrast used on this material.
       */
      get cameraContrast() {
        return this._imageProcessingConfiguration.contrast;
      }
      /**
       * Sets The camera contrast used on this material.
       */
      set cameraContrast(value) {
        this._imageProcessingConfiguration.contrast = value;
      }
      /**
       * Gets the Color Grading 2D Lookup Texture.
       */
      get cameraColorGradingTexture() {
        return this._imageProcessingConfiguration.colorGradingTexture;
      }
      /**
       * Sets the Color Grading 2D Lookup Texture.
       */
      set cameraColorGradingTexture(value) {
        this._imageProcessingConfiguration.colorGradingTexture = value;
      }
      /**
       * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
       * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
       * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
       * corresponding to low luminance, medium luminance, and high luminance areas respectively.
       */
      get cameraColorCurves() {
        return this._imageProcessingConfiguration.colorCurves;
      }
      /**
       * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
       * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
       * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
       * corresponding to low luminance, medium luminance, and high luminance areas respectively.
       */
      set cameraColorCurves(value) {
        this._imageProcessingConfiguration.colorCurves = value;
      }
      /**
       * Instantiates a new PBRMaterial instance.
       *
       * @param name The material name
       * @param scene The scene the material will be use in.
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, forceGLSL);
        this.directIntensity = 1;
        this.emissiveIntensity = 1;
        this.environmentIntensity = 1;
        this.specularIntensity = 1;
        this.disableBumpMap = false;
        this.ambientTextureStrength = 1;
        this.ambientTextureImpactOnAnalyticalLights = _PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this.metallicF0Factor = 1;
        this.metallicReflectanceColor = Color3.White();
        this.useOnlyMetallicFromMetallicReflectanceTexture = false;
        this.ambientColor = new Color3(0, 0, 0);
        this.albedoColor = new Color3(1, 1, 1);
        this.baseWeight = 1;
        this.reflectivityColor = new Color3(1, 1, 1);
        this.reflectionColor = new Color3(1, 1, 1);
        this.emissiveColor = new Color3(0, 0, 0);
        this.microSurface = 1;
        this.useLightmapAsShadowmap = false;
        this.useAlphaFromAlbedoTexture = false;
        this.forceAlphaTest = false;
        this.alphaCutOff = 0.4;
        this.useSpecularOverAlpha = true;
        this.useMicroSurfaceFromReflectivityMapAlpha = false;
        this.useRoughnessFromMetallicTextureAlpha = true;
        this.useRoughnessFromMetallicTextureGreen = false;
        this.useMetallnessFromMetallicTextureBlue = false;
        this.useAmbientOcclusionFromMetallicTextureRed = false;
        this.useAmbientInGrayScale = false;
        this.useAutoMicroSurfaceFromReflectivityMap = false;
        this.useRadianceOverAlpha = true;
        this.useObjectSpaceNormalMap = false;
        this.useParallax = false;
        this.useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this.disableLighting = false;
        this.forceIrradianceInFragment = false;
        this.maxSimultaneousLights = 4;
        this.invertNormalMapX = false;
        this.invertNormalMapY = false;
        this.twoSidedLighting = false;
        this.useAlphaFresnel = false;
        this.useLinearAlphaFresnel = false;
        this.environmentBRDFTexture = null;
        this.forceNormalForward = false;
        this.enableSpecularAntiAliasing = false;
        this.useHorizonOcclusion = true;
        this.useRadianceOcclusion = true;
        this.unlit = false;
        this.applyDecalMapAfterDetailMap = false;
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
      }
      /**
       * @returns the name of this material class.
       */
      getClassName() {
        return "PBRMaterial";
      }
      /**
       * Makes a duplicate of the current material.
       * @param name - name to use for the new material.
       * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
       * @param rootUrl defines the root URL to use to load textures
       * @returns cloned material instance
       */
      clone(name, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const clone = SerializationHelper.Clone(() => new _PBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });
        clone.id = name;
        clone.name = name;
        this.stencil.copyTo(clone.stencil);
        this._clonePlugins(clone, rootUrl);
        return clone;
      }
      /**
       * Serializes this PBR Material.
       * @returns - An object with the serialized material.
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.PBRMaterial";
        return serializationObject;
      }
      // Statics
      /**
       * Parses a PBR Material from a serialized object.
       * @param source - Serialized object.
       * @param scene - BJS scene instance.
       * @param rootUrl - url for the scene object
       * @returns - PBRMaterial
       */
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new _PBRMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._ParsePlugins(source, material, scene, rootUrl);
        if (source.clearCoat) {
          material.clearCoat.parse(source.clearCoat, scene, rootUrl);
        }
        if (source.anisotropy) {
          material.anisotropy.parse(source.anisotropy, scene, rootUrl);
        }
        if (source.brdf) {
          material.brdf.parse(source.brdf, scene, rootUrl);
        }
        if (source.sheen) {
          material.sheen.parse(source.sheen, scene, rootUrl);
        }
        if (source.subSurface) {
          material.subSurface.parse(source.subSurface, scene, rootUrl);
        }
        if (source.iridescence) {
          material.iridescence.parse(source.iridescence, scene, rootUrl);
        }
        return material;
      }
    };
    PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
    PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
    PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
    PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
    PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "directIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "specularIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "disableBumpMap", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseWeightTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureStrength", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "opacityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallic", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicF0Factor", void 0);
    __decorate([
      serializeAsColor3(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurfaceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "bumpTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
    ], PBRMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
      serializeAsColor3("ambient"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientColor", void 0);
    __decorate([
      serializeAsColor3("albedo"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoColor", void 0);
    __decorate([
      serialize("baseWeight"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseWeight", void 0);
    __decorate([
      serializeAsColor3("reflectivity"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityColor", void 0);
    __decorate([
      serializeAsColor3("reflection"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionColor", void 0);
    __decorate([
      serializeAsColor3("emissive"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurface", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "forceAlphaTest", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "useGLTFLightFalloff", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAlphaFresnel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceNormalForward", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "unlit", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    RegisterClass("BABYLON.PBRMaterial", PBRMaterial);
  }
});

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget;
var init_morphTarget = __esm({
  "node_modules/@babylonjs/core/Morph/morphTarget.js"() {
    init_tslib_es6();
    init_observable();
    init_engineStore();
    init_buffer();
    init_decorators();
    init_decorators_serialization();
    init_typeStore();
    MorphTarget = class _MorphTarget {
      /**
       * Gets or sets the influence of this target (ie. its weight in the overall morphing)
       */
      get influence() {
        return this._influence;
      }
      set influence(influence) {
        if (this._influence === influence) {
          return;
        }
        const previous = this._influence;
        this._influence = influence;
        if (this.onInfluenceChanged.hasObservers()) {
          this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
        }
      }
      /**
       * Gets or sets the animation properties override
       */
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride && this._scene) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      /**
       * Creates a new MorphTarget
       * @param name defines the name of the target
       * @param influence defines the influence to use
       * @param scene defines the scene the morphtarget belongs to
       */
      constructor(name, influence = 0, scene = null) {
        this.name = name;
        this.animations = [];
        this._positions = null;
        this._normals = null;
        this._tangents = null;
        this._uvs = null;
        this._uv2s = null;
        this._colors = null;
        this._uniqueId = 0;
        this.onInfluenceChanged = new Observable();
        this._onDataLayoutChanged = new Observable();
        this._animationPropertiesOverride = null;
        this.id = name;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.influence = influence;
        if (this._scene) {
          this._uniqueId = this._scene.getUniqueId();
        }
      }
      /**
       * Gets the unique ID of this manager
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Gets a boolean defining if the target contains position data
       */
      get hasPositions() {
        return !!this._positions;
      }
      /**
       * Gets a boolean defining if the target contains normal data
       */
      get hasNormals() {
        return !!this._normals;
      }
      /**
       * Gets a boolean defining if the target contains tangent data
       */
      get hasTangents() {
        return !!this._tangents;
      }
      /**
       * Gets a boolean defining if the target contains texture coordinates data
       */
      get hasUVs() {
        return !!this._uvs;
      }
      /**
       * Gets a boolean defining if the target contains texture coordinates 2 data
       */
      get hasUV2s() {
        return !!this._uv2s;
      }
      get hasColors() {
        return !!this._colors;
      }
      /**
       * Gets the number of vertices stored in this target
       */
      get vertexCount() {
        return this._positions ? this._positions.length / 3 : this._normals ? this._normals.length / 3 : this._tangents ? this._tangents.length / 3 : this._uvs ? this._uvs.length / 2 : this._uv2s ? this._uv2s.length / 2 : this._colors ? this._colors.length / 4 : 0;
      }
      /**
       * Affects position data to this target
       * @param data defines the position data to use
       */
      setPositions(data) {
        const hadPositions = this.hasPositions;
        this._positions = data;
        if (hadPositions !== this.hasPositions) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the position data stored in this target
       * @returns a FloatArray containing the position data (or null if not present)
       */
      getPositions() {
        return this._positions;
      }
      /**
       * Affects normal data to this target
       * @param data defines the normal data to use
       */
      setNormals(data) {
        const hadNormals = this.hasNormals;
        this._normals = data;
        if (hadNormals !== this.hasNormals) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the normal data stored in this target
       * @returns a FloatArray containing the normal data (or null if not present)
       */
      getNormals() {
        return this._normals;
      }
      /**
       * Affects tangent data to this target
       * @param data defines the tangent data to use
       */
      setTangents(data) {
        const hadTangents = this.hasTangents;
        this._tangents = data;
        if (hadTangents !== this.hasTangents) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the tangent data stored in this target
       * @returns a FloatArray containing the tangent data (or null if not present)
       */
      getTangents() {
        return this._tangents;
      }
      /**
       * Affects texture coordinates data to this target
       * @param data defines the texture coordinates data to use
       */
      setUVs(data) {
        const hadUVs = this.hasUVs;
        this._uvs = data;
        if (hadUVs !== this.hasUVs) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the texture coordinates data stored in this target
       * @returns a FloatArray containing the texture coordinates data (or null if not present)
       */
      getUVs() {
        return this._uvs;
      }
      /**
       * Affects texture coordinates 2 data to this target
       * @param data defines the texture coordinates 2 data to use
       */
      setUV2s(data) {
        const hadUV2s = this.hasUV2s;
        this._uv2s = data;
        if (hadUV2s !== this.hasUV2s) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the texture coordinates 2 data stored in this target
       * @returns a FloatArray containing the texture coordinates 2 data (or null if not present)
       */
      getUV2s() {
        return this._uv2s;
      }
      /**
       * Affects color data to this target
       * @param data defines the color data to use
       */
      setColors(data) {
        const hadColors = this.hasColors;
        this._colors = data;
        if (hadColors !== this.hasColors) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the color data stored in this target
       * @returns a FloatArray containing the color data (or null if not present)
       */
      getColors() {
        return this._colors;
      }
      /**
       * Clone the current target
       * @returns a new MorphTarget
       */
      clone() {
        const newOne = SerializationHelper.Clone(() => new _MorphTarget(this.name, this.influence, this._scene), this);
        newOne._positions = this._positions;
        newOne._normals = this._normals;
        newOne._tangents = this._tangents;
        newOne._uvs = this._uvs;
        newOne._uv2s = this._uv2s;
        newOne._colors = this._colors;
        return newOne;
      }
      /**
       * Serializes the current target into a Serialization object
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.influence = this.influence;
        serializationObject.positions = Array.prototype.slice.call(this.getPositions());
        if (this.id != null) {
          serializationObject.id = this.id;
        }
        if (this.hasNormals) {
          serializationObject.normals = Array.prototype.slice.call(this.getNormals());
        }
        if (this.hasTangents) {
          serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
        }
        if (this.hasUVs) {
          serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
        }
        if (this.hasUV2s) {
          serializationObject.uv2s = Array.prototype.slice.call(this.getUV2s());
        }
        if (this.hasColors) {
          serializationObject.colors = Array.prototype.slice.call(this.getColors());
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      }
      /**
       * Returns the string "MorphTarget"
       * @returns "MorphTarget"
       */
      getClassName() {
        return "MorphTarget";
      }
      // Statics
      /**
       * Creates a new target from serialized data
       * @param serializationObject defines the serialized data to use
       * @param scene defines the hosting scene
       * @returns a new MorphTarget
       */
      static Parse(serializationObject, scene) {
        const result = new _MorphTarget(serializationObject.name, serializationObject.influence);
        result.setPositions(serializationObject.positions);
        if (serializationObject.id != null) {
          result.id = serializationObject.id;
        }
        if (serializationObject.normals) {
          result.setNormals(serializationObject.normals);
        }
        if (serializationObject.tangents) {
          result.setTangents(serializationObject.tangents);
        }
        if (serializationObject.uvs) {
          result.setUVs(serializationObject.uvs);
        }
        if (serializationObject.uv2s) {
          result.setUV2s(serializationObject.uv2s);
        }
        if (serializationObject.colors) {
          result.setColors(serializationObject.colors);
        }
        if (serializationObject.animations) {
          for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
            const parsedAnimation = serializationObject.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              result.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          if (serializationObject.autoAnimate && scene) {
            scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1);
          }
        }
        return result;
      }
      /**
       * Creates a MorphTarget from mesh data
       * @param mesh defines the source mesh
       * @param name defines the name to use for the new target
       * @param influence defines the influence to attach to the target
       * @returns a new MorphTarget
       */
      static FromMesh(mesh, name, influence) {
        if (!name) {
          name = mesh.name;
        }
        const result = new _MorphTarget(name, influence, mesh.getScene());
        result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          result.setUV2s(mesh.getVerticesData(VertexBuffer.UV2Kind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          result.setColors(mesh.getVerticesData(VertexBuffer.ColorKind));
        }
        return result;
      }
    };
    __decorate([
      serialize()
    ], MorphTarget.prototype, "id", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray;
var init_rawTexture2DArray = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js"() {
    init_texture();
    RawTexture2DArray = class _RawTexture2DArray extends Texture {
      /**
       * Gets the number of layers of the texture
       */
      get depth() {
        return this._depth;
      }
      /**
       * Create a new RawTexture2DArray
       * @param data defines the data of the texture
       * @param width defines the width of the texture
       * @param height defines the height of the texture
       * @param depth defines the number of layers of the texture
       * @param format defines the texture format to use
       * @param scene defines the hosting scene
       * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
       * @param invertY defines if texture must be stored with Y axis inverted
       * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
       * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       */
      constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {
        super(null, scene, !generateMipMaps, invertY);
        this.format = format;
        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);
        this._depth = depth;
        this.is2DArray = true;
      }
      /**
       * Update the texture with new data
       * @param data defines the data to store in the texture
       */
      update(data) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
      }
      /**
       * Creates a RGBA texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param depth defines the number of layers of the texture
       * @param scene defines the scene the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @returns the RGBA texture
       */
      static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {
        return new _RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
      }
    };
  }
});

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager;
var init_morphTargetManager = __esm({
  "node_modules/@babylonjs/core/Morph/morphTargetManager.js"() {
    init_smartArray();
    init_logger();
    init_engineStore();
    init_morphTarget();
    init_rawTexture2DArray();
    MorphTargetManager = class _MorphTargetManager {
      /**
       * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers
       */
      set areUpdatesFrozen(block) {
        if (block) {
          this._blockCounter++;
        } else {
          this._blockCounter--;
          if (this._blockCounter <= 0) {
            this._blockCounter = 0;
            this._syncActiveTargets(this._forceUpdateWhenUnfrozen);
            this._forceUpdateWhenUnfrozen = false;
          }
        }
      }
      get areUpdatesFrozen() {
        return this._blockCounter > 0;
      }
      /**
       * Creates a new MorphTargetManager
       * @param scene defines the current scene
       */
      constructor(scene = null) {
        this._targets = new Array();
        this._targetInfluenceChangedObservers = new Array();
        this._targetDataLayoutChangedObservers = new Array();
        this._activeTargets = new SmartArray(16);
        this._supportsPositions = false;
        this._supportsNormals = false;
        this._supportsTangents = false;
        this._supportsUVs = false;
        this._supportsUV2s = false;
        this._supportsColors = false;
        this._vertexCount = 0;
        this._uniqueId = 0;
        this._tempInfluences = new Array();
        this._canUseTextureForTargets = false;
        this._blockCounter = 0;
        this._mustSynchronize = true;
        this._forceUpdateWhenUnfrozen = false;
        this._textureVertexStride = 0;
        this._textureWidth = 0;
        this._textureHeight = 1;
        this._parentContainer = null;
        this.optimizeInfluencers = true;
        this.enablePositionMorphing = true;
        this.enableNormalMorphing = true;
        this.enableTangentMorphing = true;
        this.enableUVMorphing = true;
        this.enableUV2Morphing = true;
        this.enableColorMorphing = true;
        this._numMaxInfluencers = 0;
        this._useTextureToStoreTargets = true;
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        this._scene = scene;
        if (this._scene) {
          this._scene.addMorphTargetManager(this);
          this._uniqueId = this._scene.getUniqueId();
          const engineCaps = this._scene.getEngine().getCaps();
          this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;
        }
      }
      /**
       * Gets or sets the maximum number of influencers (targets) (default value: 0).
       * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.
       * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.
       * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.
       * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.
       * Note that this property has no effect if "useTextureToStoreTargets" is false.
       */
      get numMaxInfluencers() {
        return this._numMaxInfluencers;
      }
      set numMaxInfluencers(value) {
        if (this._numMaxInfluencers === value) {
          return;
        }
        this._numMaxInfluencers = value;
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Gets the unique ID of this manager
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Gets the number of vertices handled by this manager
       */
      get vertexCount() {
        return this._vertexCount;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of positions
       */
      get supportsPositions() {
        return this._supportsPositions && this.enablePositionMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of normals
       */
      get supportsNormals() {
        return this._supportsNormals && this.enableNormalMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of tangents
       */
      get supportsTangents() {
        return this._supportsTangents && this.enableTangentMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of texture coordinates
       */
      get supportsUVs() {
        return this._supportsUVs && this.enableUVMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of texture coordinates 2
       */
      get supportsUV2s() {
        return this._supportsUV2s && this.enableUV2Morphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of colors
       */
      get supportsColors() {
        return this._supportsColors && this.enableColorMorphing;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing positions
       */
      get hasPositions() {
        return this._supportsPositions;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing normals
       */
      get hasNormals() {
        return this._supportsNormals;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing tangents
       */
      get hasTangents() {
        return this._supportsTangents;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing texture coordinates
       */
      get hasUVs() {
        return this._supportsUVs;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing texture coordinates 2
       */
      get hasUV2s() {
        return this._supportsUV2s;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing colors
       */
      get hasColors() {
        return this._supportsColors;
      }
      /**
       * Gets the number of targets stored in this manager
       */
      get numTargets() {
        return this._targets.length;
      }
      /**
       * Gets the number of influencers (ie. the number of targets with influences > 0)
       */
      get numInfluencers() {
        return this._activeTargets.length;
      }
      /**
       * Gets the list of influences (one per target)
       */
      get influences() {
        return this._influences;
      }
      /**
       * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).
       * Please note that this option is not available if the hardware does not support it
       */
      get useTextureToStoreTargets() {
        return this._useTextureToStoreTargets;
      }
      set useTextureToStoreTargets(value) {
        if (this._useTextureToStoreTargets === value) {
          return;
        }
        this._useTextureToStoreTargets = value;
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)
       */
      get isUsingTextureForTargets() {
        var _a;
        return _MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !((_a = this._scene) == null ? void 0 : _a.getEngine().getCaps().disableMorphTargetTexture);
      }
      /**
       * Gets the active target at specified index. An active target is a target with an influence > 0
       * @param index defines the index to check
       * @returns the requested target
       */
      getActiveTarget(index) {
        return this._activeTargets.data[index];
      }
      /**
       * Gets the target at specified index
       * @param index defines the index to check
       * @returns the requested target
       */
      getTarget(index) {
        return this._targets[index];
      }
      /**
       * Gets the first target with the specified name
       * @param name defines the name to check
       * @returns the requested target
       */
      getTargetByName(name) {
        for (const target of this._targets) {
          if (target.name === name) {
            return target;
          }
        }
        return null;
      }
      /**
       * Add a new target to this manager
       * @param target defines the target to add
       */
      addTarget(target) {
        this._targets.push(target);
        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {
          if (this.areUpdatesFrozen && needUpdate) {
            this._forceUpdateWhenUnfrozen = true;
          }
          this._syncActiveTargets(needUpdate);
        }));
        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {
          this._mustSynchronize = true;
          this._syncActiveTargets();
        }));
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Removes a target from the manager
       * @param target defines the target to remove
       */
      removeTarget(target) {
        const index = this._targets.indexOf(target);
        if (index >= 0) {
          this._targets.splice(index, 1);
          target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
          target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
          this._mustSynchronize = true;
          this._syncActiveTargets();
        }
        if (this._scene) {
          this._scene.stopAnimation(target);
        }
      }
      /**
       * @internal
       */
      _bind(effect) {
        effect.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight);
        effect.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices);
        effect.setTexture("morphTargets", this._targetStoreTexture);
        effect.setInt("morphTargetCount", this.numInfluencers);
      }
      /**
       * Clone the current manager
       * @returns a new MorphTargetManager
       */
      clone() {
        const copy = new _MorphTargetManager(this._scene);
        for (const target of this._targets) {
          copy.addTarget(target.clone());
        }
        copy.enablePositionMorphing = this.enablePositionMorphing;
        copy.enableNormalMorphing = this.enableNormalMorphing;
        copy.enableTangentMorphing = this.enableTangentMorphing;
        copy.enableUVMorphing = this.enableUVMorphing;
        copy.enableUV2Morphing = this.enableUV2Morphing;
        copy.enableColorMorphing = this.enableColorMorphing;
        return copy;
      }
      /**
       * Serializes the current manager into a Serialization object
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.id = this.uniqueId;
        serializationObject.targets = [];
        for (const target of this._targets) {
          serializationObject.targets.push(target.serialize());
        }
        return serializationObject;
      }
      _syncActiveTargets(needUpdate = false) {
        if (this.areUpdatesFrozen) {
          return;
        }
        const wasUsingTextureForTargets = !!this._targetStoreTexture;
        const isUsingTextureForTargets = this.isUsingTextureForTargets;
        if (this._mustSynchronize || wasUsingTextureForTargets !== isUsingTextureForTargets) {
          this._mustSynchronize = false;
          this.synchronize();
        }
        let influenceCount = 0;
        this._activeTargets.reset();
        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {
          this._morphTargetTextureIndices = new Float32Array(this._targets.length);
        }
        let targetIndex = -1;
        for (const target of this._targets) {
          targetIndex++;
          if (target.influence === 0 && this.optimizeInfluencers) {
            continue;
          }
          if (this._activeTargets.length >= _MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {
            break;
          }
          this._activeTargets.push(target);
          this._morphTargetTextureIndices[influenceCount] = targetIndex;
          this._tempInfluences[influenceCount++] = target.influence;
        }
        if (this._morphTargetTextureIndices.length !== influenceCount) {
          this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);
        }
        if (!this._influences || this._influences.length !== influenceCount) {
          this._influences = new Float32Array(influenceCount);
        }
        for (let index = 0; index < influenceCount; index++) {
          this._influences[index] = this._tempInfluences[index];
        }
        if (needUpdate && this._scene) {
          for (const mesh of this._scene.meshes) {
            if (mesh.morphTargetManager === this) {
              if (isUsingTextureForTargets) {
                mesh._markSubMeshesAsAttributesDirty();
              } else {
                mesh._syncGeometryWithMorphTargetManager();
              }
            }
          }
        }
      }
      /**
       * Synchronize the targets with all the meshes using this morph target manager
       */
      synchronize() {
        var _a;
        if (!this._scene || this.areUpdatesFrozen) {
          return;
        }
        const engine = this._scene.getEngine();
        this._supportsPositions = true;
        this._supportsNormals = true;
        this._supportsTangents = true;
        this._supportsUVs = true;
        this._supportsUV2s = true;
        this._supportsColors = true;
        this._vertexCount = 0;
        (_a = this._targetStoreTexture) == null ? void 0 : _a.dispose();
        this._targetStoreTexture = null;
        if (this.isUsingTextureForTargets && this._targets.length > engine.getCaps().texture2DArrayMaxLayerCount) {
          this.useTextureToStoreTargets = false;
        }
        for (const target of this._targets) {
          this._supportsPositions = this._supportsPositions && target.hasPositions;
          this._supportsNormals = this._supportsNormals && target.hasNormals;
          this._supportsTangents = this._supportsTangents && target.hasTangents;
          this._supportsUVs = this._supportsUVs && target.hasUVs;
          this._supportsUV2s = this._supportsUV2s && target.hasUV2s;
          this._supportsColors = this._supportsColors && target.hasColors;
          const vertexCount = target.vertexCount;
          if (this._vertexCount === 0) {
            this._vertexCount = vertexCount;
          } else if (this._vertexCount !== vertexCount) {
            Logger.Error(`Incompatible target. Targets must all have the same vertices count. Current vertex count: ${this._vertexCount}, vertex count for target "${target.name}": ${vertexCount}`);
            return;
          }
        }
        if (this.isUsingTextureForTargets) {
          this._textureVertexStride = 0;
          this._supportsPositions && this._textureVertexStride++;
          this._supportsNormals && this._textureVertexStride++;
          this._supportsTangents && this._textureVertexStride++;
          this._supportsUVs && this._textureVertexStride++;
          this._supportsUV2s && this._textureVertexStride++;
          this._supportsColors && this._textureVertexStride++;
          this._textureWidth = this._vertexCount * this._textureVertexStride || 1;
          this._textureHeight = 1;
          const maxTextureSize = engine.getCaps().maxTextureSize;
          if (this._textureWidth > maxTextureSize) {
            this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);
            this._textureWidth = maxTextureSize;
          }
          const targetCount = this._targets.length;
          const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);
          let offset = 0;
          for (let index = 0; index < targetCount; index++) {
            const target = this._targets[index];
            const positions = target.getPositions();
            const normals = target.getNormals();
            const uvs = target.getUVs();
            const tangents = target.getTangents();
            const uv2s = target.getUV2s();
            const colors = target.getColors();
            offset = index * this._textureWidth * this._textureHeight * 4;
            for (let vertex = 0; vertex < this._vertexCount; vertex++) {
              if (this._supportsPositions && positions) {
                data[offset] = positions[vertex * 3];
                data[offset + 1] = positions[vertex * 3 + 1];
                data[offset + 2] = positions[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsNormals && normals) {
                data[offset] = normals[vertex * 3];
                data[offset + 1] = normals[vertex * 3 + 1];
                data[offset + 2] = normals[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsUVs && uvs) {
                data[offset] = uvs[vertex * 2];
                data[offset + 1] = uvs[vertex * 2 + 1];
                offset += 4;
              }
              if (this._supportsTangents && tangents) {
                data[offset] = tangents[vertex * 3];
                data[offset + 1] = tangents[vertex * 3 + 1];
                data[offset + 2] = tangents[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsUV2s && uv2s) {
                data[offset] = uv2s[vertex * 2];
                data[offset + 1] = uv2s[vertex * 2 + 1];
                offset += 4;
              }
              if (this._supportsColors && colors) {
                data[offset] = colors[vertex * 4];
                data[offset + 1] = colors[vertex * 4 + 1];
                data[offset + 2] = colors[vertex * 4 + 2];
                data[offset + 3] = colors[vertex * 4 + 3];
                offset += 4;
              }
            }
          }
          this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);
          this._targetStoreTexture.name = `Morph texture_${this.uniqueId}`;
        }
        for (const mesh of this._scene.meshes) {
          if (mesh.morphTargetManager === this) {
            mesh._syncGeometryWithMorphTargetManager();
          }
        }
      }
      /**
       * Release all resources
       */
      dispose() {
        if (this._targetStoreTexture) {
          this._targetStoreTexture.dispose();
        }
        this._targetStoreTexture = null;
        if (this._scene) {
          this._scene.removeMorphTargetManager(this);
          if (this._parentContainer) {
            const index = this._parentContainer.morphTargetManagers.indexOf(this);
            if (index > -1) {
              this._parentContainer.morphTargetManagers.splice(index, 1);
            }
            this._parentContainer = null;
          }
          for (const morph of this._targets) {
            this._scene.stopAnimation(morph);
          }
        }
      }
      // Statics
      /**
       * Creates a new MorphTargetManager from serialized data
       * @param serializationObject defines the serialized data
       * @param scene defines the hosting scene
       * @returns the new MorphTargetManager
       */
      static Parse(serializationObject, scene) {
        const result = new _MorphTargetManager(scene);
        for (const targetData of serializationObject.targets) {
          result.addTarget(MorphTarget.Parse(targetData, scene));
        }
        return result;
      }
    };
    MorphTargetManager.EnableTextureStorage = true;
    MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js
var RawCubeTexture;
var init_rawCubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js"() {
    init_decorators_serialization();
    init_environmentTextureTools();
    init_cubeTexture();
    RawCubeTexture = class _RawCubeTexture extends CubeTexture {
      /**
       * Creates a cube texture where the raw buffers are passed in.
       * @param scene defines the scene the texture is attached to
       * @param data defines the array of data to use to create each face
       * @param size defines the size of the textures
       * @param format defines the format of the data
       * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)
       * @param generateMipMaps  defines if the engine should generate the mip levels
       * @param invertY defines if data must be stored with Y axis inverted
       * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
       * @param compression defines the compression used (null by default)
       */
      constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {
        super("", scene);
        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);
      }
      /**
       * Updates the raw cube texture.
       * @param data defines the data to store
       * @param format defines the data format
       * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)
       * @param invertY defines if data must be stored with Y axis inverted
       * @param compression defines the compression used (null by default)
       */
      update(data, format, type, invertY, compression = null) {
        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);
      }
      /**
       * Updates a raw cube texture with RGBD encoded data.
       * @param data defines the array of data [mipmap][face] to use to create each face
       * @param sphericalPolynomial defines the spherical polynomial for irradiance
       * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
       * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
       * @returns a promise that resolves when the operation is complete
       */
      updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {
        return _UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => {
        });
      }
      /**
       * Clones the raw cube texture.
       * @returns a new cube texture
       */
      clone() {
        return SerializationHelper.Clone(() => {
          const scene = this.getScene();
          const internalTexture = this._texture;
          const texture = new _RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
          if (internalTexture.source === 13) {
            texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);
          }
          return texture;
        }, this);
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js
function EncodeMesh(module, attributes, indices, options) {
  const encoderModule = module;
  let encoder = null;
  let meshBuilder = null;
  let mesh = null;
  let encodedNativeBuffer = null;
  const attributeIDs = {};
  const positionAttribute = attributes.find((a) => a.dracoName === "POSITION");
  if (!positionAttribute) {
    throw new Error("Position attribute is required for Draco encoding");
  }
  if (!indices) {
    const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;
    indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);
    for (let i = 0; i < positionVerticesCount; i++) {
      indices[i] = i;
    }
  }
  try {
    encoder = new encoderModule.Encoder();
    meshBuilder = new encoderModule.MeshBuilder();
    mesh = new encoderModule.Mesh();
    meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);
    const addAttributeMap = /* @__PURE__ */ new Map([
      [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],
      [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],
      [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],
      [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],
      [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],
      [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],
      [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)]
    ]);
    for (const attribute of attributes) {
      if (attribute.data instanceof Uint8ClampedArray) {
        attribute.data = new Uint8Array(attribute.data);
      }
      const addAttribute = addAttributeMap.get(attribute.data.constructor);
      const verticesCount = attribute.data.length / attribute.size;
      attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);
      if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {
        encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);
      }
    }
    if (options.method) {
      encoder.SetEncodingMethod(encoderModule[options.method]);
    }
    if (options.encodeSpeed !== void 0 && options.decodeSpeed !== void 0) {
      encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);
    }
    encodedNativeBuffer = new encoderModule.DracoInt8Array();
    const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);
    if (encodedLength <= 0) {
      throw new Error("Draco encoding failed.");
    }
    const encodedData = new Int8Array(encodedLength);
    for (let i = 0; i < encodedLength; i++) {
      encodedData[i] = encodedNativeBuffer.GetValue(i);
    }
    return { data: encodedData, attributeIDs };
  } finally {
    if (mesh) {
      encoderModule.destroy(mesh);
    }
    if (meshBuilder) {
      encoderModule.destroy(meshBuilder);
    }
    if (encoder) {
      encoderModule.destroy(encoder);
    }
    if (encodedNativeBuffer) {
      encoderModule.destroy(encodedNativeBuffer);
    }
  }
}
function EncoderWorkerFunction() {
  let encoderPromise;
  onmessage = (event) => {
    const message = event.data;
    switch (message.id) {
      case "init": {
        if (message.url) {
          importScripts(message.url);
        }
        const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};
        encoderPromise = DracoEncoderModule(initEncoderObject);
        postMessage({ id: "initDone" });
        break;
      }
      case "encodeMesh": {
        if (!encoderPromise) {
          throw new Error("Draco encoder module is not available");
        }
        encoderPromise.then((encoder) => {
          const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);
          postMessage({ id: "encodeMeshDone", encodedMeshData: result }, result ? [result.data.buffer] : void 0);
        });
        break;
      }
    }
  };
}
function DecodeMesh(module, data, attributeIDs, onIndicesData, onAttributeData) {
  const decoderModule = module;
  let decoder = null;
  let buffer = null;
  let geometry = null;
  try {
    decoder = new decoderModule.Decoder();
    buffer = new decoderModule.DecoderBuffer();
    buffer.Init(data, data.byteLength);
    let status;
    const type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH: {
        const mesh = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, mesh);
        if (!status.ok() || mesh.ptr === 0) {
          throw new Error(status.error_msg());
        }
        const numFaces = mesh.num_faces();
        const numIndices = numFaces * 3;
        const byteLength = numIndices * 4;
        const ptr = decoderModule._malloc(byteLength);
        try {
          decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
          const indices = new Uint32Array(numIndices);
          indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
          onIndicesData(indices);
        } finally {
          decoderModule._free(ptr);
        }
        geometry = mesh;
        break;
      }
      case decoderModule.POINT_CLOUD: {
        const pointCloud = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);
        if (!status.ok() || !pointCloud.ptr) {
          throw new Error(status.error_msg());
        }
        geometry = pointCloud;
        break;
      }
      default: {
        throw new Error(`Invalid geometry type ${type}`);
      }
    }
    const numPoints = geometry.num_points();
    const processAttribute = (decoder2, geometry2, kind, attribute) => {
      const dataType = attribute.data_type();
      const numComponents = attribute.num_components();
      const normalized = attribute.normalized();
      const byteStride = attribute.byte_stride();
      const byteOffset = attribute.byte_offset();
      const dataTypeInfo = {
        [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },
        [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },
        [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },
        [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },
        [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },
        [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },
        [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 }
      };
      const info = dataTypeInfo[dataType];
      if (!info) {
        throw new Error(`Invalid data type ${dataType}`);
      }
      const numValues = numPoints * numComponents;
      const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;
      const ptr = decoderModule._malloc(byteLength);
      try {
        decoder2.GetAttributeDataArrayForAllPoints(geometry2, attribute, dataType, byteLength, ptr);
        const data2 = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);
        onAttributeData(kind, data2.slice(), numComponents, byteOffset, byteStride, normalized);
      } finally {
        decoderModule._free(ptr);
      }
    };
    if (attributeIDs) {
      for (const kind in attributeIDs) {
        const id = attributeIDs[kind];
        const attribute = decoder.GetAttributeByUniqueId(geometry, id);
        processAttribute(decoder, geometry, kind, attribute);
      }
    } else {
      const dracoAttributeTypes = {
        position: decoderModule.POSITION,
        normal: decoderModule.NORMAL,
        color: decoderModule.COLOR,
        uv: decoderModule.TEX_COORD
      };
      for (const kind in dracoAttributeTypes) {
        const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);
        if (id !== -1) {
          const attribute = decoder.GetAttribute(geometry, id);
          processAttribute(decoder, geometry, kind, attribute);
        }
      }
    }
    return numPoints;
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    if (buffer) {
      decoderModule.destroy(buffer);
    }
    if (decoder) {
      decoderModule.destroy(decoder);
    }
  }
}
function DecoderWorkerFunction() {
  let decoderPromise;
  onmessage = (event) => {
    const message = event.data;
    switch (message.id) {
      case "init": {
        if (message.url) {
          importScripts(message.url);
        }
        const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};
        decoderPromise = DracoDecoderModule(initDecoderObject);
        postMessage({ id: "initDone" });
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then((decoder) => {
          const numPoints = DecodeMesh(decoder, message.dataView, message.attributes, (indices) => {
            postMessage({ id: "indices", data: indices }, [indices.buffer]);
          }, (kind, data, size, offset, stride, normalized) => {
            postMessage({ id: "attribute", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);
          });
          postMessage({ id: "decodeMeshDone", totalVertices: numPoints });
        });
        break;
      }
    }
  };
}
function initializeWebWorker(worker, wasmBinary, moduleUrl) {
  return new Promise((resolve, reject) => {
    const onError = (error) => {
      worker.removeEventListener("error", onError);
      worker.removeEventListener("message", onMessage);
      reject(error);
    };
    const onMessage = (event) => {
      if (event.data.id === "initDone") {
        worker.removeEventListener("error", onError);
        worker.removeEventListener("message", onMessage);
        resolve(worker);
      }
    };
    worker.addEventListener("error", onError);
    worker.addEventListener("message", onMessage);
    if (!wasmBinary) {
      worker.postMessage({
        id: "init",
        url: moduleUrl
      });
    } else {
      const clone = wasmBinary.slice(0);
      worker.postMessage({
        id: "init",
        url: moduleUrl,
        wasmBinary: clone
      }, [clone]);
    }
  });
}
var init_dracoCompressionWorker = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js"() {
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js
function _GetDefaultNumWorkers() {
  if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
    return 1;
  }
  return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
}
function _IsConfigurationAvailable(config) {
  return !!(config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === "object" || config.fallbackUrl);
}
var DracoCodec;
var init_dracoCodec = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js"() {
    init_tools();
    init_workerPool();
    init_dracoCompressionWorker();
    DracoCodec = class {
      /**
       * Constructor
       * @param configuration The configuration for the DracoCodec instance.
       */
      constructor(configuration) {
        if (configuration.workerPool) {
          this._workerPoolPromise = Promise.resolve(configuration.workerPool);
          return;
        }
        const wasmBinaryProvided = configuration.wasmBinary;
        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();
        const useWorkers = numberOfWorkers && typeof Worker === "function" && typeof URL === "function";
        const urlNeeded = useWorkers || !configuration.jsModule;
        const codecInfo = configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === "object" ? {
          url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : "",
          wasmBinaryPromise: wasmBinaryProvided ? Promise.resolve(wasmBinaryProvided) : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true))
        } : {
          url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl) : "",
          wasmBinaryPromise: Promise.resolve(void 0)
        };
        if (useWorkers) {
          this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {
            const workerContent = this._getWorkerContent();
            const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
            return new AutoReleaseWorkerPool(numberOfWorkers, () => {
              const worker = new Worker(workerBlobUrl);
              return initializeWebWorker(worker, wasmBinary, codecInfo.url);
            });
          });
        } else {
          this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {
            if (!this._isModuleAvailable()) {
              if (!configuration.jsModule) {
                if (!codecInfo.url) {
                  throw new Error("Draco codec module is not available");
                }
                await Tools.LoadBabylonScriptAsync(codecInfo.url);
              }
            }
            return this._createModuleAsync(wasmBinary, configuration.jsModule);
          });
        }
      }
      /**
       * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.
       * @returns a promise that resolves when ready
       */
      async whenReadyAsync() {
        if (this._workerPoolPromise) {
          await this._workerPoolPromise;
          return;
        }
        if (this._modulePromise) {
          await this._modulePromise;
          return;
        }
      }
      /**
       * Stop all async operations and release resources.
       */
      dispose() {
        if (this._workerPoolPromise) {
          this._workerPoolPromise.then((workerPool) => {
            workerPool.dispose();
          });
        }
        delete this._workerPoolPromise;
        delete this._modulePromise;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/buffer.js
var init_buffer2 = __esm({
  "node_modules/@babylonjs/core/Meshes/buffer.js"() {
    init_buffer();
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js
var DracoDecoder;
var init_dracoDecoder = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js"() {
    init_dracoCodec();
    init_tools();
    init_geometry();
    init_buffer2();
    init_logger();
    init_dracoCompressionWorker();
    DracoDecoder = class _DracoDecoder extends DracoCodec {
      /**
       * Returns true if the decoder's `DefaultConfiguration` is available.
       */
      static get DefaultAvailable() {
        return _IsConfigurationAvailable(_DracoDecoder.DefaultConfiguration);
      }
      /**
       * Default instance for the DracoDecoder.
       */
      static get Default() {
        _DracoDecoder._Default ?? (_DracoDecoder._Default = new _DracoDecoder());
        return _DracoDecoder._Default;
      }
      /**
       * Reset the default DracoDecoder object to null and disposing the removed default instance.
       * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,
       * unless the static worker pool is no longer needed.
       * @param skipDispose set to true to not dispose the removed default instance
       */
      static ResetDefault(skipDispose) {
        if (_DracoDecoder._Default) {
          if (!skipDispose) {
            _DracoDecoder._Default.dispose();
          }
          _DracoDecoder._Default = null;
        }
      }
      _isModuleAvailable() {
        return typeof DracoDecoderModule !== "undefined";
      }
      async _createModuleAsync(wasmBinary, jsModule) {
        const module = await (jsModule || DracoDecoderModule)({ wasmBinary });
        return { module };
      }
      _getWorkerContent() {
        return `${DecodeMesh}(${DecoderWorkerFunction})()`;
      }
      /**
       * Creates a new Draco decoder.
       * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.
       */
      constructor(configuration = _DracoDecoder.DefaultConfiguration) {
        super(configuration);
      }
      /**
       * Decode Draco compressed mesh data to mesh data.
       * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data
       * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
       * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization
       * @returns A promise that resolves with the decoded mesh data
       */
      decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {
        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);
        const applyGltfNormalizedOverride = (kind, normalized) => {
          if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== void 0) {
            if (normalized !== gltfNormalizedOverride[kind]) {
              Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);
            }
            return gltfNormalizedOverride[kind];
          } else {
            return normalized;
          }
        };
        if (this._workerPoolPromise) {
          return this._workerPoolPromise.then((workerPool) => {
            return new Promise((resolve, reject) => {
              workerPool.push((worker, onComplete) => {
                let resultIndices = null;
                const resultAttributes = [];
                const onError = (error) => {
                  worker.removeEventListener("error", onError);
                  worker.removeEventListener("message", onMessage);
                  reject(error);
                  onComplete();
                };
                const onMessage = (event) => {
                  const message = event.data;
                  switch (message.id) {
                    case "indices": {
                      resultIndices = message.data;
                      break;
                    }
                    case "attribute": {
                      resultAttributes.push({
                        kind: message.kind,
                        data: message.data,
                        size: message.size,
                        byteOffset: message.byteOffset,
                        byteStride: message.byteStride,
                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized)
                      });
                      break;
                    }
                    case "decodeMeshDone": {
                      worker.removeEventListener("error", onError);
                      worker.removeEventListener("message", onMessage);
                      resolve({ indices: resultIndices, attributes: resultAttributes, totalVertices: message.totalVertices });
                      onComplete();
                      break;
                    }
                  }
                };
                worker.addEventListener("error", onError);
                worker.addEventListener("message", onMessage);
                const dataViewCopy = dataView.slice();
                worker.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
              });
            });
          });
        }
        if (this._modulePromise) {
          return this._modulePromise.then((decoder) => {
            let resultIndices = null;
            const resultAttributes = [];
            const numPoints = DecodeMesh(decoder.module, dataView, attributes, (indices) => {
              resultIndices = indices;
            }, (kind, data2, size, byteOffset, byteStride, normalized) => {
              resultAttributes.push({
                kind,
                data: data2,
                size,
                byteOffset,
                byteStride,
                normalized
              });
            });
            return { indices: resultIndices, attributes: resultAttributes, totalVertices: numPoints };
          });
        }
        throw new Error("Draco decoder module is not available");
      }
      /**
       * Decode Draco compressed mesh data to Babylon geometry.
       * @param name The name to use when creating the geometry
       * @param scene The scene to use when creating the geometry
       * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data
       * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
       * @returns A promise that resolves with the decoded geometry
       */
      async decodeMeshToGeometryAsync(name, scene, data, attributes) {
        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);
        const geometry = new Geometry(name, scene);
        if (meshData.indices) {
          geometry.setIndices(meshData.indices);
        }
        for (const attribute of meshData.attributes) {
          geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
        }
        return geometry;
      }
      /** @internal */
      async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo) {
        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);
        const geometry = new Geometry(name, scene);
        if (boundingInfo) {
          geometry._boundingInfo = boundingInfo;
          geometry.useBoundingInfoFromGeometry = true;
        }
        if (meshData.indices) {
          geometry.setIndices(meshData.indices);
        }
        for (const attribute of meshData.attributes) {
          geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
        }
        return geometry;
      }
    };
    DracoDecoder.DefaultConfiguration = {
      wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,
      wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,
      fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`
    };
    DracoDecoder._Default = null;
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var NumberOfWorkers, WorkerTimeout, MeshoptCompression;
var init_meshoptCompression = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js"() {
    init_tools();
    NumberOfWorkers = 0;
    WorkerTimeout = null;
    MeshoptCompression = class _MeshoptCompression {
      /**
       * Default instance for the meshoptimizer object.
       */
      static get Default() {
        if (!_MeshoptCompression._Default) {
          _MeshoptCompression._Default = new _MeshoptCompression();
        }
        return _MeshoptCompression._Default;
      }
      /**
       * Constructor
       */
      constructor() {
        const decoder = _MeshoptCompression.Configuration.decoder;
        this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {
          return MeshoptDecoder.ready;
        });
      }
      /**
       * Stop all async operations and release resources.
       */
      dispose() {
        delete this._decoderModulePromise;
      }
      /**
       * Decode meshopt data.
       * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder
       * @param source The input data.
       * @param count The number of elements.
       * @param stride The stride in bytes.
       * @param mode The compression mode.
       * @param filter The compression filter.
       * @returns a Promise<Uint8Array> that resolves to the decoded data
       */
      decodeGltfBufferAsync(source, count, stride, mode, filter) {
        return this._decoderModulePromise.then(async () => {
          if (NumberOfWorkers === 0) {
            MeshoptDecoder.useWorkers(1);
            NumberOfWorkers = 1;
          }
          const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);
          if (WorkerTimeout !== null) {
            clearTimeout(WorkerTimeout);
          }
          WorkerTimeout = setTimeout(() => {
            MeshoptDecoder.useWorkers(0);
            NumberOfWorkers = 0;
            WorkerTimeout = null;
          }, 1e3);
          return result;
        });
      }
    };
    MeshoptCompression.Configuration = {
      decoder: {
        url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`
      }
    };
    MeshoptCompression._Default = null;
  }
});

// node_modules/@babylonjs/core/Misc/deepMerger.js
function deepMerge(...objects) {
  const isRecord = (obj) => !!obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = pVal.concat(...oVal);
      } else if (isRecord(pVal) && isRecord(oVal)) {
        prev[key] = deepMerge(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}
var init_deepMerger = __esm({
  "node_modules/@babylonjs/core/Misc/deepMerger.js"() {
  }
});

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred;
var init_deferred = __esm({
  "node_modules/@babylonjs/core/Misc/deferred.js"() {
    Deferred = class {
      /**
       * The resolve method of the promise associated with this deferred object.
       */
      get resolve() {
        return this._resolve;
      }
      /**
       * The reject method of the promise associated with this deferred object.
       */
      get reject() {
        return this._reject;
      }
      /**
       * Constructor for this deferred object.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader;
var init_dataReader = __esm({
  "node_modules/@babylonjs/core/Misc/dataReader.js"() {
    init_stringTools();
    DataReader = class {
      /**
       * Constructor
       * @param buffer The buffer to read
       */
      constructor(buffer) {
        this.byteOffset = 0;
        this.buffer = buffer;
      }
      /**
       * Loads the given byte length.
       * @param byteLength The byte length to load
       * @returns A promise that resolves when the load is complete
       */
      loadAsync(byteLength) {
        return this.buffer.readAsync(this.byteOffset, byteLength).then((data) => {
          this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
          this._dataByteOffset = 0;
        });
      }
      /**
       * Read a unsigned 32-bit integer from the currently loaded data range.
       * @returns The 32-bit integer read
       */
      readUint32() {
        const value = this._dataView.getUint32(this._dataByteOffset, true);
        this._dataByteOffset += 4;
        this.byteOffset += 4;
        return value;
      }
      /**
       * Read a byte array from the currently loaded data range.
       * @param byteLength The byte length to read
       * @returns The byte array read
       */
      readUint8Array(byteLength) {
        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
        return value;
      }
      /**
       * Read a string from the currently loaded data range.
       * @param byteLength The byte length to read
       * @returns The string read
       */
      readString(byteLength) {
        return Decode(this.readUint8Array(byteLength));
      }
      /**
       * Skips the given byte length the currently loaded data range.
       * @param byteLength The byte length to skip
       */
      skipBytes(byteLength) {
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
var init_thinInstanceMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js"() {
    init_mesh();
    init_buffer();
    init_math_vector();
    init_logger();
    init_boundingInfo();
    Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
      if (!this.getScene().getEngine().getCaps().instancedArrays) {
        Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
        return -1;
      }
      this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
      const index = this._thinInstanceDataStorage.instancesCount;
      if (Array.isArray(matrix)) {
        for (let i = 0; i < matrix.length; ++i) {
          this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
        }
      } else {
        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
      }
      return index;
    };
    Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
      return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
    };
    Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      this.removeVerticesData(kind);
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
      this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    };
    Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
      if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      matrix.copyToArray(matrixData, index * 16);
      if (this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices[index] = matrix;
      }
      if (refresh) {
        this.thinInstanceBufferUpdated("matrix");
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      return true;
    };
    Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      this._thinInstanceUpdateBufferSize(kind, 0);
      this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
      if (refresh) {
        this.thinInstanceBufferUpdated(kind);
      }
      return true;
    };
    Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
      get: function() {
        return this._thinInstanceDataStorage.instancesCount;
      },
      set: function(value) {
        var _a;
        const matrixData = this._thinInstanceDataStorage.matrixData ?? ((_a = this.source) == null ? void 0 : _a._thinInstanceDataStorage.matrixData);
        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
        if (value <= numMaxInstances) {
          this._thinInstanceDataStorage.instancesCount = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = true) {
      const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
      for (let i = 0; i < 4; i++) {
        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
      }
      return matrixBuffer;
    };
    Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = true) {
      var _a, _b, _c;
      stride = stride || 16;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
        this._thinInstanceDataStorage.matrixData = buffer;
        this._thinInstanceDataStorage.worldMatrices = null;
        if (buffer !== null) {
          this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
          if (!this.doNotSyncBoundingInfo) {
            this.thinInstanceRefreshBoundingInfo(false);
          }
        } else {
          this._thinInstanceDataStorage.instancesCount = 0;
          if (!this.doNotSyncBoundingInfo) {
            this.refreshBoundingInfo();
          }
        }
      } else if (kind === "previousMatrix") {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
        this._thinInstanceDataStorage.previousMatrixData = buffer;
        if (buffer !== null) {
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (buffer === null) {
          if ((_c = this._userThinInstanceBuffersStorage) == null ? void 0 : _c.data[kind]) {
            this.removeVerticesData(kind);
            delete this._userThinInstanceBuffersStorage.data[kind];
            delete this._userThinInstanceBuffersStorage.strides[kind];
            delete this._userThinInstanceBuffersStorage.sizes[kind];
            delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
          }
        } else {
          this._thinInstanceInitializeUserStorage();
          this._userThinInstanceBuffersStorage.data[kind] = buffer;
          this._userThinInstanceBuffersStorage.strides[kind] = stride;
          this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
      var _a, _b, _c;
      if (kind === "matrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {
          this._thinInstanceRecreateBuffer(kind);
        }
        (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else if (kind === "previousMatrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {
          this._thinInstanceRecreateBuffer(kind);
        }
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_c = this._userThinInstanceBuffersStorage) == null ? void 0 : _c.vertexBuffers[kind]) {
          if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {
            this._thinInstanceRecreateBuffer(kind);
          }
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
        }
      }
    };
    Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
      var _a;
      if (kind === "matrix") {
        if (this._thinInstanceDataStorage.matrixBuffer) {
          this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_a = this._userThinInstanceBuffersStorage) == null ? void 0 : _a.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
        }
      }
    };
    Mesh.prototype.thinInstanceGetWorldMatrices = function() {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return [];
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (!this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices = [];
        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
          this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
        }
      }
      return this._thinInstanceDataStorage.worldMatrices;
    };
    Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return;
      }
      const vectors = this._thinInstanceDataStorage.boundingVectors;
      if (forceRefreshParentInfo || !this.rawBoundingInfo) {
        vectors.length = 0;
        this.refreshBoundingInfo(applySkeleton, applyMorph);
        const boundingInfo2 = this.getBoundingInfo();
        this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
      }
      const boundingInfo = this.getBoundingInfo();
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (vectors.length === 0) {
        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
          vectors.push(boundingInfo.boundingBox.vectors[v].clone());
        }
      }
      TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
      TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
      for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
        for (let v = 0; v < vectors.length; ++v) {
          Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
          TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
          TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
        }
      }
      boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
      this._updateBoundingInfo();
    };
    Mesh.prototype._thinInstanceRecreateBuffer = function(kind, staticBuffer = true) {
      var _a, _b, _c;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, staticBuffer);
      } else if (kind === "previousMatrix") {
        if (this._scene.needsPreviousWorldMatrices) {
          (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) == null ? void 0 : _c.dispose();
        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);
        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
      }
    };
    Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
      var _a, _b, _c;
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      const kindIsMatrix = kind === "matrix";
      if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
        return;
      }
      const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
      const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
      let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
      const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
      let newSize = currentSize;
      while (newSize < bufferSize) {
        newSize *= 2;
      }
      if (!data || currentSize != newSize) {
        if (!data) {
          data = new Float32Array(newSize);
        } else {
          const newData = new Float32Array(newSize);
          newData.set(data, 0);
          data = newData;
        }
        if (kindIsMatrix) {
          (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
          this._thinInstanceDataStorage.matrixData = data;
          this._thinInstanceDataStorage.matrixBufferSize = newSize;
          if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
            (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
          }
        } else {
          (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) == null ? void 0 : _c.dispose();
          this._userThinInstanceBuffersStorage.data[kind] = data;
          this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype._thinInstanceInitializeUserStorage = function() {
      if (!this._userThinInstanceBuffersStorage) {
        this._userThinInstanceBuffersStorage = {
          data: {},
          sizes: {},
          vertexBuffers: {},
          strides: {}
        };
      }
    };
    Mesh.prototype._disposeThinInstanceSpecificData = function() {
      var _a;
      if ((_a = this._thinInstanceDataStorage) == null ? void 0 : _a.matrixBuffer) {
        this._thinInstanceDataStorage.matrixBuffer.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
      }
    };
  }
});

export {
  AnimationEvent,
  init_animationEvent,
  AbstractAssetContainer,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  init_assetContainer,
  AudioEngine,
  init_audioEngine,
  Sound,
  init_sound,
  SoundTrack,
  init_soundTrack,
  AddParser,
  GetParser,
  AddIndividualParser,
  GetIndividualParser,
  Parse,
  init_babylonFileParser_function,
  AudioSceneComponent,
  init_audioSceneComponent,
  WeightedSound,
  init_weightedsound,
  Skeleton,
  init_skeleton,
  init_buffer2 as init_buffer,
  addToBlockFactory,
  blockFactory,
  init_flowGraphBlockFactory,
  GetDataOutConnectionByUniqueId,
  GetSignalInConnectionByUniqueId,
  ParseCoordinatorAsync,
  ParseFlowGraphAsync,
  ParseFlowGraph,
  ParseFlowGraphContext,
  ParseBlockAsync,
  ParseFlowGraphBlockWithClassType,
  ParseGraphConnectionWithClassType,
  ParseGraphDataConnection,
  init_flowGraphParser,
  DirectionalLight,
  init_directionalLight,
  CubeTexture,
  init_cubeTexture,
  GetEnvironmentBRDFTexture,
  BRDFTextureTools,
  init_brdfTextureTools,
  MaterialBRDFDefines,
  PBRBRDFConfiguration,
  init_pbrBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  init_pbrClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  init_pbrIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  init_pbrAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  init_pbrSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  init_pbrSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  init_pbrBaseMaterial,
  PBRMaterial,
  init_pbrMaterial,
  MorphTarget,
  init_morphTarget,
  RawTexture2DArray,
  init_rawTexture2DArray,
  MorphTargetManager,
  init_morphTargetManager,
  RawCubeTexture,
  init_rawCubeTexture,
  EncodeMesh,
  EncoderWorkerFunction,
  init_dracoCompressionWorker,
  _GetDefaultNumWorkers,
  _IsConfigurationAvailable,
  DracoCodec,
  init_dracoCodec,
  DracoDecoder,
  init_dracoDecoder,
  MeshoptCompression,
  init_meshoptCompression,
  deepMerge,
  init_deepMerger,
  init_thinInstanceMesh,
  Deferred,
  init_deferred,
  DataReader,
  init_dataReader
};
//# sourceMappingURL=chunk-SLMEJB4Z.js.map
