import {
  init_packingFunctions
} from "./chunk-WZJA22BE.js";
import {
  init_kernelBlurVaryingDeclaration
} from "./chunk-WME2ESWV.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-CTSQY2GW.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment.js
var name, shader;
var init_kernelBlurFragment = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment.js"() {
    init_shaderStore();
    name = "kernelBlurFragment";
    shader = `#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X})*computedWeight;
#endif
`;
    if (!ShaderStore.IncludesShadersStoreWGSL[name]) {
      ShaderStore.IncludesShadersStoreWGSL[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment2.js
var name2, shader2;
var init_kernelBlurFragment2 = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment2.js"() {
    init_shaderStore();
    name2 = "kernelBlurFragment2";
    shader2 = `#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;
    if (!ShaderStore.IncludesShadersStoreWGSL[name2]) {
      ShaderStore.IncludesShadersStoreWGSL[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.fragment.js
var name3, shader3, kernelBlurPixelShaderWGSL;
var init_kernelBlur_fragment = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.fragment.js"() {
    init_shaderStore();
    init_kernelBlurVaryingDeclaration();
    init_packingFunctions();
    init_kernelBlurFragment();
    init_kernelBlurFragment2();
    name3 = "kernelBlurPixelShader";
    shader3 = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;
#ifdef DOF
var circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;
#ifdef PACKEDFLOAT
var blend: f32=0.;
#else
var blend: vec4f= vec4f(0.);
#endif
#ifdef DOF
var sumOfWeights: f32=CENTER_WEIGHT; 
var factor: f32=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
fragmentOutputs.color=pack(blend);
#else
fragmentOutputs.color=blend;
#endif
#ifdef DOF
fragmentOutputs.color/=sumOfWeights;
#endif
}`;
    if (!ShaderStore.ShadersStoreWGSL[name3]) {
      ShaderStore.ShadersStoreWGSL[name3] = shader3;
    }
    kernelBlurPixelShaderWGSL = { name: name3, shader: shader3 };
  }
});

export {
  kernelBlurPixelShaderWGSL,
  init_kernelBlur_fragment
};
//# sourceMappingURL=chunk-2Z7DB4ZP.js.map
